{
  "hash": "578c327e38f3d16283fcc9df4e5910a3",
  "result": {
    "markdown": "---\ntitle: \"Assertions and Testing\"\nauthor: \"Zoe Vernon, Andrew Vaughn, James Duncan\"\ndate: \"2022-09-09\"\nformat:\n  pdf:\n    documentclass: article\n    margin-left: 30mm\n    margin-right: 30mm\n    toc: true\n  html:\n    theme: cosmo\n    css: ../../styles.css\n    toc: true\n    code-copy: true\n    code-block-background: true\nexecute:\n  freeze: auto\n---\n\n\n\n\n\n[PDF](./assertionsAndTesting.pdf){.btn .btn-primary}\n\n## References and useful links \n\n* [Testing section](http://r-pkgs.had.co.nz/tests.html) of the R packages tutorial by Hadley Wickham\n* [GitHub](https://github.com/hadley/assertthat) for assertthat package by Hadley Wickham\n* [Assertions and testing tutorial](https://swcarpentry.github.io/python-novice-inflammation/10-defensive/index.html) in Python\n\n## Learning Objectives\n  - Understand the benefits of assertions and testings as well as the differences between the two.\n  - Introduction to the R package `assertthat`. \n  - Introduction to the R package `testthat`. \n  - Practice writing assertions and tests on your own.  \n  \n## Purpose of Assertions and Testing\nWe all want our code   to be correct the first time we write it. The unfortunate reality is that we all make mistakes when coding, either because of \"silly mistakes\" (indexing errors,   incorrect syntax,  using a wrong variable name, etc.) or because of a fundamental misunderstanding of the problem we are trying to solve. While print statements and writing test cases can help reduce coding errors, it is desirable to have a formal, structured way to test our code to ensure that it is functioning how we want it to. It is here that the `assertthat` and `testthat` packages in R prove useful. \n\n\n## Assertion vs. Testing\n\nAssertions check the internal state of a function.  For example, consider a function ```add(x, y)``` which returns ```x + y```.  The function assumes ```x```  is numeric, and an assertion would confirm that this is in the case and return as error if not.  On the other hand, tests check that a function produces the expected output for various inputs.  For example, ensuring that ```add(1, 2)``` returns the number 3.  Tests may include checks that assertions are working properly.  \n\nTests and assertions are similar in that,\n\n- Both are part of ensuring programs run correctly and aspects of defensive programming.  \n- Both should check small pieces of the code while providing useful error messages, so they tell you exactly where the issue arises.  \n\nA couple of important differences between assertions and tests are below: \n\n| Assertions                                                               | Testing                                        |\n|--------------------------------------------------------------------------|------------------------------------------------|\n| Depends only on the object and method parameters.                        | Can depend on global variables.                |\n| Document function properties that are not public.                        | Can only check externally visible properties.  |\n| Work with live data, so check cover infinitely many cases.               | Test a small number of cases.                  |\n| Excecuted in function calls, so amount of computation should be limited. |                                                |\n\n## Assertions and `assertthat`\nAn assertion is a statement in a function or progam that must be true for it to continue.  There are three types of assertions: \n\n  1. Pre-conditions: statements that must be true at the beginning of the function for it to work.  Mostly, this involves checking that inputs to the function are in the expected form.\n  2. Invariants: statements that must be true at intermediate points in the function.  For example, checking that the output from a computation is positive before using the `sqrt()` function. \n  3. Post-conditions: statements that must be true at the end of a function.  For example, if you write a function that must return a vector of length `n` with all positive numbers you would ensure that is the case after all the computation has been performed.    \n\n`assertthat` is a R package that provides functionality for adding assertions to functions, while producing useful error messages.  Calls to `assert_that` are similar to `stopifnot` function from base R.  Consider the examples below: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\nstopifnot(is.character(x))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: is.character(x) is not TRUE\n```\n:::\n\n```{.r .cell-code}\nassert_that(is.character(x))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: x is not a character vector\n```\n:::\n\n```{.r .cell-code}\nassert_that(length(x) == 5)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: length(x) not equal to 5\n```\n:::\n\n```{.r .cell-code}\nassert_that(is.numeric(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n\nIn addition to giving useful error messages adding assertions to your function allows you to document exactly what your function expects.  This is particularly useful if you come back to the function after a while and need to recall exactly what it does.  \n\n`assertthat` can be installed either from CRAN or GitHub (CRAN is the stable version, GitHub usually has the current dev version):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages('assertthat')\ndevtools::install_github(\"hadley/assertthat\")\n```\n:::\n\n\n\n### Some Useful Assertions\n\nAs well as all the functions provided by R, assertthat provides a few more that are useful:\n\n  - `is.flag(x)`: is x TRUE or FALSE? (a boolean flag)\n  - `is.string(x)`: is x a length 1 character vector?\n  - `has_name(x, nm)`, `x %has_name% nm`: does x have component nm?\n  - `has_attr(x, attr)`, `x %has_attr% attr`: does x have attribute attr?\n  - `is.count(x)`: is x a single positive integer?\n  - `are_equal(x, y)`: are x and y equal?\n  - `not_empty(x)`: are all dimensions of x greater than 0?\n  - `noNA(x)`: is x free from missing values?\n  - `is.dir(path)`: is path a directory?\n  - `is.writeable(path)`/`is.readable(path)`: is path writeable/readable?\n  - `has_extension(path, extension)`: does file have given extension?\n\n### Three main functions: `assert_that`, `see_if`, and `validate_that`\n\nThese are the three primary functions from the package:\n\n  - `assert_that()` signals an error\n  - `see_if()` returns a logical value, with the error message as an attribute.\n  - `validate_that()` returns TRUE on success, otherwise returns the error as a string.\n  \nHere is an example of the differences.  When the assertion is `TRUE` they all return `TRUE` and continue with the excecution of the function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# example functions to see differences in assertthat functions\nreturnStringAssert <- function(x){\n  assert_that(is.string(x))\n  \n  return(x)\n}\nreturnStringSeeIf <- function(x){\n  see_if(is.string(x))\n  \n  return(x)\n}\nreturnStringValidate <- function(x){\n  validate_that(is.string(x))\n  \n  return(x)\n}\n\nreturnStringAssert(\"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n```\n:::\n\n```{.r .cell-code}\nreturnStringSeeIf(\"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n```\n:::\n\n```{.r .cell-code}\nreturnStringValidate(\"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n```\n:::\n:::\n\n\n  \nWhen the assertion is `FALSE` the functions have different output and function.  `assert_that` will return an error and halt excecution of the function.  `see_if` and `validate_that` will not stop the excecution.    \n\n\n::: {.cell}\n\n```{.r .cell-code}\nreturnStringAssert(c(\"a\", \"b\"))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: x is not a string (a length one character vector).\n```\n:::\n\n```{.r .cell-code}\nreturnStringSeeIf(c(\"a\", \"b\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"b\"\n```\n:::\n\n```{.r .cell-code}\nreturnStringValidate(c(\"a\", \"b\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"b\"\n```\n:::\n:::\n\n\nHowever, when called outside of function they will give the error messages as described above. \n\n`assert_that` returns an error \n\n\n::: {.cell}\n\n```{.r .cell-code}\nassert_that(is.string(c(\"a\", \"b\")))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: c(\"a\", \"b\") is not a string (a length one character vector).\n```\n:::\n:::\n\n\n\n`see_if` returns `FALSE` with an error message attribute \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsee_if(is.string(c(\"a\", \"b\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\nattr(,\"msg\")\n[1] \"c(\\\"a\\\", \\\"b\\\") is not a string (a length one character vector).\"\n```\n:::\n:::\n\n\n\n`validate_that` returns the error message as a string \n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalidate_that(is.string(c(\"a\", \"b\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"c(\\\"a\\\", \\\"b\\\") is not a string (a length one character vector).\"\n```\n:::\n:::\n\n\n\n### Writing Your Own Assertions\n\nYou can also write you own assertions with custom error messages.  There are two ways to do this. The first is using the `on_failure()` function. Below is an example of how this works: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_odd <- function(x) {\n  assert_that(is.numeric(x), length(x) == 1)\n  x %% 2 == 1\n}\nassert_that(is_odd(2))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: is_odd(x = 2) is not TRUE\n```\n:::\n\n```{.r .cell-code}\non_failure(is_odd) <- function(call, env) {\n  paste0(deparse(call$x), \" is even\")\n}\nassert_that(is_odd(2))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: 2 is even\n```\n:::\n:::\n\n\n\n\nAlso note theat the assertions from our original `is_odd()` function flow through the function call from `on_failure()`, so we still get the appropriate error messages when we pass a non-numeric or vector value to `is_odd()`.  \n\nAnother, option is to add a new assertion that checks whether the number is odd and add a custome message directly to the assertion: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_odd2 <- function(x) {\n  assert_that(is.numeric(x), length(x) == 1)\n  assert_that(x %% 2 == 1, msg = paste(x, \"is even\"))\n  x %% 2 == 1\n}\nassert_that(is_odd2(2))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: 2 is even\n```\n:::\n:::\n\n\n\n## Testing\n\nAssertions allow us to check aspects of functions as they are being excuted, while unit tests\nhelp ensure the output from a function is what we expect.  A common approach to testing is to use the command line to informally check whether your code works on a few examples.  Units tests are a more formal framework for testing that allows you to continue running the same tests as you update your function.  Hadley Wickam describes four main areas that proper testings will help improve your code: \n\n  1. **Fewer bugs**: When setting up unit tests you have a formal place that describes your expectation of function behavior.  Having two places where the function is document allows you to check one against the other.  \n  2. **Better code structure**: Tests should only check accuracy of small portions of code, so that you can easily find the source of error.  This forces you to write more modular code.\n  3. **Easier restarts**: Tests help you remember where you left off and what the next step in your code should be.  It is good practice to write tests first, followed by the function to execute the desired result.  \n  4. **Robust code**: By having tests in place for all portions of your code you can make changes while knowing that you can easily check if those changes produce an error and where to go to fix it. \n\n\n## `testthat`\nThe `testthat` package provides a framework for writing and performing tests in R.  There are two pieces of the `testthat` package, which form a hierarchal structure for doing testing.  \n\n  1. Tests: tests are the top of the hiercharchy.  Usually for a single function that is being tested there will be multiple tests.  For example, we may have one test that inspects results for normal inputs and another test for inputs with missing values.  Use the `test_that()` function.  \n  2. Expectations: each test is made up of a series of expectations that describe the expected output of a function (e.g. length, type, value).  Use the `expect_that()` function.  \n\n### List of Common Expectation Functions\n\n| Function                  | Description                             |\n|---------------------------|-----------------------------------------|\n| `expect_true(x)`          | expects that `x` is `TRUE`              |\n| `expect_false(x)`         | expects that `x` is `FALSE`             |\n| `expect_null(x)`          | expects that `x` is `NULL`              |\n| `expect_type(x)`          | expects that `x` is of type `y`         |\n| `expect_is(x, y)`         | expects that `x` is of class `y`        |\n| `expect_length(x, y)`     | expects that `x` is of length `y`       |\n| `expect_equal(x, y)`      | expects that `x` is equal to `y`        |\n| `expect_equivalent(x, y)` | expects that `x` is equivalent to `y`   |\n| `expect_identical(x, y)`  | expects that `x` is identical to `y`    |\n| `expect_lt(x, y)`         | expects that `x` is less than `y`       |\n| `expect_gt(x, y)`         | expects that `x` is greater than `y`    |\n| `expect_lte(x, y)`        | expects that `x` is less than or equal to `y` |\n| `expect_gte(x, y)`        | expects that `x` is greater than or equal `y` |\n| `expect_named(x)`         | expects that `x` has names `y`          |\n| `expect_matches(x, y)`    | expects that `x` matches `y` (regex)    |\n| `expect_message(x, y)`    | expects that `x` gives message `y`      |\n| `expect_warning(x, y)`    | expects that `x` gives warning `y`      |\n| `expect_error(x, y)`      | expects that `x` throws error `y`       |\n\n\n## `testthat` example\nTo understand how `testthat` works, we will consider the `standardize()`\nfunction, which takes a vector `x`, subtracts the mean of the vector, and then divides by the standard deviation.  Notice the assertions in the function checking pre-conditions! \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstandardize <- function(x, na.rm = FALSE) {\n  # assertions on input\n  assert_that(is.vector(x))\n  assert_that(is.flag(na.rm))\n  \n  # do computation\n  z <- (x - mean(x, na.rm = na.rm)) / sd(x, na.rm = na.rm)\n  return(z)\n}\n```\n:::\n\n\n\n\n### Informal testing\nWhen writing a function, we informally testings usually looks something like this: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(2, 4, 7, 8, 9)\nz <- standardize(a)\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1.3719887 -0.6859943  0.3429972  0.6859943  1.0289915\n```\n:::\n:::\n\n\n\nWe can check the mean and standard deviation of `z` to make sure `standardize()`\nworks correctly:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# zero mean\nmean(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\n# unit std-dev\nsd(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n\nThen we keep testing a function with more extreme cases:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- c(1, 2, 3, 4, NA)\nstandardize(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA NA NA NA NA\n```\n:::\n\n```{.r .cell-code}\nstandardize(y, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1.1618950 -0.3872983  0.3872983  1.1618950         NA\n```\n:::\n:::\n\n\n\nand even more cases:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nalog <- c(TRUE, FALSE, FALSE, TRUE)\nstandardize(alog)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  0.8660254 -0.8660254 -0.8660254  0.8660254\n```\n:::\n:::\n\n\n\n### Using `testthat` instead\n\nInstead of writing a list of more or less informal test, we are going to use \nthe functions provide by `testthat`. \n\nTo learn about the testing functions, we'll consider the following testing vectors:\n\n- `x <- c(1, 2, 3)`\n- `y <- c(1, 2, NA)`\n- `w <- c(TRUE, FALSE, TRUE)`\n- `q <- letters[1:3]`\n\n#### Testing with \"normal\" Input\n\nThe core of `\"testthat\"` consists of __expectations__; to write expectations \nyou use functions of the form `expect_xyz()` such as `expect_equal()`,\n`expect_integer()` or `expect_error()`.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3)\nz <- (x - mean(x)) / sd(x)\n\nexpect_equal(standardize(x), z)\nexpect_length(standardize(x), length(x))\nexpect_type(standardize(x), 'double')\n```\n:::\n\n\n\nNotice that when an expectation runs successfully, nothing appears to happen.\nBut that's good news. If an expectation fails, you'll typically get an error, \nhere are some failed tests:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# different expected output\nexpect_equal(standardize(x), x)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: standardize(x) not equal to `x`.\n3/3 mismatches (average diff: 2)\n[1] -1 - 1 == -2\n[2]  0 - 2 == -2\n[3]  1 - 3 == -2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# different expected length\nexpect_length(standardize(x), 2)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: standardize(x) has length 3, not length 2.\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# different expected type\nexpect_type(standardize(x), 'character')\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: standardize(x) has type 'double', not 'character'.\n```\n:::\n:::\n\n\n\n\n### Testing with missing values\n\nLet's include a vector with missing values\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- c(1, 2, NA)\nz1 <- (y - mean(y, na.rm = FALSE)) / sd(y, na.rm = FALSE)\nz2 <- (y - mean(y, na.rm = TRUE)) / sd(y, na.rm = TRUE)\n\nexpect_equal(standardize(y), z1)\nexpect_length(standardize(y), length(y))\nexpect_equal(standardize(y, na.rm = TRUE), z2)\nexpect_length(standardize(y, na.rm = TRUE), length(y))\nexpect_type(standardize(y), 'double')\n```\n:::\n\n\n\n\n### Testing with logical input\n\nLet's now test `standardize()` with a logical vector:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw <- c(TRUE, FALSE, TRUE)\nz <- (w - mean(w)) / sd(w)\n\nexpect_equal(standardize(w), z)\nexpect_length(standardize(w), length(w))\nexpect_type(standardize(w), 'double')\n```\n:::\n\n\n\n\n### Combining multiple expectations into a test with `test_that()`\n\nNow that you've seen how the expectation functions work, the next thing to \ntalk about is the function `test_that()` which you'll use to group a set \nof expectations.  \n\nLooking at the previous test examples with the normal input vector, all the \nexpectations can be wrapped inside a call to `test_that()`. The first argument\nof `test_that()` is a string indicating what is being tested, followed by an R expression with the expectations.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_that(\"standardize works with normal input\", {\n  x <- c(1, 2, 3)\n  z <- (x - mean(x)) / sd(x)\n\n  expect_equal(standardize(x), z)\n  expect_length(standardize(x), length(x))\n  expect_type(standardize(x), 'double')\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTest passed 😀\n```\n:::\n:::\n\n\n\nLikewise, all the expectations with the vector containing missing values can be wrapped inside another call to `test_that()` like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_that(\"standardize works with missing values\", {\n  y <- c(1, 2, NA)\n  z1 <- (y - mean(y, na.rm = FALSE)) / sd(y, na.rm = FALSE)\n  z2 <- (y - mean(y, na.rm = TRUE)) / sd(y, na.rm = TRUE)\n  \n  expect_equal(standardize(y), z1)\n  expect_length(standardize(y), length(y))\n  expect_equal(standardize(y, na.rm = TRUE), z2)\n  expect_length(standardize(y, na.rm = TRUE), length(y))\n  expect_type(standardize(y), 'double')\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTest passed 🥳\n```\n:::\n:::\n\n\n\nAnd last, but not least, the expectations with the logical vector can be \ngrouped in a `test_that()` call:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_that(\"standardize handles logical vector\", {\n  w <- c(TRUE, FALSE, TRUE)\n  z <- (w - mean(w)) / sd(w)\n  \n  expect_equal(standardize(w), z)\n  expect_length(standardize(w), length(w))\n  expect_type(standardize(w), 'double')\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTest passed 🌈\n```\n:::\n:::\n\n\n\n\n### Running tests\n\nThe formal way to implement the tests is to include them in a separate `R` \nscript file, e.g. `tests-function-name.R`.  Then you\n\nIf your working directory is the `sections/03/` directory, then you could run the tests in `tests-standardize.R` from the R console using the function `test_file()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# (assuming that your working directory is \"sections/03/\")\n# run from R console\ntest_file(\"tests/tests-standardize.R\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n══ Testing tests-standardize.R ═════════════════════════════════════════════════\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 4 ]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 5 ]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 6 ]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 7 ]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 8 ]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 9 ]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 10 ]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 11 ] Done!\n```\n:::\n:::\n\n\nWe see that all 11 of the tests were passed, so it seems like our function is working as expected.  \n\nTo see what the output of `test_file()` looks like when tests fail I included a version of `standarize` which adds a 1 to the end of function called `standarizeWrong` in the `functions.R` file.  In this case we expect the tests to fail and that is what we see: \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# (assuming that your working directory is \"sections/03/\")\n# run from R console\ntest_file(\"tests/tests-standardize-wrong.R\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n══ Testing tests-standardize-wrong.R ═══════════════════════════════════════════\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 1 ]\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 2 ]\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 3 ]\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 4 ]\n[ FAIL 2 | WARN 0 | SKIP 0 | PASS 4 ]\n[ FAIL 2 | WARN 0 | SKIP 0 | PASS 5 ]\n[ FAIL 2 | WARN 0 | SKIP 0 | PASS 6 ]\n[ FAIL 3 | WARN 0 | SKIP 0 | PASS 6 ]\n[ FAIL 3 | WARN 0 | SKIP 0 | PASS 7 ]\n[ FAIL 3 | WARN 0 | SKIP 0 | PASS 8 ]\n\n── Failure (tests-standardize-wrong.R:9:3): standardize works with normal input ──\nstandardizeWrong(x) not equal to `z`.\n3/3 mismatches (average diff: 1)\n[1] 0 - -1 == 1\n[2] 1 -  0 == 1\n[3] 2 -  1 == 1\n\n── Failure (tests-standardize-wrong.R:22:3): standardize works with missing values ──\nstandardizeWrong(y, na.rm = TRUE) not equal to `z2`.\n2/3 mismatches (average diff: 1)\n[1] 0.293 - -0.707 == 1\n[2] 1.707 -  0.707 == 1\n\n── Failure (tests-standardize-wrong.R:32:3): standardize handles logical vector ──\nstandardizeWrong(w) not equal to `z`.\n3/3 mismatches (average diff: 1)\n[1]  1.577 -  0.577 == 1\n[2] -0.155 - -1.155 == 1\n[3]  1.577 -  0.577 == 1\n\n\n[ FAIL 3 | WARN 0 | SKIP 0 | PASS 8 ]\n```\n:::\n:::\n\n\n\nHere we see that 3 tests failed, namely that our output is not equal to the value that we expect it to be.  This allows us to go back to the function and assess what may be going wrong.  \n\n# Practice problems \n\nAlthough it is not required to code in this manner, we are going to practice working in a test-driven format.  It is a coding practice where you first write the tests, then write a function that will pass those tests, and update the function and tests as needed.   Coding in this way is called [test-driven development](https://en.wikipedia.org/wiki/Test-driven_development).  \n\nSuppose we want to write a function `calculator(x, y, operation)` that takes in two numbers `x` and `y` as well as a string `operation` indicating whether to perform addition, subtraction, multiplication, or division.  This function should return a numeric value.  \n\n1. Write a test that will check whether `calculator` (which you have not written yet) returns an error when `x` and `y` are not numeric and when `operation` is not in the expected set of operations (i.e. addition, subtraction, multiplication, and division). Save these tests in a file called `tests-calculator.R`.  Hint: use the expectation `expect_error()`.  You may want to write custom error messages in your assertions.  \n\n2. Start writing your `calculator` function to pass the tests written in 1).  Use the `assertthat` package to produce errors if `x` or `y` are not numeric or when `operation` is not in the expected set of operations.  You can choose what you expect the user to call each operation in the function.  Save this function as `calculator.R`\n\n3. Use the `test_files(\"tests-calculator.R\")` to see if your function is operating as you hope. Note this assumes you are in the directory that holds `tests-calculator.R`.  \n\n4. Write a test that checks whether the addition piece of your calculator produces the correct results with the following input: \n\n    1. `x = 1` and `y = 9`\n    2.  `x = 100`, `y = -5`\nAlso, check that the value returned is a scalar.  Save these tests in a file called `tests-calculator.R`.  If you think of any other tests feel free to add them.  \n\n5. Add the addition functionality to `calculator()` and call `test_files(\"tests-calculator.R\")` again.  \n\n6. Continue iterating through this process for substraction, multiplication, and division.  Make sure your function elegantly handles division when the demoninator is 0.\n\n7.  If you have time, add new functionality to your calulator (e.g. square root).  \n\n## Acknowledgements\n\nThis lab was originally authored by Zoe Vernon and updated incrementally by\nAndrew Vaughn and James Duncan.\n",
    "supporting": [
      "assertionsAndTesting_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}