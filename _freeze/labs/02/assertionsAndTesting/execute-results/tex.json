{
  "hash": "d85216ad1844173f1125567168ba1f95",
  "result": {
    "markdown": "---\ntitle: \"Assertions and Testing\"\nauthor: \"Zoe Vernon, Andrew Vaughn, James Duncan\"\ndate: \"2022-09-09\"\nformat:\n  pdf:\n    documentclass: article\n    margin-left: 30mm\n    margin-right: 30mm\n    toc: true\n  html:\n    theme: cosmo\n    css: ../../styles.css\n    toc: true\n    code-copy: true\n    code-block-background: true\nexecute:\n  freeze: auto\n---\n\n\n\n\n[PDF](./assertionsAndTesting.pdf){.btn .btn-primary}\n\n## References and useful links\n\n* [Testing section](http://r-pkgs.had.co.nz/tests.html) of the R packages tutorial by Hadley Wickham\n* [GitHub](https://github.com/hadley/assertthat) for assertthat package by Hadley Wickham\n* [Assertions and testing tutorial](https://swcarpentry.github.io/python-novice-inflammation/10-defensive/index.html) in Python\n\n## Learning Objectives\n  - Understand the benefits of assertions and testing as well as the differences between the two.\n  - Introduction to the R package `assertthat`.\n  - Introduction to the R package `testthat`.\n  - Practice writing assertions and tests on your own.\n\n## Purpose of Assertions and Testing\nWe all want our code   to be correct the first time we write it. The unfortunate reality is that we all make mistakes when coding, either because of \"silly mistakes\" (indexing errors,   incorrect syntax,  using a wrong variable name, etc.) or because of a fundamental misunderstanding of the problem we are trying to solve. While print statements and writing test cases can help reduce coding errors, it is desirable to have a formal, structured way to test our code to ensure that it is functioning how we want it to. It is here that the `assertthat` and `testthat` packages in R prove useful.\n\n\n## Assertion vs. Testing\n\nAssertions check the internal state of a function. For example, consider a\nfunction `add(x, y)` which returns `x + y`. The function assumes `x`\nis numeric, and an assertion within the body of the function would confirm that\nthis is in the case and return an error if not.\n\nOn the other hand, tests (sometimes referred to as \"unit tests\") check that a\nfunction produces the expected output for various inputs. For example, ensuring\nthat `add(1, 2)` returns the number 3. Tests may include checks that assertions\nare working properly, for example by confirming that an error is thrown when the\nuser calls `add(\"potato\", 2)`.\n\nTests and assertions are similar in that,\n\n- Both are part of ensuring programs run correctly and aspects of defensive programming.\n- Both should check small pieces of the code while providing useful error messages, so they tell you exactly where the issue arises.\n\nHere's a summary table comparing the two:\n\n| Assertions | Tests |\n|--------------------------------------------------------------------------|------------------------------------------------|\n| Take the perspective of the developer. | Take the perspective of the user. |\n| Assert that the developer knows what they're doing. | Test what the user can do. |\n| Check internal function states. | Check function results given a specific input. |\n| Typically found within a function alongside source code. | Typically kept in a directory separate from source code. |\n| Can run every time the code is called. | Run periodically during development at specific moments (e.g., before creating a git commit). |\n| Amount of computation should be limited to avoid slowing down source code. | For large packages with many functions, can take many minutes or even hours to run. |\n| Should depend only on local states (e.g., the function's arguments and internal variables). | Can depend on global state (e.g., global options). |\n| Double as inline documentation of source code. | Can be helpful for the code design process (i.e., test-driven development). |\n\n## Assertions and `assertthat`\n\nAn assertion is a statement in a function or program that must be `TRUE` for it to\ncontinue and throws an error if `FALSE`. There are three types of assertions:\n\n  1. _Pre-conditions_: statements that must be true at the beginning of the function for it to work.  Mostly, this involves checking that inputs to the function are in the expected form.\n  2. _Invariants_: statements that must be true at intermediate points in the function.  For example, checking that the output from a computation is positive before using the `sqrt()` function.\n  3. _Post-conditions_: statements that must be true at the end of a function.  For example, if you write a function that must always return a vector of length `n` with all positive numbers you would ensure that is the case after all the computation has been performed.\n\n`assertthat` is a R package that provides functionality for adding assertions to\nfunctions, while producing useful error messages. Calls to `assert_that` are\nsimilar to `stopifnot` function from base R. Consider the examples below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\nstopifnot(is.character(x))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: is.character(x) is not TRUE\n```\n:::\n\n```{.r .cell-code}\nassert_that(is.character(x))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: x is not a character vector\n```\n:::\n\n```{.r .cell-code}\nassert_that(length(x) == 5)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: length(x) not equal to 5\n```\n:::\n\n```{.r .cell-code}\nassert_that(is.numeric(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nIn addition to giving useful error messages to the user about their inputs,\nadding assertions to your function allows you to document exactly what you as\nthe developer expect to happen at intermediate points. This is particularly\nuseful if you come back to the function after a while and need to recall exactly\nwhat it does.\n\n`assertthat` can be installed either from CRAN or GitHub (CRAN is the stable\nversion, GitHub usually has the current dev version):\n\n- Installation from CRAN:\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  install.packages('assertthat')\n  ```\n  :::\n\n- Installation from GitHub (requires the [`remotes`](https://remotes.r-lib.org/) package):\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  remotes::install_github(\"hadley/assertthat\")\n  ```\n  :::\n\n\n### Three main functions: `assert_that`, `see_if`, and `validate_that`\n\nThese are the three primary functions from the package:\n\n  - `assert_that()` signals (i.e., throws) an error. This is primarily what you will use in your functions.\n  - `see_if()` returns a logical value, with the error message as an attribute, but no error is thrown.\n  - `validate_that()` returns `TRUE` on success and otherwise returns the error as a string.\n\nHere is an example of the differences. When the assertion is `TRUE` they all\nreturn `TRUE` and continue with the execution of the function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# these functions will help us see the differences in assertthat's functions\nreturnStringAssert <- function(x){\n  assert_that(is.string(x))\n\n  return(x)\n}\nreturnStringSeeIf <- function(x){\n  see_if(is.string(x))\n\n  return(x)\n}\nreturnStringValidate <- function(x){\n  validate_that(is.string(x))\n\n  return(x)\n}\n\nreturnStringAssert(\"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n```\n:::\n\n```{.r .cell-code}\nreturnStringSeeIf(\"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n```\n:::\n\n```{.r .cell-code}\nreturnStringValidate(\"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n```\n:::\n:::\n\n\nWhen the assertion is `FALSE` the functions have different behaviors.\n`assert_that()` will throw an error, halting furthering execution of the\nfunction immediately. `see_if()` and `validate_that()` will not stop the\nexecution, allowing the function to continue with bad state.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreturnStringAssert(c(\"a\", \"b\"))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: x is not a string (a length one character vector).\n```\n:::\n\n```{.r .cell-code}\nreturnStringSeeIf(c(\"a\", \"b\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"b\"\n```\n:::\n\n```{.r .cell-code}\nreturnStringValidate(c(\"a\", \"b\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"b\"\n```\n:::\n:::\n\n\nHowever, all three will give the error message\n\n`assert_that` signals an error:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nassert_that(is.string(c(\"a\", \"b\")))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: c(\"a\", \"b\") is not a string (a length one character vector).\n```\n:::\n:::\n\n\n`see_if` returns `FALSE` with the error message as an attribute:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsee_if_result <- see_if(is.string(c(\"a\", \"b\")))\nsee_if_result\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\nattr(,\"msg\")\n[1] \"c(\\\"a\\\", \\\"b\\\") is not a string (a length one character vector).\"\n```\n:::\n\n```{.r .cell-code}\nattr(see_if_result, \"msg\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"c(\\\"a\\\", \\\"b\\\") is not a string (a length one character vector).\"\n```\n:::\n:::\n\n\n`validate_that` returns the error message as a string:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalidate_that(is.string(c(\"a\", \"b\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"c(\\\"a\\\", \\\"b\\\") is not a string (a length one character vector).\"\n```\n:::\n:::\n\n\nWhile in general `assert_that()` is likely to be your go-to, you might prefer to\nuse `see_if()` or `validate_that()` in cases where you first want to inspect the\nerror message and perhaps check other aspects of your function's state before\neventually signaling an error (e.g., using `stop()` with a custom message) so\nthat function execution does not continue with the bad state.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nerr_msg <- attr(see_if_result, \"msg\")\nstop(\"see_if() returned FALSE because \", err_msg, call. = FALSE)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: see_if() returned FALSE because c(\"a\", \"b\") is not a string (a length one character vector).\n```\n:::\n:::\n\n\n### Writing Your Own Assertions\n\nWhile you could use `see_if()` or `validate_that()` to create custom error\nmessages as in the previous example, `assertthat` already provides a couple of\nways to do so.\n\nThe first is by adding a new assertion that checks whether the number is odd and\nadd a custom message directly to the assertion:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_odd <- function(x) {\n  # your custom assertion checking functions can have their own assertions!\n  # you can check multiple conditions by separating them with a ,\n  assert_that(is.numeric(x), length(x) == 1)\n\n  # here is the main assertion\n  assert_that(x %% 2 == 1, msg = paste(\"x =\", x, \"is even\"))\n}\n\nassert_that(is_odd(2))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: x = 2 is even\n```\n:::\n:::\n\n\nThe second is to using the `on_failure()` function, which allows you to use more\ncomplex logic to create your assertion failure messages. Below is an example of\nhow this works:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_odd2 <- function(x) {\n  assert_that(is.numeric(x), length(x) == 1)\n  x %% 2 == 1\n}\nattributes(is_odd2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$srcref\nfunction(x) {\n  assert_that(is.numeric(x), length(x) == 1)\n  x %% 2 == 1\n}\n```\n:::\n\n```{.r .cell-code}\nassert_that(is_odd2(2))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: is_odd2(x = 2) is not TRUE\n```\n:::\n\n```{.r .cell-code}\non_failure(is_odd2) <- function(call, env) {\n  paste(\"x =\", deparse(call$x), \" is even\")\n}\nattributes(is_odd2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$srcref\nfunction(x) {\n  assert_that(is.numeric(x), length(x) == 1)\n  x %% 2 == 1\n}\n\n$fail\nfunction(call, env) {\n  paste(\"x =\", deparse(call$x), \" is even\")\n}\n```\n:::\n\n```{.r .cell-code}\nassert_that(is_odd2(2))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: x = 2  is even\n```\n:::\n:::\n\n\nThe assertions from our original `is_odd()` function flow through the function\nwe assigned to the `fail` attribute of `is_odd()` by using `on_failure()`, so we\nstill get the appropriate error messages when we pass a non-numeric or vector\nvalue to `is_odd()`.\n\n\n### Some Additional Useful Assertions\n\n`assertthat` provides a few additional assertions above and beyond what base R\nprovides that can be quite useful:\n\n  - `is.flag(x)`: is `x` `TRUE` or `FALSE`? (a boolean flag)\n  - `is.string(x)`: is `x` a length 1 character vector?\n  - `has_name(x, nm)`, `x %has_name% nm`: does `x` have component `nm`?\n  - `has_attr(x, attr)`, `x %has_attr% attr`: does `x` have attribute `attr`?\n  - `is.count(x)`: is `x` a single positive integer?\n  - `are_equal(x, y)`: are `x` and `y` equal?\n  - `not_empty(x)`: are all dimensions of `x` greater than 0?\n  - `noNA(x)`: is `x` free from missing values?\n  - `is.dir(path)`: is path a directory?\n  - `is.writeable(path)`/`is.readable(path)`: is `path` writeable/readable?\n  - `has_extension(path, extension)`: does `file` have given `extension`?\n\n## Testing\n\nAssertions allow us to check aspects of function state as the function is being\nexecuted, while unit tests help ensure that the output from a function is what\nwe expect given some set of inputs.\n\nA common approach to testing is to use the R console to informally check whether\nyour code works on a few examples. Units tests formalize this approach by\nproviding a framework for testing that allows you to re-run tests as you update\nyour functions. You are likely already using the first approach, so there is no\nreason to waste your code and energy by not saving it for later use.\n\nHadley Wickam describes four main areas that proper testings will help improve\nyour code:\n\n1. **Fewer bugs**: When setting up unit tests you have a formal place that\n   describes your expectations for function behavior. This serves as a form of\n   internal documentation and helps ensure that your code does what you\n   intend.\n\n2. **Better code structure**: Tests should only check accuracy of small portions\n   of code, allowing you to easily find sources of error. This forces you to\n   write more modular code.\n\n3. **Easier restarts**: Tests help you remember where you left off and what the\n   next step in your code should be. It is good practice to write tests first,\n   and then write the function that achieves the desired result. This practice\n   is called \"test-driven development\".\n\n4. **Robust code**: By having tests in place for all portions of your code you\n   can make changes while knowing that you can easily check if those changes\n   produce an error and where to go to fix it.\n\n\n## `testthat`\n\nThe `testthat` package provides a framework for writing and performing tests in\nR. There are two pieces of the `testthat` package, forming a hierarchical\nstructure for testing.\n\n1. Tests: tests are the top of the hiercharchy. Usually for a single function\n   that is being tested there will be multiple tests. For example, we may have\n   one test that inspects results for normal inputs and another test for inputs\n   with missing values. Use the `test_that()` function.\n\n2. Expectations: each test is made up of a series of expectations that describe\n   the expected output of a function (e.g. length, type, value). Use the\n   `expect_that()` function.\n\n### List of Common Expectations\n\n| Function                  | Description                             |\n|---------------------------|-----------------------------------------|\n| `expect_true(x)`          | expects that `x` is `TRUE`              |\n| `expect_false(x)`         | expects that `x` is `FALSE`             |\n| `expect_null(x)`          | expects that `x` is `NULL`              |\n| `expect_type(x)`          | expects that `x` is of type `y`         |\n| `expect_is(x, y)`         | expects that `x` is of class `y`        |\n| `expect_length(x, y)`     | expects that `x` is of length `y`       |\n| `expect_equal(x, y)`      | expects that `x` is equal to `y`        |\n| `expect_equivalent(x, y)` | expects that `x` is equivalent to `y`   |\n| `expect_identical(x, y)`  | expects that `x` is identical to `y`    |\n| `expect_lt(x, y)`         | expects that `x` is less than `y`       |\n| `expect_gt(x, y)`         | expects that `x` is greater than `y`    |\n| `expect_lte(x, y)`        | expects that `x` is less than or equal to `y` |\n| `expect_gte(x, y)`        | expects that `x` is greater than or equal `y` |\n| `expect_named(x)`         | expects that `x` has names `y`          |\n| `expect_matches(x, y)`    | expects that `x` matches `y` (regex)    |\n| `expect_message(x, y)`    | expects that `x` gives message `y`      |\n| `expect_warning(x, y)`    | expects that `x` gives warning `y`      |\n| `expect_error(x, y)`      | expects that `x` throws error `y`       |\n\n\n## `testthat` example\n\nTo understand how `testthat` works, we will consider the `standardize()`\nfunction, which takes a vector `x`, subtracts the mean of the vector, and then\ndivides by the standard deviation. Notice the assertions in the function\nto check pre-conditions!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstandardize <- function(x, na.rm = FALSE) {\n  # assertions on input\n  assert_that(is.vector(x))\n  assert_that(is.flag(na.rm))\n\n  # do computation\n  z <- (x - mean(x, na.rm = na.rm)) / sd(x, na.rm = na.rm)\n  return(z)\n}\n```\n:::\n\n\n\n### Informal testing\n\nWhen writing a function, the informal process of testing usually looks something\nlike this, executed line-by-line in the R console:\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(2, 4, 7, 8, 9)\nz <- standardize(a)\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1.3719887 -0.6859943  0.3429972  0.6859943  1.0289915\n```\n:::\n:::\n\n\nThen you might look at the mean and standard deviation of `z` to see if\n`standardize()` appears to be working as expected:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# zero mean\nmean(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\n# unit std-dev\nsd(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\nNext, you might keep testing the function with more extreme cases:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- c(1, 2, 3, 4, NA)\nstandardize(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA NA NA NA NA\n```\n:::\n\n```{.r .cell-code}\nstandardize(y, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1.1618950 -0.3872983  0.3872983  1.1618950         NA\n```\n:::\n:::\n\n\nAnd so on for different types of inputs:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nalog <- c(TRUE, FALSE, FALSE, TRUE)\nstandardize(alog)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  0.8660254 -0.8660254 -0.8660254  0.8660254\n```\n:::\n:::\n\n\nThis approach is fine and encouraged for interactive development, but don't\nwaste all this energy! Hold on to your testing code for a rainy day.\n\n### Using `testthat`\n\nInstead of just writing a list of more or less informal tests in the R console,\nwe are going to use the functions provide by `testthat`.\n\nTo learn about the testing functions, we'll consider the following test inputs:\n\n- `x <- c(1, 2, 3)`\n- `y <- c(1, 2, NA)`\n- `w <- c(TRUE, FALSE, TRUE)`\n- `q <- letters[1:3]`\n\n#### The \"happy path\": Testing with \"normal\" input\n\nThe core of `testthat` consists of _expectations_; to write expectations you\nuse functions from the `testthat` package starting with `expect_` such as\n`expect_equal()`, `expect_integer()` or `expect_error()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3)\nz <- (x - mean(x)) / sd(x)\n\nexpect_equal(standardize(x), z)\nexpect_length(standardize(x), length(x))\nexpect_type(standardize(x), 'double')\n```\n:::\n\n\nNotice that when an expectation runs successfully, nothing appears to happen.\nBut that's good news. If an expectation fails, you'll typically get an error,\nhere are some failed tests:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# different expected output\nexpect_equal(standardize(x), x)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: standardize(x) not equal to `x`.\n3/3 mismatches (average diff: 2)\n[1] -1 - 1 == -2\n[2]  0 - 2 == -2\n[3]  1 - 3 == -2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# different expected length\nexpect_length(standardize(x), 2)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: standardize(x) has length 3, not length 2.\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# different expected type\nexpect_type(standardize(x), 'character')\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: standardize(x) has type 'double', not 'character'.\n```\n:::\n:::\n\n\n### Edge cases: Testing function robustness\n\nIt's important to be creative when testing and get into the mindset of the user\nof your code. You might be the only user, but your perspective when developing\ncode vs. when you use it later on are not one in the same. Think about the range\nof inputs the user might give your functions and how your function should behave\nin cases that don't fall directly on the happy path.\n\n#### Testing inputs with `NA`\n\nLet's include a vector with missing values, which we want to handle.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- c(1, 2, NA)\nz1 <- (y - mean(y, na.rm = FALSE)) / sd(y, na.rm = FALSE)\nz2 <- (y - mean(y, na.rm = TRUE)) / sd(y, na.rm = TRUE)\n\nexpect_equal(standardize(y), z1)\nexpect_length(standardize(y), length(y))\nexpect_equal(standardize(y, na.rm = TRUE), z2)\nexpect_length(standardize(y, na.rm = TRUE), length(y))\nexpect_type(standardize(y), 'double')\n```\n:::\n\n\n#### Testing with logical input\n\nLet's now test `standardize()` with a logical vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw <- c(TRUE, FALSE, TRUE)\nz <- (w - mean(w)) / sd(w)\n\nexpect_equal(standardize(w), z)\nexpect_length(standardize(w), length(w))\nexpect_type(standardize(w), 'double')\n```\n:::\n\n\n### Combining multiple expectations into a test with `test_that()`\n\nNow that you've seen how the expectation functions work, the next thing to\ntalk about is the function `test_that()` which you'll use to group a set\nof expectations.\n\nLooking at the previous test examples with the normal input vector, all the\nexpectations can be wrapped inside a call to `test_that()`. The first argument\nof `test_that()` is a string indicating what is being tested, followed by an R\nexpression with the expectations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_that(\"standardize works with normal input\", {\n  x <- c(1, 2, 3)\n  z <- (x - mean(x)) / sd(x)\n\n  expect_equal(standardize(x), z)\n  expect_length(standardize(x), length(x))\n  expect_type(standardize(x), 'double')\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTest passed \n```\n:::\n:::\n\n\nLikewise, all the expectations with the vector containing missing values can be wrapped inside another call to `test_that()` like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_that(\"standardize works with missing values\", {\n  y <- c(1, 2, NA)\n  z1 <- (y - mean(y, na.rm = FALSE)) / sd(y, na.rm = FALSE)\n  z2 <- (y - mean(y, na.rm = TRUE)) / sd(y, na.rm = TRUE)\n\n  expect_equal(standardize(y), z1)\n  expect_length(standardize(y), length(y))\n  expect_equal(standardize(y, na.rm = TRUE), z2)\n  expect_length(standardize(y, na.rm = TRUE), length(y))\n  expect_type(standardize(y), 'double')\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTest passed \n```\n:::\n:::\n\n\nAnd last, but not least, the expectations with the logical vector can be\ngrouped in a `test_that()` call:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_that(\"standardize handles logical vector\", {\n  w <- c(TRUE, FALSE, TRUE)\n  z <- (w - mean(w)) / sd(w)\n\n  expect_equal(standardize(w), z)\n  expect_length(standardize(w), length(w))\n  expect_type(standardize(w), 'double')\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTest passed \n```\n:::\n:::\n\n\n\n### Running tests\n\nThe formal way to implement the tests is to include them in a separate `R`\nscript file, e.g. `tests-function-name.R`.  Then you\n\nIf your working directory is the `sections/03/` directory, then you could run the tests in `tests-standardize.R` from the R console using the function `test_file()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# (assuming that your working directory is \"sections/03/\")\n# run from R console\ntest_file(\"tests/tests-standardize.R\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n== Testing tests-standardize.R =================================================\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 4 ]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 5 ]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 6 ]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 7 ]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 8 ]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 9 ]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 10 ]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 11 ] Done!\n```\n:::\n:::\n\nWe see that all 11 of the tests were passed, so it seems like our function is working as expected.\n\nTo see what the output of `test_file()` looks like when tests fail I included a version of `standarize` which adds a 1 to the end of function called `standarizeWrong` in the `functions.R` file.  In this case we expect the tests to fail and that is what we see:\n\n::: {.cell}\n\n```{.r .cell-code}\n# (assuming that your working directory is \"sections/03/\")\n# run from R console\ntest_file(\"tests/tests-standardize-wrong.R\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n== Testing tests-standardize-wrong.R ===========================================\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 1 ]\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 2 ]\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 3 ]\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 4 ]\n[ FAIL 2 | WARN 0 | SKIP 0 | PASS 4 ]\n[ FAIL 2 | WARN 0 | SKIP 0 | PASS 5 ]\n[ FAIL 2 | WARN 0 | SKIP 0 | PASS 6 ]\n[ FAIL 3 | WARN 0 | SKIP 0 | PASS 6 ]\n[ FAIL 3 | WARN 0 | SKIP 0 | PASS 7 ]\n[ FAIL 3 | WARN 0 | SKIP 0 | PASS 8 ]\n\n-- Failure (tests-standardize-wrong.R:9:3): standardize works with normal input --\nstandardizeWrong(x) not equal to `z`.\n3/3 mismatches (average diff: 1)\n[1] 0 - -1 == 1\n[2] 1 -  0 == 1\n[3] 2 -  1 == 1\n\n-- Failure (tests-standardize-wrong.R:22:3): standardize works with missing values --\nstandardizeWrong(y, na.rm = TRUE) not equal to `z2`.\n2/3 mismatches (average diff: 1)\n[1] 0.293 - -0.707 == 1\n[2] 1.707 -  0.707 == 1\n\n-- Failure (tests-standardize-wrong.R:32:3): standardize handles logical vector --\nstandardizeWrong(w) not equal to `z`.\n3/3 mismatches (average diff: 1)\n[1]  1.577 -  0.577 == 1\n[2] -0.155 - -1.155 == 1\n[3]  1.577 -  0.577 == 1\n\n\n[ FAIL 3 | WARN 0 | SKIP 0 | PASS 8 ]\n```\n:::\n:::\n\n\nHere we see that 3 tests failed, namely that our output is not equal to the value that we expect it to be.  This allows us to go back to the function and assess what may be going wrong.\n\n# Practice problems\n\nAlthough it is not required to code in this manner, we are going to practice working in a test-driven format.  It is a coding practice where you first write the tests, then write a function that will pass those tests, and update the function and tests as needed.   Coding in this way is called [test-driven development](https://en.wikipedia.org/wiki/Test-driven_development).\n\nSuppose we want to write a function `calculator(x, y, operation)` that takes in two numbers `x` and `y` as well as a string `operation` indicating whether to perform addition, subtraction, multiplication, or division.  This function should return a numeric value.\n\n1. Write a test that will check whether `calculator` (which you have not written yet) returns an error when `x` and `y` are not numeric and when `operation` is not in the expected set of operations (i.e. addition, subtraction, multiplication, and division). Save these tests in a file called `tests-calculator.R`.  Hint: use the expectation `expect_error()`.  You may want to write custom error messages in your assertions.\n\n2. Start writing your `calculator` function to pass the tests written in 1).  Use the `assertthat` package to produce errors if `x` or `y` are not numeric or when `operation` is not in the expected set of operations.  You can choose what you expect the user to call each operation in the function.  Save this function as `calculator.R`\n\n3. Use the `test_files(\"tests-calculator.R\")` to see if your function is operating as you hope. Note this assumes you are in the directory that holds `tests-calculator.R`.\n\n4. Write a test that checks whether the addition piece of your calculator produces the correct results with the following input:\n\n    1. `x = 1` and `y = 9`\n    2.  `x = 100`, `y = -5`\nAlso, check that the value returned is a scalar.  Save these tests in a file called `tests-calculator.R`.  If you think of any other tests feel free to add them.\n\n5. Add the addition functionality to `calculator()` and call `test_files(\"tests-calculator.R\")` again.\n\n6. Continue iterating through this process for substraction, multiplication, and division.  Make sure your function elegantly handles division when the demoninator is 0.\n\n7.  If you have time, add new functionality to your calulator (e.g. square root).\n\n## Acknowledgements\n\nThis lab was originally authored by Zoe Vernon and updated incrementally by\nAndrew Vaughn and James Duncan.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}