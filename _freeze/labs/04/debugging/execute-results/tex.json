{
  "hash": "c0b2ce07721cab25a51cbc9d228cbd88",
  "result": {
    "markdown": "---\ntitle: \"Debugging in R\"\nauthor: \"Zoe Vernon, Andrew Vaughn, James Duncan\"\ndate: \"2022-09-23\"\noutput: rmarkdown::pdf_document\nformat:\n  pdf:\n    documentclass: article\n    margin-left: 30mm\n    margin-right: 30mm\n    toc: true\n  html:\n    theme: cosmo\n    css: ../../styles.css\n    toc: true\n    code-copy: true\n    code-block-background: true\nexecute:\n  freeze: auto\n---\n\n\n[PDF](./debugging.pdf){.btn .btn-primary}\n\n\n\n\n\n# Useful links\n\n- General advice for debugging\n    - [Efficient Debugging by Goldspink](https://www.codementor.io/mattgoldspink/how-to-debug-code-efficiently-and-effectively-du107u9jh)\n    - [Debugging for Beginners by Brody](https://blog.hartleybrody.com/debugging-code-beginner/)\n- R specific debugging\n    - [Advanced R by Wickham](https://adv-r.hadley.nz/debugging.html)\n    - [Debugging in Rstudio by Gadrow](https://www.rstudio.com/resources/rstudioconf-2018/debugging-techniques-in-rstudio/)\n- The material for this document is based on the SCF tutorial linked below.\n    - [Berkeley-SCF tutorial by Chris Paciorek](https://github.com/berkeley-scf/tutorial-R-debugging)\n    - [Debugging demo by Chris](https://www.youtube.com/watch?v=-yy_3htRHdU&feature=youtu.be&ab_channel=berkeley-scf)\n\n# Learning objectives\n\nThe goal for this section is to become familiar with the debugging tools available in R as well as provide additional information on online forums and common errors in R.  Note that the debugging tools in R are difficult to illustrate in a Rmd document, so I recommend watching this   [screencast](https://www.youtube.com/watch?v=-yy_3htRHdU&feature=youtu.be&ab_channel=berkeley-scf) from the SCF tutorial.  I will also do a live demo at the beginning of section if that you all would find that useful.\n\nAlso, note that the material in this PDF is a summary of SCF tutorial on debugging, so if you want to see more detail please visit the [tutorial GitHub](https://github.com/berkeley-scf/tutorial-R-debugging).  The tutorial also has some good tips for defensive programming that you may find useful for preventing and catching errors in your code.\n\n# `R`'s debugging tools\n\nBelow is a list of the debugging tools available in R.  I took screenshots illustrating how some of the tools work in RStudio in the example below.\n\n##  Tools\n\n- Use `traceback` to view the call stack, which can help pinpoint where an error is occurring.\n- Use `recover`  to navigate the stack of active function calls at the time of the error and browse within the desired call. If you set `options(error = recover)` then `recover` is invoked whenever an error occurs.  You can revert the options to the default with `options(error = NULL)`.\n- `browser()`: pauses current execution, provides an interactive interpreter.\nYou can now step through a function line-by-line to find errors.\n- `debug(someFunc)`: sets a `browser()` statement at the first line of `someFunc`\n    - `undebug(someFunc)` removes the `debug()` statement. Or close the `R` session\n    - `debugonce(someFunc)` lets you debug only once, no need to run `undebug()`\n- `trace()`: allows you to temporarily modify a function without saving the modifications\n    - This is especially helpful for debugging functions in code where you don't\n      have the source handy (e.g., in the packages you're using).\n    - Edits will be removed when session ends, or when you call `untrace()` on the function\n\n## Example of debugging\n\nWe will use the `jackKnife.R` code to understand the debugging tools.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(MASS)\n\ngamma_est <- function(data) {\n  # this fits a gamma distribution to a collection of numbers\n  m <- mean(data)\n  v <- var(data)\n  s <- v/m\n  a <- m/s\n  return(list(a=a,s=s))\n}\n\ncalc_var <- function(estimates){\n  var_of_ests <- apply(estimates, 2, var)\n  return(((n-1)^2/n)*var_of_ests)\n}\n\ngamma_jackknife <- function(data) {\n  ## jackknife the estimation\n\n  n <- length(data)\n  jack_estimates <- gamma_est(data[-1])\n  for (omitted_point in 2:n) {\n    jack_estimates <- rbind(jack_estimates, gamma_est(data[-omitted_point]))\n  }\n\n  jack_var <- calc_var(jack_estimates)\n\n  return(sqrt(jack_var))\n}\n\n# jackknife gamma dist. estimates of cat heart weights\ngamma_jackknife(MASS::cats$Hwt)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in FUN(newX[, i], ...): is.atomic(x) is not TRUE\n```\n:::\n:::\n\nNotice that there is an error returned by the function, but it is unclear what is producing the error.  We can start by calling `traceback()` to see what may have gone wrong.\n\n![](figures/traceback.png){width=95%}\n\n`traceback()` shows us the set of calls leading up to the error.  We see that the error is produced at 5, and thus came from the call at 4 `FUN(newX[, i], ...)` which occured after calling `calc_var()` function and attempting to excecute the `apply` statement.\n\nAn alternative to `traceback()` is `recover()`.  If we have set `options(error = recover)` and call\n`gamma_jackknife(MASS::cats$Hwt)` again we will see the call stack (in reverse order of `traceback`), but now we have the option to select a number in the stack that we would like to enter.  I selected 2 and entered the `calc_var` function.  Typing `ls()` showed me that the only object in the function environment is `estimates`, which is a matrix.  However, I see the `is.atomic(x)` error when I try to compute the variance of a column. When we look at the column, we can now see that we output a list, instead of a vector and we know exactly where the error is occuring.  To exit we type `Q` and hit enter.\n\n![](figures/recover.png){width=95%}\n\nNow let's say we want to browse in the `gamma_jackknife()` function to figure out why we are passing a list to `calc_var` we can utlize the `debug()` function, which will allow us to step through `gamma_jackknife` one line at a time.  We first call `debug(gamma_jackknife)` and then when we attempt to run `gamma_jackknife(MASS::cats$Hwt)`, because an error is produce, we will enter the browser mode.\n\n![](figures/jackknife.png){width=95%}\n\nWe can use the graphical interface in RStudio or the command line, with the command `n` to step through lines of the code and see what it outputs.  Here we see that `gamma_est` is returning a list and that is likely the source of our issues.\n\nFor more details on these functions, as well as how to use `trace` to temporarialy add edits see the SCF tutorial and the screencast.  Also, as I stated above if there is enough interest I can do a live demo at the beginning of section.\n\n# Common errors\n\n- Parenthesis mis-matches\n\n- `[[...]]` vs. `[...]`\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  # example list\n  myList <- list(\"A\"=1:10,\n                 \"B\"=11:20)\n   # one set\n  cat(\"Type: \", typeof(myList[1]), \"\\nLength: \", length(myList[1]), sep = \"\")\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  ```\n  Type: list\n  Length: 1\n  ```\n  :::\n  \n  ```{.r .cell-code}\n   # two sets\n  cat(\"Type: \", typeof(myList[[1]]), \"\\nLength: \", length(myList[[1]]), sep = \"\")\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  ```\n  Type: integer\n  Length: 10\n  ```\n  :::\n  :::\n\n\n- `==` vs. `=`\n- Comparing real numbers exactly using `==` is dangerous because numbers on a\ncomputer are only represented to limited numerical precision.\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  # exact comparison\n  1/3 == 4*(4/12 - 3/12)\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  ```\n  [1] FALSE\n  ```\n  :::\n  \n  ```{.r .cell-code}\n  # approximate comparison\n  #  default tolerance is sqrt(.Machine$double.eps)\n  all.equal(target = 1/3, current = 4*(4/12 - 3/12))\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  ```\n  [1] TRUE\n  ```\n  :::\n  :::\n\n\n- You expect a single value but execution of the code gives a vector\n\n- You want to compare an entire vector but your code just compares the first value\n  (e.g., in an if statement)\n\n    - use `identical()`\n\n\n      ::: {.cell}\n      \n      ```{.r .cell-code}\n      x <- 1:10\n      y <- 1:5\n      if (x == y) {\n        print(\"Equal\")\n      } else {\n        print(\"Not equal\")\n      }\n      ```\n      \n      ::: {.cell-output .cell-output-error}\n      ```\n      Error in if (x == y) {: the condition has length > 1\n      ```\n      :::\n      \n      ```{.r .cell-code}\n      if (identical(x, y)) {\n        print(\"Equal\")\n      } else {\n        print(\"Not equal\")\n      }\n      ```\n      \n      ::: {.cell-output .cell-output-stdout}\n      ```\n      [1] \"Not equal\"\n      ```\n      :::\n      :::\n\n\n- Silent type conversion when you don't want it, or lack of coercion where you're expecting it\n    - eg., `read.csv()` and the `stringsAsFactors` argument\n- Using the wrong function or variable name\n- Giving unnamed arguments to a function in the wrong order\n- In an if-else statement, the `else` cannot be on its own line (unless all the code is enclosed in `{}`)\nbecause R will see the `if` part of the statement, which is a valid R statement,\nwill execute that, and then will encounter the `else` and return an error.\n- Forgetting to define a variable in the environment of a function and having R,\nvia lexical scoping, get that variable as a global variable from one of the enclosing\nenvironments. At best the types are not compatible and you get an error; at worst,\nyou use a garbage value and the bug is hard to trace. In some cases your code may\nwork fine when you develop the code (if the variable exists in the enclosing environment),\nbut then may not work when you restart R if the variable no longer exists or is different.\n    - Clear your environment before testing (`rm(list=ls());gc()`)\n    - Restart `R` session and test\n- R (usually helpfully) drops matrix and array dimensions that are extraneous.\nThis can sometimes confuse later code that expects an object of a certain dimension.\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  # 3x3 matrix\n  myMat <- matrix(data = 1:9, nrow = 3, ncol = 3)\n  # lost dimensions\n  dim(myMat[1, ])\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  ```\n  NULL\n  ```\n  :::\n  \n  ```{.r .cell-code}\n  # keep dimensions\n  dim(myMat[1, , drop = FALSE])\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  ```\n  [1] 1 3\n  ```\n  :::\n  :::\n\n\n# Getting help online\n\n## Online forums / mailing lists\n\nThere are online forums that have lots of useful postings.\nIn general if you have an error, others have already posted about it.\n\n- Simple web searches - *a la Google*\n    - You may want to include \"in R\" or preface your question with \"R yada yada yada\"\n- [Stack overflow](http://stackoverflow.com): R stuff will be tagged with 'R'\n    - [http://stackoverflow.com/questions/tagged/r](http://stackoverflow.com/questions/tagged/r)\n- R help special interest groups (SIG) such as r-sig-hpc (high performance computing),\nr-sig-mac (R on Macs), etc.\n    - To search a SIG you might include the name of the SIG in the search string\n- [Rseek.org](http://Rseek.org) for web searches restricted to sites that have information on R\n- [R-help mailing list](https://stat.ethz.ch/mailman/listinfo/r-help)\n\n:::{.callout-note}\nOf course these are also helpful for figuring out how to do things, not\njust for fixing bugs. For example, this [blogpost](http://www.r-bloggers.com/the-guerilla-guide-to-r/?utm_source=feedburner&utm_medium=email&utm_campaign=Feed%3A+RBloggers+%28R+bloggers%29)\nhas a guide to R based simply on Stack Overflow posts.\n:::\n\n## Asking questions online\n\nIf you've searched the archive and haven't found an answer to your problem, you\ncan often get help by posting to the R-help mailing list or one of the other\nlists mentioned above. A few guidelines (generally relevant when posting to mailing\nlists beyond just the R lists):\n\n- Search the archives and look through relevant R books or manuals first.\n    - [Advanced R](http://adv-r.had.co.nz/) by Hadley Wickham\n- Boil your problem down to the essence of the problem, giving an example,\nincluding the output and error message\n    - Former GSI's first [SO](https://stackoverflow.com/questions/49822833/r-package-call-c-function-within-rcpp) post\n        - Notice the not-so-polite comments, see the remark below\n    - Former GSI's second [SO](https://stackoverflow.com/questions/56298503/r-vignette-fails-on-internal-package-function) question\n- Say what version of R, what operating system and what operating system version you're using.\n    - Provide `sessionInfo()` and `Sys.info()`. These show the current state of your machine\n- Read the [R mailing list posting guide](https://www.r-project.org/posting-guide.html).\n\nThe R mailing lists are a way to get free advice from the experts, who include\nsome of the world's most knowledgeable R experts - seriously - members of the R\ncore development team contribute frequently. The cost is that you should do your\nhomework and that sometimes the responses you get __may be blunt__, along the lines\nof “read the [manual](https://cran.r-project.org/manuals.html)”. Chris considers it a\npretty good tradeoff - where else do you get the foremost experts in a domain actually helping you?\n\n# Pair debugging exercise: `logitBoot()`\n\nFor the group work this week we will step through debugging the `logitBoot`\nfunction. This is a function that computes a bootstrapped estimate of the\nstandard error of the coefficient on a logistic regression model. From R's\nimplementation of logistic regression, stored in the `mod` variable, we can see\nthat the estimated standard error is around 3. However, by calling\n`logitBoot(my_data$y, my_data$x)`, which is supposed to get this same standard\nerror, we return a value of over 100.\n\nThe goal here is to figure out what is going wrong and, if time, fix the issue.\nBelow are a list of steps you can take reach this goal. Note, that the functions\nare in the `logitBoot.R` script, so it will easiest to open that file and work\nfrom there.\n\n  - Load `data.csv` and look at the data to see what we are working with.   There should be a column of `y` values (which are 0 or 1) and a column of `x` values (which are continuous).\n    - The goal of logistic regression is to model which class `y` (0 or 1) an observation falls in based on `x`.\n  - Load the functions in the `logitBoot.R` script.\n  - Fit the logistic regression model in R using the `glm` function (code provided) and look at the `summary(mod)`\n    - Notice the estimated standard error on the coefficient for `x` is around 3.\n  - Try to run the `logitBoot(my_data$y, my_data$x)`.  Notice the overestimate and the warning.  We want to figure out what is going wrong.\n  - Call `debug(logitBoot)` and rerun `logitBoot(my_data$y, my_data$x)`.  This will take you into the browser window for `logitBoot` (if you get a fatal error at this step, you may need to update RStudio)\n    - Run through each line until you compute the vector `boot_coefs`.  Use the `range` and `quantile` functions to examine `boot_coefs` and see what could be going wrong.\n    - Find the index of sample that is causing the issue.\n  - Now that we have identified where the issue is occuring we still need to figure out why that paricular permutation is problematic.  For that we will use `trace` to temporarily edit our functions.\n    - Call `trace(myGLM, edit = TRUE)` and edit the function to return a list of coeficient, `y_boot`, and `x_boot`.\n    - Call `trace(logitBoot, edit = TRUE)` and change `sapply` to `lapply`\n  - Rerun `logitBoot(my_data$y, my_data$x)`, which will again open the browser window. Step through the code lines and look at `boot_coefs[[i]]` where `i` is the index found in step 5.\n    - Look at the values of `x_boot` that correspond to `y_boot = 1`.  Also, `sort` the `x_boot` output.  Can you tell what is going wrong?\n  - Now that we know what is causing the warning we can call `untrace(logitBoot)` and `untrace(myGLM)` to remove the temporary edits.\n\nAfter identifing the issue and we could edit the `myGLM` function to not compute\nthe model when that particular issue arises. Alternatively, we could employ a\nmore holistic approach with `tryCatch`. With this we can handle unforseen issues\nthat may arise. (This is what is implemented in the `logitBoot_solution.R`\nscript, which I will push after section.) Note, with the fixed code we now seem\nto underestimating the standard error. I am not sure why that is happening...\nbecause as far as I can tell the code is working correctly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data <- read.csv('./data.csv')\n\nlogitBoot <- function(y, x, n_boot = 2000) {\n  set.seed(5)\n\n  # do n_boot random permutations of x and y and return coefficient on x with\n  # the myGLM function\n  boot_coefs <- sapply(seq_len(n_boot), myGLM, y, x)\n\n  # compute standard deviation of those estimates and return\n  boot_se <- sd(boot_coefs)\n  return(boot_se)\n}\n\nmyGLM <- function(i, y, x) {\n  n <- length(y)\n\n  # randomly sample with replacement from the observations in the data\n  boot_sample <- sample(seq_len(n), n, replace = TRUE)\n\n  # create vectors of the bootstrapped samples\n  x_boot <- x[boot_sample]\n  y_boot <- y[boot_sample]\n\n  # fit logistic regression on permutated data\n  mod_boot <- glm(y_boot ~ x_boot, family = 'binomial')\n\n  # return the estimated coefficient\n  return(mod_boot$coef[2])\n}\n\n# fit model in R\nmod <- glm(y ~ x, data = my_data, family = 'binomial')\n\n# note that the standard error for the regression coefficient is ~3\nsummary(mod)\n\n# estimate standard error with our bootstrap function\n# note the overestimation of standard error 119 > 3\nlogitBoot(my_data$y, my_data$x)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}