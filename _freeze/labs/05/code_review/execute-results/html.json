{
  "hash": "9dbf8abcde5d1882f555c0ad57b49a0d",
  "result": {
    "markdown": "---\ntitle: \"PS3 code review\"\nauthor: \"Jared Bennett, Zoe Vernon, Andrew Vaughn, James Duncan\"\ndate: \"2022-09-30\"\nformat:\n  html:\n    theme: cosmo\n    css: ../../styles.css\n    toc: true\n    code-copy: true\n    code-block-background: true\nexecute:\n    freeze: auto\n---\n\n\n\n\n# Overview\n\nIn section this week we will do a paired code review for Problem 1 of PS3.\n\nIn order for this to be beneficial, you will need to be as honest with your\npartner as possible (while staying respectful). If something is actually hard to\nfollow, tell them! If you thought that something they did was clever, also tell\nthem!\n\n## Instructions\n\nWe will break up into pairs of 2 (with a possible group of 3 if necessary).\nPlease open up the PDF you submitted.\n\nNext, you will spend ~15 minutes reading one partner's code, asking questions to\nthe person whose code you are reviewing. You will then switch roles so that the\nreviewer becomes the reviewee.\n\nFinally, each of you will fill out the survey at the following link:\n[tinyurl.com/stat243-2022-lab5](https://tinyurl.com/stat243-2022-lab5), where you\nwill summarize the differences between your work and and your partner's work,\nnoting anything that was particularly novel to you. You will need to log in with\nyour Berkeley account to access this survey.\n\nThe survey response is worth 1 point, similar to in class group work or the unit\ncheck ins, and will be graded. You will receive credit as long as your response\nis thoughtful (e.g. at least a couple of sentences). If you choose not to come\nto section, please find a partner or two on your own to do the paired review\nwith and submit the survey by Wednesday Oct. 5 at 5:59pm to receive credit.\n\n## Some Guiding Questions\n\n1. Is the code visually easy to break apart? Can you see the entire body of the\nfunctions without scrolling up/down left/right? The general rule-of-thumb is no\nmore than 80 in either direction (80 character width, 80 lines; the first\nrestriction should be practiced more religiously).\n\n2. Are the data structures easy to parse? Do you understand what information is in\nwhich objects? Is the type of data appropriate?\n\n3. Are the functions easy to parse? Is it clear what they are doing, what information\nis being passed to each function, and what the return value/objects are?\n\n4. Look at the regex. Are there any edge cases that were missed? Was anything handled\nparticularly well? Any novel expressions that you didn't think of?\n\n5. Look at the plots. Are they well labeled? Is it easy to read information from them?\nDo they provide an assurance that the code is running correctly? Was there anything\nparticularly neat about your partner's solution?\n\n6. EXTRA. Look at Problem 2, compare/contrast your approaches to OOP. Explain the\nlogic behind your design.\n\n# General notes about homeworks\n\nBelow are some notes to keep in mind when doing your problem sets.\n\n## Address All Aspects of the Problems\n\nYou **have to** answer the questions on the homework, unless the instructions\nsay otherwise. When in doubt, please post to Ed Discussion!\n\nDo whatever you'd like beyond that and be as creative as you wish, but **you\nmust answer the questions that were asked**. This includes all parts of a\nwritten response question. If you do not answer these, you are throwing away\npoints.\n\n## Code Should be Preceded By Introductory Text\n\nFor each sub-problem where code is required, please include an introduction to\nin the text _before_ presenting any code. This should include a brief summary of\nwhat the code does and how you approached the solution, plus any relevant\nchallenges you faced. This doesn't have to be very long, but it should have some\nsubstance.\n\nIf there's a natural stopping point in your code -- e.g., between separate\nfunctions, after you've accomplished some task(s), or somewhere you want to\nhighlight what you just did -- then feel free to break longer code chunks up\nwith some text if you think it will help with readability / flow of your\ndocument. However, good code quality and substantive code comments will often\nsuffice.\n\n:::{.callout-important}\n## Code comments are not a replacement for the introductory text\n\n#### a. How to lose Presentation points\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# To answer this problem, I wrote the code below which does x, y, and z...\n# and this comment should instead be in the text above the code chunk :(\nhow_to_lose_points <- function(...) { ... }\n```\n:::\n\n:::\n\n## Include Your Code\n\nMost people include it as they go along, which is fine. If you find that messy,\nput an appendix at the end with all of the function definitions. This applies to\ncode for plots as well.\n\n## Include Relevant Outputs\n\nWhere appropriate, include some sample outputs from your code. You don't have to\ndo this for every single function, but be sure to give outputs if the question\nasks for it to avoid points off, e.g. \"print out or plot the number of chunks\nfor the candidates\" or \"report the number of observations in each year by\nprinting the information to the screen\".\n\nIf outputs are long and you can't truncate them, then create an appendix section\nat the end of your document and put them there, with a subheading for the\nrelevant problem. Please also be sure to include a note that you did so in the\ntext, e.g. \"The output can be found in the Appendix.\"\n\n## Avoid Unnecessary Outputs\n\nPlease use `suppressPackageStartupMessages()` or set `warning = FALSE` and\n`message = FALSE` in a code chunk that **only** loads the packages. Please on't\nuse these chunk options on other chunks. If something is going wrong ou need to\nfix it, as opposed to not printing the warning.\n\n## Use Good Formatting to Make Clear What Problem You're Answering\n\nYou have the power of Markdown in your hands, so use it! While you're free to\nuse the `.Rmd` source code for the problem set instructions as a template, the\ninstructions are written as a list, and `.Rmd` is finicky when adding text or\ncode chunks between sequential list items.\n\nIt can often be less error-prone to start a new `.Rmd` from scratch and just use\nheader tags like `#` (top level section) and `##` (second level section) to\nseparate your problems and sub-problems.\n\nFor example:\n\n```markdown\n# Problem 1: Assertions and testing\n\n## a. Assertions\n\nIn the function below, I added an assertion to check for...\nwhich guards against... and gives helpful feedback to the user\ntelling them to...\n\n```\n\nNote that you have to include a space between the final `#` and the header text,\nor the header won't render correctly, e.g.:\n\n```markdown\n#Header\n```\n\nproduces the following non-header text:\n\n#Header\n\nIf you're having trouble with Markdown, see [2.5 Markdown syntax](https://bookdown.org/yihui/rmarkdown/markdown-syntax.html)\nfrom the _R Markdown: The Definitive Guide_ book.\n\n## A Couple of Useful Tools in RStudio\n\nYou can autoindent your code in RStudio using Command or Ctrl + I. You can also\nautoformat your code with Shift + Command or Ctrl + A. There are some other\nuseful shortcuts in the Code menu.\n\n## Extra Credit\n\nThis is something additional, above and beyond the basic homework. Repeating the\nanalysis already performed, but with different parameters, is not novel.\n\n## Code Testing\n\nYou should have already tested all aspects of your R code before you submit it.\nYour code should run properly if you restart RStudio and render your `.Rmd`. I\nhave seen several assignments where students renamed a variable at the last\nsecond which causes their code to break, are referencing a global variable that\ndoesn't exist in the `.Rmd`, etc. which tells me they did not fully test that\ntheir code works before submitting. When reasonable, the functions you create\nshould have a set of small but thoughtful examples showing that the code works\nas expected.\n\n## Simple is Often Better\n\nYou should always be thinking of ways to make your code as simple as possible\n(while maintaining correctness, numerical precision, speed, etc.). For example,\nthe following three chunks of code all do the same thing:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntotal <- 0\nfor (i in 1:length(x)) {\n    total <- total + x[i]\n}\ntotal / length(x)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(x) / length(x)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(x)\n```\n:::\n\n\nBut the third option is preferred. Simple code helps with debugging (as\nthere are fewer lines of code to check), improves readability (both for\nyourself and others), and can often (though not always) result in faster\ncode.\n\n## Plots and Comments\n\nPlots need to have a title, axis labels, and a key if there are several types of\ndata. Both code _and_ comment lines should be ~80 characters in length, e.g.:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n####################\n# Wrap your comments\n####################\n\n# This is a bad comment\n# Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n\n# This is a good comment\n# Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n# tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n# veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ...etc\n\n###############\n# Good plotting\n###############\n\n# set things up\nn <- 50\nx <- 1:n\ny <- runif(n = n, min = 0, max = 10)\n\ncol_factor <- sample(x = c(1, 2), size = n, replace = T, prob = c(1, 2))\n\ndf <- data.frame(x, y, color = as.factor(col_factor))\n\n# make the plot\nggplot(df, aes(x = x, y = y)) +\n  geom_point(aes(color = color), size = 3) +\n  geom_line() +\n  theme_bw() +\n  labs(x = \"Label related to data\", y = \"Label related to data\") +\n  ggtitle(\"Short but informative title\") +\n  scale_color_discrete(name = \"Group designation\") +\n  theme(legend.position = c(1, 1),\n        legend.justification = c(1, 1),\n        legend.background = element_blank(),\n        legend.box.background = element_rect(colour = \"black\")) +\n  ylim(0, 13)\n```\n\n::: {.cell-output-display}\n![](code_review_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n## Vectorization\n\n\"Vectorization\" in R implies using functions that naturally operate over vector\ninputs, rather than processing each element one at a time. This ends up being\nfaster because, under the hood, vectorized functions in R actually call\ncorresponding code written in C, and the C code itself uses a loop that runs\nmuch more quickly than an equivalent loop in R would. But to do that, it needs\nto receive the full vector all at once.\n\nR is vectorized in many basic mathematical operations (addition, subtraction,\nmultiplication, division, etc.) and any other functions have built-in\nvectorization as well. Some functions -- like those for linear algebra -- even\nuse highly optimized parallel routines in C, adding further speedups. So when\noperating on large vectors or matrices, be sure to check the documentation to\nsee if there is a vectorized function that you can use to your advantage.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#####################\n# vectorized division\n#####################\n\nx <- 1:100\ny <- 100:1\n\na_div <- mapply(FUN = \"/\", x, y)\nv_div <- x / y\n\nall.equal(a_div, v_div)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nidentical(a_div, v_div)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n########################\n# vectorized multinomial\n########################\n\nprobs <- matrix(data = c(0.1,0.1,0.8, 1/3,1/3,1/3), nrow = 2, byrow = T)\n\nset.seed(0)\na_mnom <- t(apply(X = probs, MARGIN = 1, FUN = rmultinom,\n                 n = 1, size = 100))\n\nset.seed(0)\nv_mnom <- extraDistr::rmnom(n = 2, size = 100, prob = probs)\n\nall.equal(a_mnom, v_mnom)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nidentical(a_mnom, v_mnom) # why false?\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n# short benchmark\nmicrobenchmark::microbenchmark(\n    \"apply\" = apply(X = probs, MARGIN = 1,\n                    FUN = rmultinom, n = 1, size = 100),\n    \"vector\" = extraDistr::rmnom(n = 2, size = 100,\n                                 prob = probs),\n    times = 100)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUnit: microseconds\n   expr    min      lq     mean median    uq     max neval cld\n  apply 36.720 37.6400 39.77439 38.728 39.49 102.926   100   b\n vector  5.639  6.1305  7.42927  7.014  8.30  23.061   100  a \n```\n:::\n:::\n\n\nIf you want to learn a bit more about vectorization, check out [24.5 Vectorize](https://adv-r.hadley.nz/perf-improve.html#vectorise) \nin the _AdvancedR_ book.\n",
    "supporting": [
      "code_review_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}