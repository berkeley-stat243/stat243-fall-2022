{
  "hash": "2807efe0380769e29c49db4f73b983aa",
  "result": {
    "markdown": "---\ntitle: \"Intro to Python\"\nauthor: \"Andrew Vaughn, James Duncan\"\ndate: \"2022-10-07\"\nformat:\n  pdf:\n    documentclass: article\n    margin-left: 30mm\n    margin-right: 30mm\n    toc: true\n  html:\n    theme: cosmo\n    css: ../../styles.css\n    toc: true\n    code-copy: true\n    code-block-background: true\nexecute:\n  freeze: auto\n---\n\n# Background\n\n\n## Preparation\n\nThis tutorial assumes you are familiar with R.\n\nYou will also need Python and IPython installed on your computer, as well as a few core additional packages, including re, numpy, scipy, and pandas. \n\nPackages can generally be installed via pip, or via conda if you have the Anaconda (or Miniconda) installation of Python. The following shows how to do this from the command line on MacOS or Linux.\n\n\n```{bash}\n## using conda\nconda list\nconda install numpy\nconda install ipython\n\n## using pip\npip install numpy\npip install ipython\n# or to install within your home directory if you do not have admin control of the computer\npip install --user numpy\n```\n\n\nFor additional help with installation, please see the [IPython installation page](http://ipython.org/install.html).\n\n## Resources\n\nUseful written references and tutorials:\n\n-   <https://docs.python.org/3/index.html>\n-   <https://docs.python.org/3/library/index.html>\n-   <https://scipy-lectures.github.io/>\n\nSome introductory video lectures:\n\n-   <https://www.youtube.com/watch?v=a_Z_6brm9ZQ>\n\nWhile working through this tutorial, you should type the example code\nsnippets at an interactive Python terminal. I recommend using either the\nIPython shell or a Jupyter IPython notebook. To start an IPython shell, type\nthe following at a bash prompt:\n\n\n```{bash}\nipython\n```\n\n\nTo start an Jupyter IPython notebook, type this:\n\n\n``` {bash}\njupyter notebook\n```\n\n\nA notebook should open in your browser.\n\nAlternatively you can access Jupyter notebooks through a service called [Jupyterhub on the SCF](https://jupyter.stat.berkeley.edu).\n\nSide note: to have all output (not just the last result) printed in the Jupyter notebook, you can run this in a cell in your notebook.\n\n```python\nfrom IPython.core.interactiveshell import InteractiveShell\nInteractiveShell.ast_node_interactivity = \"all\"\n```\n\n## Python 2 vs. 3\n\nPython 3 is the current version of Python. For many years the old version\n(Python 2) has co-existed with Python 3 and Python 2 has been used by many\npeople despite the existence of Python 3. Python 2 is now being phased out, so don't use it.\n\nIntroduction\n===============\n\nFormatting Python code\n-------------------------\n\nUnlike most languages, in Python indentation determines code blocks, including functions, loops, and if-else statements.\n\nThe standard is one tab or 4 spaces, but you can use other spacing if it's consistent within a block of code.\n\n\n``` {.sourceCode .python}\na = 3\n a = 3  # this will cause an IndentationError, at least in Python itself, if not IPython\n```\n\nNote that because indentation determines the beginning and end of code blocks, the following two pieces of code do different things.\n\n``` {.sourceCode .python}\nif a>=4:    \n    print('a is big')\n    if(a == 4):\n        print('a is 4')\nelse:\n    print('a is small')\n\nif a>=4:    \n  print('a is big')\n  if(a == 4):\n        print('a is 4')\n  else:\n        print('a is not 4')\n```\n\nThe importance of indentation can cause problems when cutting and pasting code into a Python session.\n\nObjects\n-------\n\nEverything is an object in Python. Roughly, this means that it can be\ntagged with a variable (i.e., given a name) and passed as an argument to a function. Often it\nmeans that everything has *attributes* and *methods*.\n\nCertain objects in Python are mutable (e.g., lists, dictionaries), while\nother objects are immutable (e.g., tuples, strings, sets). Mutable means one can change parts of the object.\n\nMany objects can be composite (e.g., a list of dictionaries or a dictionary of lists,\ntuples, and strings).\n\nHere's a list in Python. It's similar to a list in R in that it can store heterogeneous information, but the syntax is a bit different.\n\nAlso note that indexing in Python starts at 0 not at 1.\n\n``` {.sourceCode .python}\nmyList = [1, 2, 'foo']\nmyList[0]\nmyList[1]\nmyList[1] = 2.5\nmyList\n```\n\nHere's a tuple in Python. What's different compared to the list?\n\n\n``` {.sourceCode .python}\nmyTuple = (1, 2, 'foo')\nmyTuple[1] = 2.5\nmyTuple\n```\n\nVariables\n---------\n\nAs in R and other interpreted languages, variables are not their values in Python (think \"I am not my name, I am\nthe person named XXX\"). You can think of variables as tags on objects.\nIn particular, variables can point to (be bound to) an object of one type and then\nreassigned to an object of another type without error.\n\n``` {.sourceCode .python}\na = 'foobar'\na\na * 4\nlen(a)\n\na = 3\na\na*4\nlen(a)\n```\n\nModules, files, packages, import\n--------------------------------\n\nWhile you will often explore things from an interactive Python prompt,\nyou will save your code in files for reuse as well as to document what\nyouâ€™ve done. You can use Python code saved in a plain text file from a\nPython prompt or other files by importing it. Typically, this is done at\nthe top of a file (if you are working at a prompt, you just need to\nimport it before you want to use the functionality).\n\nNote that the use of `mytest.` is similar to our discussion of package\nnamespaces in R.\n\n``` {.sourceCode .bash}\ncat mytest.py  # special IPython functionality to call the operating system\n```\n\n``` {.sourceCode .python}\ndel(a); del(hello)   # delete any existing objects\n\nimport mytest          # make available objects/functions in mytest.py\n\nmytest.hello()         # access using object-oriented style syntax\nmytest.a\n\nhello()\na\n```\n\nWe can import everything in the test.py file if we want. Why\nmight this not be a great idea?\n\n``` {.sourceCode .python}\nfrom mytest import *\n\nhello()\na\n```\n\n\nAs in R, you can also load in additional supporting packages for extra functionality.\nIn contrast to R, a lot of basic functionality is provided in supporting packages\nthat need to be loaded before you can use it.\n\nHere are some examples of importing Python packages and using functionality from them:\n\n``` {.sourceCode .python}\nfrom math import cos\ncos(0)\nsin(0)    # why doesn't this work?\nimport math\nmath.cos(0)\nmath.sin(0)\nimport numpy as np\nnumpy.arctan(1)\nnp.arctan(1)\nimport scipy as sp\nimport matplotlib.pyplot as plt\n```\n\nNote as seen above for numpy and scipy, it's common to import a package but give it a\nshortened name, 'np' and 'sp' in this case.\n\nThe different packages have different namespaces, which helps to avoid problems with\ndifferent packages using the same names for different functions.\n\n\nDocumentation and getting help\n-------------------------------\n\nWe can get help like this.\n\n``` {.sourceCode .python}\nIn [1]: import numpy as np\n\nIn [2]: np.ndim?\nType:        function\nString form: <function ndim at 0x7fcabd864938>\nFile:        /usr/lib64/python2.7/site-packages/numpy/core/fromnumeric.py\nDefinition:  np.ndim(a)\nDocstring:\nReturn the number of dimensions of an array.\n\nParameters\n----------\na : array_like\n    Input array.  If it is not already an ndarray, a conversion is\n    attempted.\n\nReturns\n-------\nnumber_of_dimensions : int\n    The number of dimensions in `a`.  Scalars are zero-dimensional.\n\nSee Also\n--------\nndarray.ndim : equivalent method\nshape : dimensions of array\nndarray.shape : dimensions of array\n\nExamples\n--------\n>>> np.ndim([[1,2,3],[4,5,6]])\n2\n>>> np.ndim(np.array([[1,2,3],[4,5,6]]))\n2\n>>> np.ndim(1)\n0\n```\n\nDocstrings are an important part of Python. A docstring is a character string that occurs as the first statement in a module, function, class, or method definition. Such a docstring becomes the __doc__ special attribute of that object. All modules (e.g., test.py is a module) should normally have docstrings, and all functions and classes exported by a module should also have docstrings. \n\n\nDecoding error messages\n--------------------------\n\nRun the following code and try to tease out where the error is. The tricky part is that the error occurs within a function where the function comes from a module (separate code file).\n\n``` {.sourceCode .python}\nimport days\n\ndays.print_friday_message()\n```\n\nThe list of function calls that led to the error is called a *traceback*.  (Recall that in R you can get similar output using `traceback()` after an error or setting `options(error = recover)` before an error.)\n\nData Structures\n===============\n\nPython has a number of basic data structure types that are widely used. There are both similarities and differences from basic data structures in R.\n\n-   <https://docs.python.org/3/library/stdtypes.html>\n-   <https://docs.python.org/3/tutorial/datastructures.html>\n-   <https://docs.python.org/3/reference/datamodel.html>\n\nNumbers\n-------\n\nPython has integers, floats, and complex numbers with the usual\noperations.\n\n``` {.sourceCode .python}\n2*3\n2/3\n\n# be careful - if you try `2/3` in Python 2, you'll get different behavior.\n\nx = 1.1\ntype(x)\n\nx * 2\nx ** 2\n\n(type(1), type(1.1), type(1+2j))\ny = 1+2j\n```\n\n\nWe can apply various functions to numbers, as expected.\n``` {.sourceCode .python}\nimport math\nmath.cos(0)\nmath.cos(math.pi)\n```\n\nThe *math* package in the standard library includes many additional\nnumerical operations.\n\nIf you type the name of a module or package followed by period (.) and tab\nyou should see the objects and functions in that module/package.\n\n``` {.sourceCode .python}\nmath.    \n```\n```\nmath.acos       math.degrees    math.fsum       math.pi\nmath.acosh      math.e          math.gamma      math.pow\nmath.asin       math.erf        math.hypot      math.radians\nmath.asinh      math.erfc       math.isinf      math.sin\nmath.atan       math.exp        math.isnan      math.sinh\nmath.atan2      math.expm1      math.ldexp      math.sqrt\nmath.atanh      math.fabs       math.lgamma     math.tan\nmath.ceil       math.factorial  math.log        math.tanh\nmath.copysign   math.floor      math.log10      math.trunc\nmath.cos        math.fmod       math.log1p      \nmath.cosh       math.frexp      math.modf\n```\n\n\n\n**Exercises**\n\n- Using the section on \"Built-in Types\" from the [official \"The Python\nStandard Library\" reference](https://docs.python.org/3/library/index.html), figure out how to compute:\n    1.  $(\\lceil \\frac{3}{4} \\rceil \\times 4)^3$, \n    and\n    2.  $\\sqrt{-1}$.\n\n\n\nObjects and object-oriented programming\n---------------------------------------\n\nWe'll talk about this in more detail later, but it's worth mentioning here that Python is an object-oriented language.  What this means is that variables in Python are objects that are instances of a class.\n\nObjects have methods that can be used on them and attributes (member data) that are part of the object. All objects in a class have the same methods and same member data 'slots', but different objects will have different values in those slots.\n\nNote that even the basic numeric structures behave like objects. We can use tab completion to see what methods are available for an object and what member data are part of an object.\n\n``` {.sourceCode .python}\nx = 3.0\ntype(x)\nx.\n# x.as_integer_ratio  x.hex               x.real\n# x.conjugate         x.imag              \n# x.fromhex           x.is_integer        \n```\n\nWhich of those are attributes/metadata ('member data') and which are methods ('member functions')? If it's a method, say `foo`, you can run the method as `x.foo()`. If it's member data, you can see its value with `x.foo`. \n\n\nTuples\n------\n\nTuples are immutable sequences of (zero or more) objects. Functions in\nPython often return tuples.\n\n``` {.sourceCode .python}\nx = 1; y = 'foo'\n\nxy = (x, y)\ntype(xy)\nxy = x,y\ntype(xy)\n\nxy\nxy[1]\n\nxy[1] = 3\n\na,b = x,y\na\nb\n```\n\n**Exercises**\n\n- Create the following: `x=5` and `y=6`. Now swap their values using a single line of code. (How would you do this in R?)\n- What happens when you multiply a tuple by a number? how is this different than similar syntax in R?\n- What's nice about using immutable objects in your code?\n\nLists\n----\n\nLists are mutable sequences of (zero or more) objects.\n\n``` {.sourceCode .python}\ndice = [1, 2, 3, 4, 5, 6]\ndice.extend([7,8])\n\ndice.insert(3, 100)\n```\n\nIndexing (also called 'slicing') in Python starts at 0 and ends at the length of the object minus 1.\n\n``` {.sourceCode .python}\ndice = [1, 2, 3, 4, 5, 6]\ndice[0]\ndice[1]\ndice[6]\n```\n\nOne can also use sequences. Figure out what is going on here:\n\n``` {.sourceCode .python}\ndice = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ndice[1::2]\ndice[1:4:2]\n\ndice[1::2] = dice[::2]\n\ndice\n```\n\n**Exercises**\n\n- What do you get if you multiply a list of numbers by a number? We'll need to use numpy if we want this to behave like we might expect based on R.\n- What does the following tell you about copying and use of memory in Python?\n``` {.sourceCode .python}\na = [1, 3, 5]\nb = a\nid(a)\nid(b)\n# this should confirm what you might suspect\na[1] = 5\n```\n\nDictionaries\n------------\n\nDictionaries are mutable, unordered collections of key-value pairs. They're like named lists or named vectors in R.\n\n``` {.sourceCode .python}\nstudents = {\"Jarrod Millman\": ['A', 'B+', 'A-'], \n            \"Thomas Kluyver\": ['A-', 'A-'], \n            \"Stefan van der Walt\": 'and now for something completely different'}\nstudents\nstudents.keys()\nstudents.values()\nstudents[\"Jarrod Millman\"]\nstudents[\"Jarrod Millman\"][1]\nstudents.\n```\n\n\nControl flow\n============\n\n-   <https://docs.python.org/3/tutorial/controlflow.html>\n\nIf-then-else\n------------\n\n-   <https://docs.python.org/3/tutorial/controlflow.html#if-statements>\n\nThis is as expected based on your experience with other languages. As previously noted, the indentation is important.\n\n``` {.sourceCode .python}\nx = 2\n\nif a>=4:    \n    print('a is big')\n    if(a == 4):\n        print('a is 4')\nelse:\n    print('a is small')\n\nif a>=4:    \n    print('a is big')\n    if(a == 4):\n        print('a is 4')\n    else:\n        print('a is not 4')\n```\n\nFor-loops (and list comprehension)\n----------------------------------\n\n-   <https://docs.python.org/3/tutorial/controlflow.html#for-statements>\n-   <https://docs.python.org/3/whatsnew/2.0.html#list-comprehensions>\n\nHere's basic use of a for loop. Once again indentation is critical, in this case for indicating where the loop ends.\n\n``` {.sourceCode .python}\nfor x in [1,2,3,4]:\n    print(x)\n\nfor x in [1,2,3,4]:\n    y = x*2\n    print(y, end=\" \")\n\nprint(\"\\n\")\nfor x in range(30):\n    print(x)\n    y = x\n\n\nprint(y, end=\" \")\n```\n\nBuilding up a list piece-by-piece is a common task, which can easily be\ndone in a for-loop. An approach called 'List comprehension' provides a compact syntax to\nhandle this task.\n\n``` {.sourceCode .python}\ny = [x for x in range(4)]\n\nvals = [-4, 3, -1, 2.5, 7]\n[x for x in vals if x > 0]  # list comprehension\n\n```\n\n\n**Exercises**\n\n- See what `[1, 2, 3] + 3` returns. Try to explain what happened and why.\n- Use list comprehension to perform element-wise addition of a scalar to a list of scalars.\n\n\n\nFunctions\n===============\n\n-   <https://docs.python.org/3/tutorial/controlflow.html#defining-functions>\n\nHere's an example that illustrates both positional arguments (always first) and named arguments.\n\n``` {.sourceCode .python}\ndef add(x, y=1, absol=False):\n    if absol:\n        return(abs(x+y))\n    else:\n        return(x+y)\n\nadd(3)\nadd(3, 5)\n\nadd(3, absol=True, y=-5)\n\nadd(y=-5, x=3)\nadd(y=-5, 3)\n```\n\n**Exercises**\n\n- Define a function that will take the sqrt of a number and will (if requested by the user) set the square root of a negative number to 0.\n\n\nMath and Statistics\n======================\n\nNumPy and SciPy\n-------------\n\nStandard lists in Python are not amenable to mathematical manipulation unlike standard vectors in R. Instead we generally work with numpy arrays. These arrays can be of various dimensions (i.e., vectors, matrices, multi-dimensional arrays). One important difference between R and numpy objects is that numpy performs operations *in place* - i.e. the object itself is modified and no copies are made. \n\n``` {.sourceCode .python}\nz = [0, 1, 2] \n\ny = np.array(z)\ny*3\n\ny.dtype  # what type of value is stored in the array\n\n\nx = np.array([[1, 2], [3, 4]], dtype=np.float64)\nx*x         # element wise multiplication\nx.dot(x)    # matrix multiplication\nx.T         # transpose\n\nnp.linalg.svd(x)   # do an SVD\n\ne = np.linalg.eig(x)  # find eigenvalues and vectors\n\ne[0]  # first eigenvalue (not the largest in this case...)\ne[1][:, 0] # corresponding eigenvector\n```\n\nAll of the elements of the array must be of the same type.\n\nThere are a variety of numpy functions that allow us to do standard mathematical/statistical manipulations. \n\nHere we'll use some of those functions in addition to some syntax for subsetting and vectorized calculations.\n\n``` {.sourceCode .python}\nnp.linspace(0, 1, 5)\n\nnp.random.seed(0)\nx = np.random.normal(size=10)\n\npos = x > 0\n\ny = x[pos]\n\nx[[1, 3, 4]]\n\nx[pos] = 0\n\nnp.cos(x)\n```\n\nscipy has even more numerical routines, including working with distributions and additional linear algebra.\n\n``` {.sourceCode .python}\nimport scipy.stats as st\nst.norm.cdf(1.96, 0, 1)\nst.norm.cdf(1.96, 0.5, 2)\nst.norm(0.5, 2).cdf(1.96)\n```\n\n**Exercise**\n\n- See what happens if you try to create a numpy array with a mix of numbers and character strings.\n- Try to add a vector to a matrix; how does this compare to R?\n\n\nPandas\n---------\n\nPandas provides a Python implementation of R's dataframe capabilities. Let's see some example code.\n\n``` {.sourceCode .python}\nimport pandas as pd\ndat = pd.read_csv('gapminder.csv')\ndat.head()\n\ndat.columns\ndat['year']\ndat.year\ndat[0:5]\n\ndat.sort_values(['year', 'country'])\n\ndat.loc[0:5, ['year', 'country']]  # R-style indexing\n\ndat[dat.year == 1952]\n\nndat = dat[['pop','lifeExp','gdpPercap']]\nndat.apply(lambda col: col.max() - col.min())\n```\n\nNow let's see the sort of split-apply-combine functionality that is popular in dplyr and related R packages.\n\n``` {.sourceCode .python}\ndat2007 = dat[dat.year == 2007].copy()  \n\ndat2007.groupby('continent', as_index=False).mean()\n\ndef stdize(vals):\n    return((vals - vals.mean()) / vals.std())\n\ndat2007['lifeExpZ'] = dat2007.groupby('continent')['lifeExp'].transform(stdize)\n```\n\n**Exercise**\n\n- Use *pd.merge()* to merge the continent means for life expectancy for 2007 back into the original *dat2007* dataFrame.\n\n\n\n\nAdditional topics\n==================\n\nStyle \n-----\n\nAdopting standard coding conventions is good practice.\n\n-   <https://www.python.org/dev/peps/pep-0008/>\n-   <https://docs.python.org/3/tutorial/controlflow.html#intermezzo-coding-style>\n-   <https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt>\n-   <http://matplotlib.org/devel/coding_guide.html>\n\nThe first link above is the official \"Style Guide for Python Code\",\nusually referred to as PEP8 (PEP is an acronym for Python Enhancement\nProposal). There are a couple of potentially helpful tools for helping\nyou conform to the standard. The\n[pep8](https://pypi.python.org/pypi/pep8) package that provides a\ncommandline tool to check your code against some of the PEP8 standard\nconventions. Similarly,\n[autopep8](https://pypi.python.org/pypi/autopep8) provides a tool to\nautomatically format your code so that it conforms to the PEP8\nstandards. I have used both a little and they seem to work fairly well.\n\nClasses\n------------\n\n-   <https://docs.python.org/3/tutorial/classes.html>\n\nWe've already seen a bunch of object-oriented behavior. Here we'll see how to make our own classes and objects that are instances (realizations) of a class.\n\n``` {.sourceCode .python}\nclass Rectangle(object):\n    dim = 2  # class variable\n    counter = 0\n    def __init__(self, height, width):\n        self.height = height  # instance variable\n        self.width = width    # instance variable\n        self.set_diagonal()\n        Rectangle.counter += 1\n    def __repr__(self):\n        return(\"{0} by {1} rectangle\".format(self.height, self.width))        \n    def area(self, verbose = False):\n\tif verbose:\n\t    print('Computing the area... ')\n        return(self.height*self.width)\n    def set_diagonal(self):\n        self.diagonal = pow(self.height**2 + self.width**2, 0.5)\n\nx = Rectangle(10, 5)\n\nx.dim\nx.dim = 'foo'\nx.dim # hmmm\n\nx.area()\nRectangle.area(x)\n\ny = Rectangle(4, 8)\ny.counter\nx.counter\n```\n\nStrings\n----------\n\nStrings are immutable sequences of (zero or more) characters.\n\n**Sequences**\n\nUnlike numbers, Python strings are container objects. Specifically, it\nis a sequence. Python has several sequence types including strings,\ntuples, and lists. Sequence types share some common functionality, which\nwe can demonstrate with strings.\n\n**Indexing** \n\nTo see how indexing works in Python letâ€™s use the\nstring containing the digits 0 through 9.\n\n``` {.sourceCode .python}    \nimport string\nstring.digits \nstring.digits[1]\nstring.digits[-1]\n```\n\nNote that indexing starts at 0 (unlike R and Fortran, but like C).\nAlso negative integers index starting from the end of the sequence.\nYou can find the length of a sequence using the *len* function.\n\n**Slicing** \n\nSlicing allows you to select a subset of a string (or\nany sequence) by specifying start and stop indices as well as a\nstep, which you specify using the `start:stop:step` notation inside\nof square braces.\n\n``` {.sourceCode .python}\nstring.digits[1:5]\nstring.digits[1:5:2]\nstring.digits[1::2]\nstring.digits[:5:-1]\nstring.digits[1:5:-1]\nstring.digits[-3:-7:-1]\n```\n\n**Subsequence testing**\n\n``` {.sourceCode .python}    \n'23' in string.digits \n'25' not in string.digits\n```\n\n**String methods**\n\n``` {.sourceCode .python}\nstring1 = \"my string\"\nstring1.\n```\n```\nstring1.capitalize  string1.islower     string1.rpartition\nstring1.center      string1.isspace     string1.rsplit\nstring1.count       string1.istitle     string1.rstrip\nstring1.decode      string1.isupper     string1.split\nstring1.encode      string1.join        string1.splitlines\nstring1.endswith    string1.ljust       string1.startswith\nstring1.expandtabs  string1.lower       string1.strip\nstring1.find        string1.lstrip      string1.swapcase\nstring1.format      string1.partition   string1.title\nstring1.index       string1.replace     string1.translate\nstring1.isalnum     string1.rfind       string1.upper\nstring1.isalpha     string1.rindex      string1.zfill\nstring1.isdigit     string1.rjust       \n```\n\n``` {.sourceCode .python}\nstring1.upper()\n\nstring1.upper?\n\nstring1 + \" is your string.\"\n\"*\"*10\n\nstring1[3:]\nstring1[3:4] \nstring1[4::2]\n\nstring1[3:5] = 'ts'\n```\n\n``` {.sourceCode .python}\nstring1 > \"ab\"\nstring1 > \"zz\"\nstring1.__\n```\n```\nstring1.__add__           string1.__len__\nstring1.__class__         string1.__lt__\nstring1.__contains__      string1.__mod__\nstring1.__delattr__       string1.__mul__\nstring1.__doc__           string1.__ne__\nstring1.__eq__            string1.__new__\nstring1.__format__        string1.__reduce__\nstring1.__ge__            string1.__reduce_ex__\nstring1.__getattribute__  string1.__repr__\nstring1.__getitem__       string1.__rmod__\nstring1.__getnewargs__    string1.__rmul__\nstring1.__getslice__      string1.__setattr__\nstring1.__gt__            string1.__sizeof__\nstring1.__hash__          string1.__str__\nstring1.__init__          string1.__subclasshook__\n```\n\n**Exercises**\n\n- Using this string: `x = 'The ant wants what all ants want.'`, solve the following string manipulation problems using string indexing, slicing, methods, and subsequence testing:\n    1.  Convert the string to all lower case letters (donâ€™t change x).\n    2.  Count the number of occurrences of the substring `ant`.\n    3.  Create a list of the words occurring in `x`. Make sure to remove\n    punctuation and convert all words to lowercase.\n    4.  Using only string methods on `x`, create the following string:\n    `The chicken wants what all chickens want.`\n    5.  Using indexing and the `+` operator, create the following string:\n    `The tna wants what all ants want.`\n    6.  Do the same thing except using a string method instead.\n- What can you do with the *in* and *not in* operators?  What R operator is this like and how is it different?\n- Figure out what code you could run to figure out if Python is explicitly counting the number of characters when it does `len(x)`?\n- Compare the time for computing the length of a (long) string in Python and R. What can you infer about what is happening behind the scenes?\n\n\n\nA Note on the Contents\n==============\n\nThis content was adapted by Chris Paciorek from [material prepared by K. Jarrod Millman](http://www.jarrodmillman.com/capstone/bootcamp/standard.html) and is licensed under the [CC BY-NC-SA 4.0 license](http://creativecommons.org/licenses/by-nc-sa/4.0/).\n\n",
    "supporting": [
      "python_intro_files"
    ],
    "filters": []
  }
}