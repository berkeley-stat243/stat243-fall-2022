{
  "hash": "919b112492a18b5744322477cfc1ea43",
  "result": {
    "markdown": "---\ntitle: \"Collaboration with Git\"\nauthor: \"Zoey Vernon, Andrew Vaughn, James Duncan\"\ndate: \"2022-11-04\"\nformat:\n  pdf:\n    documentclass: article\n    margin-left: 30mm\n    margin-right: 30mm\n    toc: true\n  html:\n    theme: cosmo\n    css: ../../styles.css\n    toc: true\n    code-copy: true\n    code-block-background: true\nexecute:\n  freeze: auto\n---\n\n\n\n\nIn our very first section of the semester, we discussed how to use Git and\nGitHub. Now that you have a semester's worth of experience pulling from and\ncommitting to a remote repository, we will explore some of the more advanced\nfunctionally of Git and GitHub. We will practice a number of the tools that are\nuseful when collaborating with others on a GitHub repository, which could prove\nuseful when working on your final project. There is additional information about\nusing Git for collaboration and various other features in the appendix at the\nend for those of you that are curious.\n\nIn section we will split into groups of 2 (or 3 if necessary) to practice creating\nbranches and merging. \nd\n## To Do in Section: Using Git For Collaboration\n\nWe will do this as a partner exercise to practice collaborating with git and \nfixing issues that may arise during collaboration.   \nPlease read the sections on advanced Git functionality first and then do the following exercises: \n\n1) Create a new repo (just one of you, doesn't matter who)\n2) Add your partner(s) as a collaborator.  This can be done by clicking the Settings\noption in the upper right and then selecting Collaborators on the menu on the left.\n3) Each person create a new branch (call them something different), add a file \nor two to your branch and practice\nmerging to the `master` branch.  You can do either merge on the command line or \nuse a pull request.  See section **Managing Branches** below for the commands.  Make\nsure to use `git pull` before pushing your merge to the remote repo if you\ndo it through the command line to avoid merge conflicts.  \n4) Test what happens when your remote repository is ahead of your local \nrepository, but you already staged new changes.\n  * Have one partner push a new commit to the remote repo\n  * Have the other partner try to add, commit, and push new changes without pulling\n  the most recent update and see what happens.\n  * Resolve the merge conflict.  You can do this by calling `git pull` and merging\n  the repositories or by using `git reset --soft` as described in the **Reset** \n  section below.\n5) Test what happens when a collaborator (or you on a different computer) edits \nthe same file? \n\n## Useful References\n\n[Berkeley SCF Git Basics](https://htmlpreview.github.io/?https://github.com/berkeley-scf/tutorial-git-basics/blob/master/git-intro.html)  \n[Software Carpentry Collection of Information on Git](https://swcarpentry.github.io/git-novice/)  \n[Basic Branching and Merging](https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging#_basic_merge_conflicts)  \n[Interactive Branching Tutorial](https://learngitbranching.js.org/)  \n[Advanced Merging](https://git-scm.com/book/en/v2/Git-Tools-Advanced-Merging#_advanced_merging) \n[Undoing Things](https://git-scm.com/book/en/v2/Git-Basics-Undoing-Things)  \n\n## Git Tracks Contents, Not Files\n\nMany revision control systems provide an `add` command that tells the system to \nstart tracking changes to a new file. Git's `add` command does something simpler \nand more powerful: `git add` is used both for new and newly modified files, and \nin both cases it takes a snapshot of the given files and stages that content in \nthe index, ready for inclusion in the next commit.\n\n## Manual Pages\n\nYou can get documentation for a command such as `git log --graph` with:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nman git-log\n```\n:::\n\nor\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit help log\n```\n:::\n\n\n\n## Viewing Project History\nAt any point you can view the history of your changes using:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit log\n```\n:::\n\n\nIf you also want to see complete diffs at each step, use\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit log -p\n```\n:::\n\n\nOften the overview of the change is useful to get a feel of each step:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit log --stat --summary\n```\n:::\n\n\nFor a prettier, more detailed graph (with several more options to look up):\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit log --oneline --decorate --graph --all\n```\n:::\n\n\n\n## Undoing a Mistake: checkout, reset, and revert\n### Checkout\n`git checkout` can be used to look at a previous commit.  It can also be used to \nmove to a different branch, which we will look at in the next section. Here we \ncan look at code from a previous commit with: \n\n::: {.cell}\n\n```{.bash .cell-code}\ngit checkout HEAD~1 # moves back 1 commit\ngit checkout HEAD~2 # moves back 2 commits\ngit checkout <commit_hash> # move back to a specific commit\n```\n:::\n\n\nTo find commit IDs you can use `git log` or `git reflog`.  You can also find \ncommit IDs on GitHub.  \n\nOnce you have looked at the commit you can go back to the most recent update using\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit checkout master # or replacing master with whatever branch you are on\n```\n:::\n\n\n### Revert \n`git revert` is used when you want to undo the changes made in a previous \ncommit. It will undo a commit by creating a new commit.  Consider using \n`git revert HEAD~1`, this will remove the changes that were added in the \nprevious commit.  \n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit revert HEAD~1 \ngit revert HEAD~2 \ngit revert <commit_hash> \n```\n:::\n\n\n### Reset\nIf you added something that shouldn't be commited or you want to reset your repo\nto what it looked like at a previous commit, then you need to use \nthe `git reset` feature.  \n\n\n::: {.cell}\n\n```{.bash .cell-code}\nman git-reset\n\n# e.g.\ngit reset --soft HEAD~1\ngit reset --hard HEAD~1 \n```\n:::\n\n\nGit reset moves the tip of your working tree back to the specified revision (here, \nwe go back one revision). The `--soft` flag means that the changes in the \nfiles are presevered, so all that was done was to undo the commit. If you use the \n`--hard` flag, then all changes are reverted to the specified time. \n\nIf you have done something more complex, like commiting and attempting to push a \nlarge file, the command below may be useful.\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit filter-branch --index-filter 'git rm -r --cached --ignore-unmatch <PATH/TO/FILE>' HEAD\n```\n:::\n\n\nThis deletes everything in the commit history.\n\n## Managing Branches\n\nA single Git repository can maintain multiple branches of development. To create \na new branch named \"experimental\", use\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit branch experimental\n```\n:::\n\n\nIf you now run\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit branch\n```\n:::\n\n\nThe \"experimental\" branch is the one you just created, and the \"master\" branch \nis a default branch that was created for you automatically. The asterisk marks \nthe branch you are currently on; type\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit checkout experimental\n```\n:::\n\n\nto switch to the experimental branch. Now edit a file, commit the change, and \nswitch back to the master branch:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit add file\ngit commit -m \"edited file\"\n```\n:::\n\n\nAlternatively, one can \"stash\" the changes using `git stash`.  This saves your \nchanges for later, and then reverts the working tree to the last \nHEAD (whatever the last commit was). This allows you to keep working without the \nchanges being applied to any files.  You can apply those changes later \nusing `git stash pop`, which applies the changes and removes them from your \nstash. Or, if you wish to apply the changes to multiple \nbranches, you can use `git stash apply`, which applies the changes but leaves them \nin your stash.  \n\nNow, you can switch back to the master branch.\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit checkout master\n```\n:::\n\n\nCheck that the change you made is no longer visible, since it was made on the \nexperimental branch and you're back on the master branch.\n\nYou can make a different change on the master branch and commit. At this point \nthe two branches have diverged, with different changes made in each. To merge \nthe changes made in experimental into master, run:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit merge experimental\n```\n:::\n\n\nIf the changes don't conflict, then the merge was succesful and you can add,\ncommit and push to the remote repository. If there are conflicts, markers will \nbe left in the problematic files showing the conflict;\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit diff\n```\n:::\n\n\nwill show this. Once you've edited the files to resolve the conflicts,\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit commit -a\n```\n:::\n\n\nwill commit the result of the merge. Finally,\n\nAt this point you could delete the experimental branch with\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit branch -d experimental\n```\n:::\n\n\nThis command ensures that the changes in the experimental branch are already in \nthe current branch.\n\nIf you want to remove a branch without pulling the changes into the master branch, \nthe `-D` flag deletes it without checking any of the changes.\n\nThis only removes the branch from your local machine.  To remove it from the \nremote repository, you use:  \n\n::: {.cell}\n\n```{.bash .cell-code}\ngit push -d origin experimental\n```\n:::\n\n\n## Pull-requests\nWhen working in a collaborative environment, instead of merging directly into \nthe master, it is better to create a pull-request.  This\n[link](https://www.atlassian.com/git/tutorials/making-a-pull-request) has a good \nstep-by-step explanation.  Pull requests tell repository maintainers the difference\nbetween the master repository and an individual's branch.  It will then allow\nmaintainers to comment on the pull request and get bugs fixed before the branch is\nmerged to the master.  \n\nPull requests are common practice in software development in industry.  \n  \n## Appendix: More Useful Git Functionality\n\n### Importing A Project\n\nI __do not__ recommend this process for initiating a new project. These steps are simple, \nuntil you get to creating the remote repository. Then, just like in the intro tutorial, \nyou have you setup a new repository on Github and link it to the local one.  It \nis easier to create the repo on Github, clone the empty repo locally, then put \nfiles in it as desired. \n\nAssume you have a tarball linReg.tar.gz with your initial work. You can place it\nunder Git revision control as follows.\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ntar xzf project.tar.gz\ncd project\ngit init\n```\n:::\n\n\nGit will reply (something along the lines)\n\n::: {.cell}\n\n```{.bash .cell-code}\nInitialized empty Git repository in .git/\n```\n:::\n\n\nYou've now initialized the working directory-you may notice a new directory created, \nnamed \".git\".\n\nNext, tell Git to take a snapshot of the contents of all files under the current \ndirectory (note the .), with git add:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit add .\n```\n:::\n\n\nThis snapshot is now stored in a temporary staging area which Git calls the *index*. \nYou can permanently store the contents of the index in the repository with `git commit`:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit commit -m \"add\"\n```\n:::\n\n\nThis will prompt you for a commit message. You've now stored the first version of \nyour project in Git.\n\n### Making Changes\nIf we make changes to files `file1`, `file2` and `file3` we can add them to be commited with `git add` as we have discussed before: \n\n::: {.cell}\n\n```{.bash .cell-code}\ngit add file1 file2 file3\n```\n:::\n\n\nYou are now ready to commit. You can see what is about to be committed using `git diff` \nwith the `--cached` option:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit diff --cached\n```\n:::\n\n\n(Without --cached, git diff will show you any changes that you've made but not \nyet added to the index.) \n\nYou can also get a brief summary of the situation with `git status`:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit status\n```\n:::\n\n\nAlternatively, instead of running `git add` before `git commit`, you can use:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit commit -a\n```\n:::\n\n\nwhich will automatically notice any modified (but not new) files, add them to \nthe index, and commit, all in one step.\n\n### Amending file to commit\n\nWhat if, in the files you just commited, there was a file you forgot?  This \nsituation is handled via git's `amend` option in git commit.  Say we have added and\ncommitted `file1`\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit add file1\ngit commit -m \"adding file1\"\n```\n:::\n\n\nBut we realize we also meant to commit `file2`.  We can do that by ammending the \noriginal commit as follows:\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit add file2\ngit commit --amend -m \"adding second file\"\n```\n:::\n\n\nThis allows you to add more files to a commit and then update the message, while \nkeeping your original message/commmited-files there.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}