{
  "hash": "3369fb06c1bd0cc722ccc3a1f9f6a64e",
  "result": {
    "markdown": "---\ntitle: \"Final Project\"\nsubtitle: \"Due Thursday Dec. 15, 5 pm\"\nformat:\n  pdf:\n    documentclass: article\n    margin-left: 30mm\n    margin-right: 30mm\n    toc: false\n  html:\n    theme: cosmo\n    css: ../styles.css\n    toc: false\n    code-copy: true\n    code-block-background: true\nexecute:\n  freeze: auto\n---\n\n\n\n[PDF](./project.pdf){.btn .btn-primary}\n\n\nThe project will be done in groups of three, with students assigned\nrandomly.\n\nA few comments. First, the project, when split amongst the group\nmembers, is not intended to be a huge undertaking. The goals of the\nproject are to give you experience in working collaboratively and\ndeveloping a well-designed, well-tested piece of software.\n\nThe project will be graded as a letter grade and will count for about as\nmuch as two problem sets in your final grade.\n\nPlease use standard citation practices to cite any papers/online reasources/people whose ideas you make\nuse of. Please do not consult with class members who are not in your group.\n\n\n# Problem\n\nYour task is to implement an adaptive-rejection sampler, described in\nthe Unit 9 notes (Section 5) and with details in Section 2.2 of Gilks\net al. (1992) - the PDF is in the `project` directory of the class Git repository. The result\nshould be an R package that I can install and use.\n\n1.  Your solution should allow the user to provide reasonable inputs,\n    including the number of points to sample, and should check the\n    inputs for validity (e.g., using `assertthat`). The primary input\n    should be an R function that calculates the (possibly unnormalized)\n    density of the distribution of interest in a vectorized fashion\n    (e.g., many of the \"d\" functions in R, such as `dnorm` are\n    legitimate inputs). Your code should include numerical checks that\n    catch cases of non-log-concave densities as the calculations\n    proceed. (I.e., you do not need to come up with an overall test of\n    the input density, but you should be able to do some checks that\n    will catch cases where the upper and lower bounds are not actually\n    bounding the density.) \n    \n\n2.  Formal testing is required with a set of tests where results are\n    compared to some known truth. You should have tests for the overall\n    function and any modules that do anything complicated. Given the\n    output is stochastic, how to do this will require some thought. The\n    output of your testing should be clear and interpretable. I.e., when\n    I run your tests I should see informative messages of what is being\n    done and whether a given test was passed or failed. You should also\n    have unit tests for individual functions that carry out the\n    individual computations that make up the algorithm. Note also that an important\n    part of the grade will depend on how your code performs on tests\n    that I have prepared. \n\n3.  Your solution should involve modular code, with functions or OOP\n    methods that implement discrete tasks. You should have an overall\n    design and style that is consistent across the components, in terms\n    of functions vs. OOP methods, naming of functions/objects, etc.\n\n4.  In terms of efficiency, the algorithm is inherently sequential.\n    However, you should try to vectorize as much as possible. One\n    possibility in terms of the overall calculation is that you could\n    generate a vector of samples based on the upper envelope. Then\n    determine where are the points that require evaluation of $f(x)$.\n    All points up to the first of those points can be generated before\n    changing the envelope, at which point you would throw away the\n    remaining points. How many points you generate at once might vary\n    depending on how far along you are in generating the number of\n    points requested by the user. Or you may think of other tricks.\n\n5.  Your solution should include help/manual information as follows:\n\n    a.  Basic doc strings for any function you create (i.e., include\n        comments at the beginning of the function), as well as\n        commenting of code as appropriate.\n\n    b.  An overall help page for the primary function only. This help\n        page should be directly in the form of standard R documentation\n        in a file called `ars.Rd`. You do not need help\n        pages for your auxiliary functions. Your help page should include example usage.\n\n\n# Formatting requirements and additional information \n\nYour solution to the problem should have two parts:\n\n1.  A PDF document describing your solution, prepared in R Markdown/quarto/knitr.\n    The description does not need to be more than a few pages,\n    but should describe the approach you took in terms of\n    functions/modularity/object-oriented programming, the testing\n    that you carried out, and usage on examples. It must include a paragraph describing the\n    specific contributions of each team member and which person/people\n    were responsible for each component of the work.  \n\n    **Please submit a paper copy of the document to\n    me - either directly to me, under my door, or in my mailbox. On your paper solution,\n    please indicate  the GitHub repository name clearly at the beginning\n    of your writeup so I can easily get your materials.**\n\n2.  An R package named `ars`, including the `.tar.gz` file created by\n    `R CMD build ars`, committed to the relevant Git repository (see\n    below). The package should include:\n\n    a.  A primary function called `ars` that carries out the simulation,\n        located in a file `ars.R` in the `R` directory of the package,\n\n    b.  Formal tests you applied to your overall function. You can set\n        this up with `usethis::use_testthat`. I should be able to\n        run  `testthat::test_package(’ars’)` or `testthat::test_file('/path/to/test-file.R')`\n        and have it run all your tests.\n        Please check that you can run the tests if you install your own package as\n        a fresh install, and indicate in your writeup how I can run\n        your tests. There is more information on testing in\n        [Hadley Wickham's book](https://r-pkgs.had.co.nz/tests.html).\n\n    c.  Auxiliary functions used by the primary function and testing\n        function,\n\n    d.  Help information for the main function, in a file `ars.Rd` in\n        the `man` directory. If you want, you can `ars.Rd` by hand,\n        but I recommend having it generated based on using the `roxygen2`\n        package (see [here for an example](http://adv-r.had.co.nz/Documenting-functions.html)).\n        In the latter case you would have the\n        documentation included in `ars.R`.\n\n        A good starting place for information about R packages is [Hadley Wickham's book](http://r-pkgs.had.co.nz/).\n\nFor a given subtask of the problem, if you find good code available, you\nmay use it as a modular component of your code provided it does not\nconstitute too large a part of your solution and provided you test the\ncode. Consult me with questions on this matter.\n\nYou should use Git and GitHub to manage your collaboration. Please have\nthe project be a private repository named `ars` within the Berkeley GitHub account or github.com account of one\nof the project members. **Make sure to share the repository with me (username `paciorek` in either\n`github.berkeley.edu` or `github.com`.)**\n\nYou should start the process by mapping out as a group the modular\ncomponents you need to write and how they will fit together, as well as\nwhat the primary function will do. After one person writes a component,\nanother person on the team should test it and, with the original coder,\nimprove it. Or you might consider using pair programming.\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}