{
  "hash": "1fc9980a29a09783e98c2706e288f5bd",
  "result": {
    "markdown": "---\ntitle: \"Programming concepts\"\nauthor: \"Chris Paciorek\"\ndate: \"2022-09-06\"\nformat:\n  pdf:\n    documentclass: article\n    margin-left: 30mm\n    margin-right: 30mm\n    toc: true\n  html:\n    theme: cosmo\n    css: ../styles.css\n    toc: true\n    code-copy: true\n    code-block-background: true\nexecute:\n  freeze: auto\n---\n\n\n\n[PDF](./unit5-programming.pdf){.btn .btn-primary}\n\n\n> **Note**\n> This Unit will be posted in phases as I get the material ready. Currently only Sections 1-4 are available.\n\n\nReferences:\n\n-   Books on R listed on the syllabus: Adler, Chambers, Wickham\n-   [R intro manual](http://cran.r-project.org/doc/manuals/R-intro.html)\n    and [R language\n    manual](http://cran.r-project.org/doc/manuals/R-lang.html) (R-lang),\n    both on CRAN.\n-   Murrell, Introduction to Data Technologies\n\n(Optional) Videos\n\nThere are various videos from 2020 in the bCourses Media Gallery that you\ncan use for reference if you want to. Note that I've reorganized the material in this Unit relative to 2020, so the section numbers and ordering in the videos may differ from that in the current Unit, but you should be able to match things up fairly easily.\n\n1. Strings and regular expressions\n3. Type/class coercion\n\n\n# Overview\n\nThis unit covers a variety of programming concepts, illustrated in the\ncontext of R and with comments about and connections to other languages. It also serves as a way to teach some advanced features of\nR. In general the concepts are relevant in other languages, though other\nlanguages may implement things differently. One of my goals for the unit is for us\nto think about why things are the way they are in R. I.e., what\nprinciples were used in creating the language and what choices were\nmade? While other languages use different principles and made different \nchoices, understanding what one language does in detail will be helpful when you\nare learning another language or choosing a language for a project.\n\nI'll likely refer to R syntax as *statements* or *expressions*, meaning\n any code that is a valid, complete R expression. But note that the term *expression* also means a specific type of object\nwithin the R language, as seen late in this Unit when we discuss computing on the language.\n\n# 1. Text manipulation, string processing and regular expressions (regex)\n\nText manipulations in R have a number of things in common with Python,\nPerl, and UNIX, as many of these evolved from UNIX. When I use the term\n*string* here, I'll be referring to any sequence of characters that may\ninclude numbers, white space, and special characters, rather than to the\ncharacter class of R objects. The string or strings will generally be\nstored as an R character vector.\n\n## String processing and regular expressions in R\n\nFor details of string processing in R, including use of regular expressions, see the [string\nprocessing tutorial](https://berkeley-scf.github.io/tutorial-string-processing).\n(You can ignore the sections on Python if you wish.) That tutorial then refers to\nthe [bash shell tutorial](https://berkeley-scf.github.io/tutorial-using-bash/regex) \nfor details on regular expressions.\n\nIn class we'll work through some problems in the string processing tutorial, focusing in\nparticular on the use of regular expressions with the *stringr* package.\nThis will augment our consideration of regular expressions in the shell, in particular\nby seeing how we can replace patterns in addition to finding them. \n\n## Regex/string processing challenges\n\nWe'll work on these challenges (and perhaps one or two others) in class in the process of working\nthrough the string processing tutorial.\n\n1.  What regex would I use to find any number with or without a decimal place.\n\n2.  Suppose a text string has dates in the form \"Aug-3\", \"May-9\", etc.\n    and I want them in the form \"3 Aug\", \"9 May\", etc. How would I do\n    this search and replace operation? (Alternatively, how could I do\n    this without using regular expressions at all?)\n\n## Side notes on special characters in R \n\nRecall that when characters are used for special purposes, we need to\n'escape' them if we want them interpreted as the actual character. In what\nfollows, I show this in R, but similar manipulations are sometimes\nneeded in the shell and in Python.\n\nThis can get particularly confusing in R as the backslash is also used\nto input special characters such as newline (`\\n`) or tab (`\\t`).\n\nHere are some examples of using special characters.\n\n> **Note**\n> It is hard to compile the Rmd file correctly for these R chunks, so I am just pasting in the output from running in R 'manually' in some cases.)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmp <- \"Harry said, \\\"Hi\\\"\"\n## cat(tmp)   # prints out without a newline -- this is hard to show in the pdf\ntmp <- \"Harry said, \\\"Hi\\\".\\n\"\ncat(tmp)      # prints out with the newline\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHarry said, \"Hi\".\n```\n:::\n\n```{.r .cell-code}\ntmp <- c(\"azar\", \"foo\", \"hello\\tthere\\n\")\ncat(tmp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nazar foo hello\tthere\n```\n:::\n\n```{.r .cell-code}\nprint(tmp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"azar\"           \"foo\"            \"hello\\tthere\\n\"\n```\n:::\n\n```{.r .cell-code}\ngrep(\"[\\tz]\", tmp)   ## search for a tab or a 'z'\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3\n```\n:::\n:::\n\n\n\nAs a result, in R we often need two backslashes when working with\nregular expressions. In the next examples, the first backslash says to\ninterpret the next backslash literally, with the second backslash being\nused to indicate that the caret (\\^) should be interpreted literally and\nnot as a special character in the regular expression syntax.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Search for characters that are not 'z'\n## (using ^ as regular expression syntax)\ngrep(\"[^z]\", c(\"a^2\", \"93\", \"zzz\", \"zit\", \"azar\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 4 5\n```\n:::\n\n```{.r .cell-code}\n## Search for either a '^' (as a regular charcter) or a 'z':\ngrep(\"[\\\\^z]\", c(\"a^2\", \"93\", \"zzz\", \"zit\", \"azar\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 4 5\n```\n:::\n\n```{.r .cell-code}\n## This fails (and the Rmd won't compile) because\n## '\\^' is not an escape sequence (i.e., a special character):\n## grep(\"[\\^z]\", c(\"a^2\", \"93\", \"zit\", \"azar\", \"zzz\"))\n## Error: '\\^' is an unrecognized escape in character string starting \"\"[\\^\"\n\n## Search for exactly three characters\n## (using . as regular expression syntax)\ngrep(\"^.{3}$\", c(\"abc\", \"1234\", \"def\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3\n```\n:::\n\n```{.r .cell-code}\n## Search for a period (as a regular character)\ngrep(\"\\\\.\", c(\"3.9\", \"27\", \"4.2\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3\n```\n:::\n\n```{.r .cell-code}\n## This fails (and the Rmd won't compile) because \n## '\\.' is not an escape sequence (i.e., a special character):\n## grep(\"\\.\", c(\"3.9\", \"27\")))\n## Error: '\\.' is an unrecognized escape in character string starting \"\"\\.\"\n```\n:::\n\n\n\n> **Challenge**\n> Explain why we use a single backslash to get a newline and double backslash to write out a Windows path in the examples here:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Suppose we want to use a \\ in our string:\ncat(\"hello\\nagain\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nhello\nagain\n```\n:::\n\n```{.r .cell-code}\ncat(\"hello\\\\nagain\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nhello\\nagain\n```\n:::\n\n```{.r .cell-code}\ncat(\"My Windows path is: C:\\\\Users\\\\My Documents.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMy Windows path is: C:\\Users\\My Documents.\n```\n:::\n:::\n\n\n\nFor more information, see `?Quotes` in R and the subsections of the\nstring processing tutorial that discuss backslashes and escaping.\n\nAdvanced note: Searching for an actual backslash gets even more\ncomplicated, because we need to pass two backslashes as the regular\nexpression, so that a literal backslash is searched for. However, to\npass two backslashes, we need to escape each of them with a backslash so\nR doesn't treat each backslash as part of a special character. So that's\nfour backslashes to search for a single backslash! Yikes. One rule of\nthumb is just to keep entering backslashes until things work!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Search for an actual backslash\ntmp <- \"something \\\\ other\\n\"\ncat(tmp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsomething \\ other\n```\n:::\n\n```{.r .cell-code}\ngrep(\"\\\\\\\\\", tmp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\ntry(grep(\"\\\\\", tmp))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in grep(\"\\\\\", tmp): TRE pattern compilation error 'Trailing backslash'\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nError in grep(\"\\\\\", tmp) : \n  invalid regular expression '\\', reason 'Trailing backslash'\n```\n:::\n:::\n\n\n\n> **Warning**\n> Be careful when cutting and pasting from documents that are not text\n> files as you may paste in something that looks like a single or double\n> quote, but which R cannot interpret as a quote because it's some other\n> ASCII quote character. If you paste in a \" from PDF, it will not be\n> interpreted as a standard R double quote mark.\n\nSimilar things come up in the shell and in Python, but in the shell you\noften don't need two backslashes. E.g. you could do this to look for a\nliteral \\^ character.\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngrep '\\^' file.txt\n```\n:::\n\n\n\n# 2. Interacting with the operating system and external code and configuring R \n\n## Interacting with the operating system\n\nScripting languages allow one to interact with the operating system in various ways.\nMost allow you to call out to the shell to run arbitrary shell code and save results within your session.\n\nI'll assume everyone knows about the following functions/functionality for interacting with the filesystem and file\nin R: *getwd*, *setwd*, *source*, *pdf*, *save*, *save.image*, *load*.\n\n-   To run UNIX commands from within R, use `system()`, as follows,\n    noting that we can save the result of a system call to an R object:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    system(\"ls -al\")   ## results apparently not shown when compiled...\n    files <- system(\"ls\", intern = TRUE)\n    files[1:5]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"badCode.R\"    \"cache\"        \"calc_mean.py\" \"convert.sh\"   \"convert.sh~\" \n    ```\n    :::\n    :::\n\n\n\n-   There are also a bunch of functions that will do specific queries of\n    the filesystem, including\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    file.exists(\"unit2-dataTech.Rmd\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] TRUE\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    list.files(\"../data\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"airline.csv\"           \"coop.txt.gz\"           \"cpds.csv\"             \n    [4] \"hivSequ.csv\"           \"IPs.RData\"             \"precip.txt\"           \n    [7] \"precipData.txt\"        \"RTADataSub.csv\"        \"stackoverflow-2016.db\"\n    ```\n    :::\n    :::\n\n\n\n-   There are some tools for dealing with differences between operating\n    systems. *file.path* is a nice example:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    list.files(file.path(\"..\", \"data\"))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"airline.csv\"           \"coop.txt.gz\"           \"cpds.csv\"             \n    [4] \"hivSequ.csv\"           \"IPs.RData\"             \"precip.txt\"           \n    [7] \"precipData.txt\"        \"RTADataSub.csv\"        \"stackoverflow-2016.db\"\n    ```\n    :::\n    :::\n\n\n\n    It's best if you can to write your code in a way that is *agnostic* to the underlying operating system.\n\n-   To get some info on the system you're running on:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    Sys.info()\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n                                           sysname \n                                           \"Linux\" \n                                           release \n                               \"5.4.0-120-generic\" \n                                           version \n    \"#136-Ubuntu SMP Fri Jun 10 13:40:48 UTC 2022\" \n                                          nodename \n                                         \"smeagol\" \n                                           machine \n                                          \"x86_64\" \n                                             login \n                                        \"paciorek\" \n                                              user \n                                        \"paciorek\" \n                                    effective_user \n                                        \"paciorek\" \n    ```\n    :::\n    :::\n\n\n\n## Controlling the behavior of R\n\nScripting languages generally allow you to control/customize their behavior\nin various ways by setting options.\n\n-   To see some of the options that control how R behaves, try the\n    *options* function. The *width* option changes the number of\n    characters of width printed to the screen, while *max.print*\n    revents too much of a large object from being printed to the\n    screen. \n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ## options()  # this would print out a long list of options\n    options()[1:4]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    $add.smooth\n    [1] TRUE\n    \n    $bitmapType\n    [1] \"cairo\"\n    \n    $browser\n    [1] \"xdg-open\"\n    \n    $browserNLdisabled\n    [1] FALSE\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    options()[c('width', 'digits')]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    $width\n    [1] 80\n    \n    $digits\n    [1] 7\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    ## Often it's nice to have more characters in each line on the screen,\n    ## but that would cause overly lines in the compiled file.\n    ## options(width = 120)\n    \n    options(max.print = 5000)\n    ```\n    :::\n\n\n\n    The *digits* option changes the number of digits of numbers\n    printed to the screen (but be careful as this can be deceptive if\n    you then try to compare two numbers based on what you see on the\n    screen).\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    options(digits = 3)\n    a <- 0.123456; b <- 0.1234561\n    a; b; a == b\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 0.123\n    ```\n    :::\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 0.123\n    ```\n    :::\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] FALSE\n    ```\n    :::\n    :::\n\n\n\n    More on how to (and how not to) compare real-valued numbers on a computer in Unit 8.\n\n-   Use `Ctrl-C` to interrupt execution. This will generally back out\n    gracefully, returning you to a state as if the command had not been\n    started. Note that if R is exceeding the amount of memory available, there can\n    be a long delay. This can be frustrating, particularly since a\n    primary reason you would want to interrupt is when R runs out of\n    memory.\n\n-   *sessionInfo* gives information on the current R session and can\n    be very helpful for recording the state of your session (including package versions) to allow for reproducibility.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    sessionInfo()\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    R version 4.2.0 (2022-04-22)\n    Platform: x86_64-pc-linux-gnu (64-bit)\n    Running under: Ubuntu 20.04.3 LTS\n    \n    Matrix products: default\n    BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3\n    LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/liblapack.so.3\n    \n    locale:\n     [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n     [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n     [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n     [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n     [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n    [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n    \n    attached base packages:\n    [1] stats     graphics  grDevices utils     datasets  methods   base     \n    \n    other attached packages:\n    [1] SCF_4.1.0\n    \n    loaded via a namespace (and not attached):\n     [1] digest_0.6.29     jsonlite_1.8.0    magrittr_2.0.3    evaluate_0.15    \n     [5] rlang_1.0.4       stringi_1.7.8     cli_3.3.0         rmarkdown_2.14   \n     [9] tools_4.2.0       stringr_1.4.0     htmlwidgets_1.5.4 xfun_0.31        \n    [13] yaml_2.3.5        fastmap_1.1.0     compiler_4.2.0    htmltools_0.5.3  \n    [17] knitr_1.39       \n    ```\n    :::\n    :::\n\n\n\n-   Any code that you wanted executed automatically when starting R can\n    be placed in `~/.Rprofile` (or in individual, project-specific `.Rprofile` files in\n    specific directories). This could include loading packages (see\n    below), sourcing files that contain user-defined functions that you\n    commonly use (you can also put the function code itself in\n    `.Rprofile`), assigning variables, and specifying options via\n    `options()`.\n\n-   You can have an R script act as a shell script (like running a bash\n    shell script) as follows. This will probably on work on Linux and\n    Mac.\n\n    1.  Write your R code in a text file, say `exampleRscript.R`.\n    2.  As the first line of the file, include `#!/usr/bin/Rscript`\n        (like `#!/bin/bash` in a bash shell file, as seen in Unit 2) or\n        for more portability across machines, include\n        `#!/usr/bin/env Rscript`.\n    3.  Make the R code file executable with *chmod*:\n        `chmod ugo+x exampleRscript.R`.\n    4.  Run the script from the command line: `./exampleRscript.R`\n\n    If you want to pass arguments into your script, you can do so as\n    long as you set up the R code to interpret the incoming arguments:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    args <- commandArgs(TRUE)\n    \n    ## Now args is a character vector containing the arguments.\n    ## Suppose the first argument should be interpreted as a number \n    ## and the second as a character string and the third as a boolean:\n    \n    numericArg <- as.numeric(args[1])\n    charArg <- args[2]\n    logicalArg <- as.logical(args[3])\n    \n    cat(\"First arg is: \", numericArg, \"; second is: \", charArg, \n        \"; third is: \", logicalArg, \".\\n\")\n    ```\n    :::\n\n\n\n    Now we can run it as follows in the shell:\n\n\n\n    ::: {.cell}\n    \n    ```{.bash .cell-code}\n    ./exampleRscript.R 53 blah T\n    ./exampleRscript.R blah 22.5 t\n    ```\n    \n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    First arg is:  53 ; second is:  blah ; third is:  TRUE .\n    Warning message:\n    NAs introduced by coercion \n    First arg is:  NA ; second is:  22.5 ; third is:  NA .\n    ```\n    :::\n    :::\n\n\n\n## Interacting with external code\n\nScripting languages such as R, Python, and Julia allow you to call out to \"external code\",\nwhich often means C or C++ (but also Fortran, Java and other languages). \n\nIn fact, the predecessor language to R,\nwhich was called 'S' was developed specifically (at AT&T's Bell Labs in the 1970s and 1980s) as an interactive\nwrapper around Fortran, the numerical programming language most commonly used at the time (and still widely relied on today in various legacy codes). \n\nCalling out to external code is particularly important in languages like R and Python that are often much slower\nthan compiled code and less important in a fast language like Julia (which uses Just-In-Time compilation -- more on that later).\n\nIn R, one can call directly out to C or C++ code using *.Call* or one can use the [Rcpp package](https://adv-r.hadley.nz/rcpp.html). *Rcpp* is specifically designed to be able to write C++ code that feels somewhat like writing R code and where it is very easy to pass data between R and C++. \n\nIn Python, one can [directly call out to C or C++ code](https://docs.python.org/3/extending/extending.html) or one can use *Cython* to interact with C. With Cython, one can:\n  - Have Cython automatically translate Python code to C, if you provide type definitions for your variables.\n  - Define C functions that can be called from your Python code.\n\n# 3. Packages and namespaces\n\nScripting languages that become popular generally have an extensive collection\nof add-on packages available online (the causal relationship of the popularity and\nthe extensive add-on packages goes in both directions). Packages need to\nbe *installed* (once) on your computer and *loaded* (every time you start a new session).\n\nA big part of R's popularity is indeed the extensive collection of add-on\npackages on [CRAN](https://cran.r-project.org) (and GitHub and elsewhere) that provide\nmuch of R's functionality. To make use of a package it needs to be\ninstalled on your system (using *install.packages* once only) and\nloaded into R (using *library* every time you start R).\n\nSome packages are *installed* by default with R and of these, some are\n*loaded* by default, while others require a call to *library*. \n\nIf you want to sound like an R expert, make sure to call them *packages*\nand not *libraries*. A *library* is the location in the directory\nstructure where the packages are installed/stored.\n\n## Loading packages\n\nYou can use *library* to either (1) make a package available (loading\nit), (2) get an overview of the package, or (3) (if called without\narguments) to see all the installed packages.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)              # load the package\nlibrary(help = dplyr)       # get some help info about the package\n```\n:::\n\n\n\nPackages often\ndepend on other packages. In general, if one package depends on another,\nR will load the dependency, but if the dependency is installed locally\n(see below), R may not find it automatically and you may have to use\n*library* to load the dependency first. In general, package dependencies\nare handled very cleanly in R without you having having to worry much about it;\nthis is less the case in Python.\n\nPackages in R (and in Python, Julia, etc.) may be installed in various places\non the filesystem, and it sometimes it is helpful (e.g., if you end up with multiple\nversions of a package installed on your system) to be able to figure out \nwhere on the filesystem the package is being loaded from. \nIf you run `library()`, you'll notice that some of the packages are in a\nsystem directory and some are in your home directory. \n\n`.libPaths()` shows where R\nlooks for packages on your system and `searchpaths()` shows where\nindividual packages currently loaded in your session have been loaded from. The help information \nfor *.libPaths* gives some information about how R decides what locations\nto look in for packages.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.libPaths()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"/accounts/vis/paciorek/R/x86_64-pc-linux-gnu-library/4.2\"\n[2] \"/system/linux/lib/R-20.04/4.2.0/x86_64/site-library\"     \n[3] \"/usr/lib/R/site-library\"                                 \n[4] \"/usr/lib/R/library\"                                      \n```\n:::\n\n```{.r .cell-code}\nsearchpaths()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \".GlobalEnv\"                                             \n [2] \"tools:quarto\"                                           \n [3] \"/usr/lib/R/library/stats\"                               \n [4] \"/usr/lib/R/library/graphics\"                            \n [5] \"/usr/lib/R/library/grDevices\"                           \n [6] \"/usr/lib/R/library/utils\"                               \n [7] \"/usr/lib/R/library/datasets\"                            \n [8] \"/system/linux/lib/R-20.04/4.2.0/x86_64/site-library/SCF\"\n [9] \"/usr/lib/R/library/methods\"                             \n[10] \"Autoloads\"                                              \n[11] \"/usr/lib/R/library/base\"                                \n```\n:::\n:::\n\n\n\n## Installing packages\n\nIf a package is on CRAN but not on your system, you can install it\neasily (usually). You don't need root permission on a machine to install\na package (though sometimes you run into hassles if you are installing\nit just as a user, so if you have administrative privileges it may help\nto use them). Of course in RStudio, you can install via the GUI. \n\nNote that R will generally install the package in a reasonable place by default\nbut you can control where it is installed using the *lib* argument.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages('dplyr', lib = '~/Rlibs') # ~/Rlibs needs to exist!\n```\n:::\n\n\n\nYou can also download the zipped source file from CRAN and install from\nthe file; see the help page for *install.packages*. This is called\n\"installing from source\". On Windows and Mac, you'll need to do\nsomething like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages('dplyr_VERSION.tar.gz', repos = NULL, type = 'source')\n```\n:::\n\n\n\nThis can be handy if you need to install [an older version of a package](https://cran.r-project.org/src/contrib/Archive)\nfor reproducibility or because of some dependency incompatibility.\n\nIf you've downloaded the binary package (files ending in .tgz for Mac\nand .zip for Windows) and want to install the package directly from the\nfile, use the syntax above but omit the `type= 'source'` argument.\n\n### Source vs. binary packages\n\nThe difference between a *source* package and a *binary* package is that\nthe source package has the raw R (and C and Fortran, in some cases) code\nas text files while the binary package has all the code in a\nbinary/non-text format, including that any C and Fortran code will have already been\ncompiled. To install a source package with C or Fortran code in it,\nyou'll need to have developer/command-line tools (e.g., *XCode* on Mac\nor *Rtools.exe* on Windows) installed on your system so that you have a\ncompiler.\n\n## Package namespaces\n\nThe objects in a package (primarily functions, but also data) are in\ntheir own workspaces, and are accessible after you load the package\nusing `library()`, but are not directly visible when you use `ls()`. In\nother words, each package has its own *namespace*. Namespaces help\nachieve modularity and avoid having zillions of objects all reside in\nyour workspace.  If we want to see the objects in a package's namespace, we\ncan do the following:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsearch()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \".GlobalEnv\"        \"tools:quarto\"      \"package:stats\"    \n [4] \"package:graphics\"  \"package:grDevices\" \"package:utils\"    \n [7] \"package:datasets\"  \"package:SCF\"       \"package:methods\"  \n[10] \"Autoloads\"         \"package:base\"     \n```\n:::\n\n```{.r .cell-code}\n## ls(pos = 4) # for the stats package\nls(pos = 4)[1:5] # just show the first few\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"abline\"    \"arrows\"    \"assocplot\" \"axis\"      \"Axis\"     \n```\n:::\n\n```{.r .cell-code}\nls(\"package:stats\")[1:5] # equivalent\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"acf\"        \"acf2AR\"     \"add.scope\"  \"add1\"       \"addmargins\"\n```\n:::\n\n```{.r .cell-code}\nls(\"package:stats\", pattern = \"^lm\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"lm\"           \"lm.fit\"       \"lm.influence\" \"lm.wfit\"     \n```\n:::\n:::\n\n\n\n### Why have namespaces?\n\nWe'll talk more about namespaces when we talk about scope and\nenvironments. But as some motivation for why this is useful, consider the following.\n\nThe *lm* function calls the *lm.fit* function to calculate the least squares solution in regression.\n\nSuppose we write our own *lm.fit* function that does something else:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm.fit <- function(x)\n    print('hi')\n\nx <- 7\nlm.fit(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"hi\"\n```\n:::\n:::\n\n\n\nOne might expect that if one now uses `lm()` to fit a regression, that it wouldn't work correctly because we have an *lm.fit* function in our workspace that doesn't calculate the least squares solution. But it works just fine (see below), because *lm* and *lm.fit* are in the *stats* package namespace (see above) and R's scoping rules (more later) ensure that the *lm.fit* that is found when I run *lm* is the *lm.fit* needed to run the regression and not my silly *lm.fit* function in current workspace.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 10\nx <- runif(n)\ny <- runif(n)\nmod <- lm(y ~ x)\nmod\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = y ~ x)\n\nCoefficients:\n(Intercept)            x  \n      0.519       -0.105  \n```\n:::\n:::\n\n\n\n### Namespace resolution\n\nStandard practice in R has generally been to load a package and then use any of the items in the package namespace directly, e.g.,\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringr)\nstr_detect(\"hello there\", \"hello\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n\nHowever, particularly if you're using the package in only a limited way, it can be a nice idea to not load the entire package and instead use the namespace resolution operator in a style that might remind you of Python and some other languages:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstringr::str_detect(\"hello there\", \"hello\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\nx = np.ndarray([0,3,5])\n```\n:::\n\n\n\nOf course in Python you could also load the entire package (i.e., import the entire namespace), though it's not standard practice:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom numpy import *\n## OR: from numpy import ndarray\nx = ndarray([0,3,5])\n```\n:::\n\n\n\nLoading entire packages often causes 'name collisions' where there are multiple functions (or variables, more genreally) that have the same name. This can be confusing. We'll see how R determines what function to use later in the Unit.\n\n# 4. Types and data structures\n\n## Data structures\n\nPlease see the [data structures section of Unit 2](unit2-dataTech.html#data-structures) for some general discussion of data structures.\n\nWe'll also see more complicated data structures when we consider objects in the next section on object-oriented programming.\n\n\n## Types and classes\n\n### Overview and static vs. dynamic typing\n\nThe term 'type' refers to how a given piece of information is stored and what operations can be done with the information.\n'Primitive' types are the most basic types that often relate directly to how data are stored in memory or on disk (e.g., boolean, integer, numeric (real-valued, aka *double* or *floating point*), character, pointer (aka *address*, *reference*).\n\nIn compiled languages like C and C++, one has to define the type of each variable. Such languages are *statically* typed.\nInterpreted (or scripting) languages such as Python and R have *dynamic* types. One can associate different types of information with a given variable name at different times and without declaring the type of the variable:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 'hello'\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"hello\"\n```\n:::\n\n```{.r .cell-code}\nx <- 7\nx*3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 21\n```\n:::\n:::\n\n\n\nIn contrast in a language like C, one has to declare a variable based on its type before using it:\n\n```\ndouble y;\ndouble x = 3.1;\ny = x * 7.1;\n```\n\nDynamic typing can be quite helpful from the perspective of quick implementation and avoiding tedious type definitions and problems from minor inconsistencies between types (e.g., multiplying an integer by a real-valued number).\nBut static typing has some critical advantages from the perspective of software development, including:\n  - protecting against errors from mismatched values and unexpected user inputs, and\n  - generally much faster execution because the type of a variable does not need to be checked when the code is run.\n\nMore complex types in R (and in Python) often use references (*pointers*, aka *addresses*) to the actual locations of the data. We'll see this in detail later in the Unit.\n\n### Types and classes in R\n\nYou should be familiar with vectors as the basic data structure in R,\nwith character, integer, numeric, etc. classes. Vectors are either\n*atomic vectors* or *lists*. Atomic vectors generally contain one of the\nfour following types: *logical*, *integer*, *double* (i.e., *numeric*), and\n*character*.\n\nEverything in R is an object and all objects have a class. For simple\nobjects class and type are often closely related, but this is not the\ncase for more complicated objects. As we'll see later in the Unit, the class describes what the object\ncontains and standard functions associated with it. In general, you\nmainly need to know what class an object is rather than its type.\n\n> **Note**\n> You can look at Table 7.1 in the Adler book to see some other types.\n\nLet's look at the type and class of various data structures in R.\nWe'll first see that real-valued are stored as double-precision (8 byte) floating point numbers\ninternally in R (as 'doubles' in C, as the R interpreter is a program written in C).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndevs <- rnorm(5)\nclass(devs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(devs)   \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\na <- data.frame(x = 1:2)\nclass(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.frame\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nis.data.frame(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.matrix(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis(a, \"matrix\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nm <- matrix(1:4, nrow = 2) \nclass(m) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"matrix\" \"array\" \n```\n:::\n\n```{.r .cell-code}\ntypeof(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n:::\n\n\n\nIn most cases integer-valued numbers are stored as numeric values in R, but there are exceptions such as the result of using the\nsequence operater, `:`, above. We can force R to store values\nas integers:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvals <- c(1, 2, 3)\nclass(vals)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nvals <- 1:3\nclass(vals)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\nvals <- c(1L, 2L, 3L)\nvals\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nclass(vals)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n:::\n\n\n\n\n### Attributes\n\nWe saw the notion of attributes when looking at HTML and XML, where the information was stored as\nkey-value pairs that in many cases had additional information in the form of attributes.\n\nIn R, *attributes* are information about an object attached to an object as\nsomething that looks like a named list. Attributes are often copied when\noperating on an object. This can lead to some weird-looking formatting when \nin subsequent operations the *names* attribute is carried along:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(10 * 365)\nattributes(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n\n```{.r .cell-code}\nqs <- quantile(x, c(.025, .975))\nattributes(qs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$names\n[1] \"2.5%\"  \"97.5%\"\n```\n:::\n\n```{.r .cell-code}\nqs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n 2.5% 97.5% \n-1.92  1.95 \n```\n:::\n\n```{.r .cell-code}\nqs[1] + 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2.5% \n1.08 \n```\n:::\n\n```{.r .cell-code}\nobject.size(qs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n352 bytes\n```\n:::\n:::\n\n\n\nWe can get rid of the attribute:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(qs) <- NULL\nqs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1.92  1.95\n```\n:::\n\n```{.r .cell-code}\nobject.size(qs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n64 bytes\n```\n:::\n:::\n\n\n\nA common use of attributes is that rows and columns may be named in\nmatrices and data frames, and elements in vectors:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(x = 1:2, y = 3:4)\nattributes(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$names\n[1] \"x\" \"y\"\n\n$class\n[1] \"data.frame\"\n\n$row.names\n[1] 1 2\n```\n:::\n\n```{.r .cell-code}\nrow.names(df) <- c(\"first\", \"second\")\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       x y\nfirst  1 3\nsecond 2 4\n```\n:::\n\n```{.r .cell-code}\nattributes(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$names\n[1] \"x\" \"y\"\n\n$class\n[1] \"data.frame\"\n\n$row.names\n[1] \"first\"  \"second\"\n```\n:::\n\n```{.r .cell-code}\nvec <- c(first = 7, second = 1, third = 5)\nvec['first']\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfirst \n    7 \n```\n:::\n\n```{.r .cell-code}\nattributes(vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$names\n[1] \"first\"  \"second\" \"third\" \n```\n:::\n:::\n\n\n\n### Converting between types\n\nThis also goes by the term *coercion* and *casting*. \nCasting often needs to be done explicitly in compiled languages and somewhat less so in interpreted languages like R.\n\nWe convert between classes using variants on *as*: e.g.,\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.character(c(1,2,3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\" \"2\" \"3\"\n```\n:::\n\n```{.r .cell-code}\nas.numeric(c(\"1\", \"2.73\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.00 2.73\n```\n:::\n\n```{.r .cell-code}\nas.factor(c(\"a\", \"b\", \"c\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] a b c\nLevels: a b c\n```\n:::\n:::\n\n\n\nSome common conversions are converting numbers that are being\ninterpreted as characters into actual numbers, converting between\nfactors and characters, and converting between logical TRUE/FALSE\nvectors and numeric 1/0 vectors. \n\nIn some cases R will automatically do\nconversions behind the scenes in a smart way (or occasionally not so\nsmart way). Consider these examples of implicit coercion:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(5)\nx[3] <- 'hat' # What do you think is going to happen?\nindices <- c(1, 2.73)\nmyVec <- 1:10\nmyVec[indices]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2\n```\n:::\n:::\n\n\n\nBe careful of using factors as indices:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudents <- factor(c(\"basic\", \"proficient\", \"advanced\",\n                     \"basic\", \"advanced\", \"minimal\"))\nscore <- c(minimal = 65, basic = 75, proficient = 85, advanced = 95)\nscore[\"advanced\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nadvanced \n      95 \n```\n:::\n\n```{.r .cell-code}\nstudents[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] advanced\nLevels: advanced basic minimal proficient\n```\n:::\n\n```{.r .cell-code}\nscore[students[3]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nminimal \n     65 \n```\n:::\n\n```{.r .cell-code}\nscore[as.character(students[3])]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nadvanced \n      95 \n```\n:::\n:::\n\n\n\nWhat has gone wrong and how does it relate to type coercion?\n\nHere's an example we can work through that will help illustrate how type\nconversions occur behind the scenes in R.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 5\ndf <- data.frame(label = rep('a', n), val1 = rnorm(n), val2 = rnorm(n))\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  label   val1   val2\n1     a  1.568 -0.563\n2     a -1.000 -0.297\n3     a -0.581  0.545\n4     a -0.299  0.656\n5     a -0.527  0.600\n```\n:::\n\n```{.r .cell-code}\n## Why does the following not work?\ntry( apply(df, 1, function(x) x[2] + x[3]) )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nError in x[2] + x[3] : non-numeric argument to binary operator\n```\n:::\n\n```{.r .cell-code}\n## Instead, this will work. Why?\napply(df[ , 2:3], 1, function(x) x[1] + x[2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1.0048 -1.2969 -0.0360  0.3570  0.0724\n```\n:::\n:::\n\n\n\n\n## Data frames and related concepts\n\n### Some notes on data frames and operations on data frames\n\nBase R provides a variety of functions for manipulating data frames, but\nnow many researchers use add-on packages (many written by Hadley Wickham\nas part of a group of packages called the *tidyverse*) to do these\nmanipulations in a more elegant way. [Module 6 of the R bootcamp](https://https://berkeley-scf.github.io/r-bootcamp-fall-2022/modules/module6_tidyverse) describes some of these new tools in more details, but I'll touch on some aspects of this here, without showing much of the tidyverse syntax.\n\n### split-apply-combine\n\nOften analyses are done in a stratified fashion - the same operation or\nanalysis is done on subsets of the data set. The subsets might be\ndifferent time points, different locations, different hospitals,\ndifferent people, etc.\n\nThe split-apply-combine framework is intended to operate in this kind of\ncontext: first one splits the dataset by one or more variables, then one\ndoes something to each subset, and then one combines the results. The\n*dplyr* package implements this framework (as does the *pandas* package\nfor Python). One can also do similar operations using various flavors of\nthe *lapply* family of functions such as *by*, *tapply*, and\n*aggregate*, but the dplyr-based tools are often nicer to use.\n\nsplit-apply-combine is also closely related to the famous Map-Reduce framework\nunderlying big data tools such as Hadoop and Spark. \n\nIt's also very similar to standard SQL queries involving filtering, grouping, and\naggregation.\n\n### Long and wide formats\n\nFinally, we may want to convert between so-called 'long' and 'wide'\nformats, which we can motivate in the context of longitudinal data\n(multiple observations per subject) and panel data (temporal data for\neach of multiple units such as in econometrics). The wide format has\nrepeated measurements for a subject in separate columns, while the long\nformat has repeated measurements in separate rows, with a column for\ndifferentiating the repeated measurements. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlong <- data.frame(id = c(1, 1, 1, 2, 2, 2),\n                   time = c(1980, 1990, 2000, 1980, 1990, 2000),\n                   value = c(5, 8, 9, 7, 4, 7))\nwide <- data.frame(id = c(1, 2),\n                   value_1980 = c(5, 7), value_1990 = c(8, 4), value_2000 = c(9, 7))\nlong\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  id time value\n1  1 1980     5\n2  1 1990     8\n3  1 2000     9\n4  2 1980     7\n5  2 1990     4\n6  2 2000     7\n```\n:::\n\n```{.r .cell-code}\nwide\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  id value_1980 value_1990 value_2000\n1  1          5          8          9\n2  2          7          4          7\n```\n:::\n:::\n\n\n\nThe wide format can be useful in some situations for treating each row as a (multivariate observation), \nbut the long formatwhile the long format is often what is needed for analyses such as \nmixed models. ANOVA, or for plotting, such as with *ggplot2*.\n\nThere are a variety of functions for converting between wide and long\nformats. I recommend *pivot_longer* and *pivot_wider* in the *tidyr* package. There are also older *tidyr* functions\ncalled *gather* and *spread*. There are also the *melt* and\n*cast* in the *reshape2* package. These are easier to use than the\nfunctions in base R such as *reshape* or *stack* and *unstack*\nfunctions*.*\n\n### Piping\n\nPiping was introduced into R in conjuction with *dplyr* and the *tidyverse*.\n\nThe tidyverse pipe is `%>%` while the new base R pipe is `|>`.\nThese are based on the UNIX pipe, which we saw in Unit 3, though\nthey behave somewhat differently in that the output of the previous function\nis passed in as the *first* argument of the next function. In the shell,\nthe pipe connects *stdout* from the previous command to *stdin* for the next command.\n\n\n### Non-standard evaluation and the tidyverse\n\nMany tidyverse packages use non-standard evaluation to make it easier to\ncode. For example in the following dplyr example, you can refer directly\nto *country* and *unemp*, which are variables in the data frame, without\nusing `data$country` or `data$unemp` and without using quotes around the\nvariable names, as in `\"country\"` or `\"unemp\"`. Referring directly to\nthe variables in the data frame is not standard R usage, hence the term\n\"non-standard evaluation\". One reason it is not standard is that *country*\nand *unemp* are not themselves independent R variables so R can't find\nthem in the usual way using scoping (discussed later in the Unit).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\ncpds <- read.csv(file.path('..', 'data', 'cpds.csv'))\n\ncpds2 <- cpds %>% group_by(country) %>%\n                  mutate(mean_unemp = mean(unemp))\n\nhead(cpds2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 7\n# Groups:   country [1]\n   year country   vturn outlays realgdpgr unemp mean_unemp\n  <int> <chr>     <dbl>   <dbl>     <dbl> <dbl>      <dbl>\n1  1960 Australia  95.5    NA       NA     1.42       5.52\n2  1961 Australia  95.3    NA       -0.07  2.79       5.52\n3  1962 Australia  95.3    23.2      5.71  2.63       5.52\n4  1963 Australia  95.7    23.0      6.1   2.12       5.52\n5  1964 Australia  95.7    22.9      6.28  1.15       5.52\n6  1965 Australia  95.7    24.9      4.97  1.15       5.52\n```\n:::\n:::\n\n\n\n\nThis 'magic' is done by capturing the code expression you write and\nevaluating it in a special way in the context of the data frame. I\nbelieve this uses R's environment class (discussed later in the Unit), but\nhaven't looked more deeply.\n\nWhile this has benefits, this so-called non-standard evaluation makes it\nharder to program functions in the usual way, as illustrated in the\nfollowing code chunk, where neither attempt to use the function works.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_mean <- function(data, group_var, summarize_var) {\n    data %>% group_by(group_var) %>%\n             mutate(mean_of_var = mean(summarize_var))\n}\n\ntry(cpds2 <- add_mean(cpds, country, unemp))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nError in group_by(., group_var) : \n  Must group by variables found in `.data`.\n✖ Column `group_var` is not found.\n```\n:::\n\n```{.r .cell-code}\ntry(cpds2 <- add_mean(cpds, 'country', 'unemp'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nError in group_by(., group_var) : \n  Must group by variables found in `.data`.\n✖ Column `group_var` is not found.\n```\n:::\n:::\n\n\n\n\nFor more details on how to avoid this problem when writing functions\nthat involve tidyverse manipulations, see\n[this tidyverse programming guide](https://dplyr.tidyverse.org/articles/programming.html).\n\nNote that the tidyverse is not the only place where non-standard\nevaluation is used. Consider this *lm* call:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm(y ~ x, weights = w, data = mydf)\n```\n:::\n\n\n\n> **Challenge**\n> Where is the non-standard evaluation there?\n\n# 5. Programming paradigms: object-oriented and functional programming\n\nObject-oriented and functional programming are two important approaches to programming.\n\nFunctional programming focuses on writing functions that take inputs and produce outputs. Ideally those functions don't change the state (i.e., the values) of any variables and can be treated as black boxes. Functions can be treated like other variables, such as passing functions as arguments (as one does with *lapply* in R, for example).\n\nObject-oriented programming revolves around objects that belong to classes. The class of an object defines the fields (the data objects) holding information and (often) methods that can be applied to those fields. When one calls a method, it may modify the value of the fields. A statistical analogy is that an object of a class is like the realization (the object) of a random variable (the class).\n\nOne can think of functional programming as being focused on actions (or *verbs* to make an analogy with human language). One carries out a computation as a sequence of function calls. One can think of OOP as being focused on the objects (or *nouns*). One carries out a computation as a sequence of operations with the objects, using the class methods.\n\nMany languages are multi-paradigm, containing aspects of both approaches and allowing programmers to use either approach. Both R and Python are like this, though some might consider R to be more functional and Python to be more object-oriented. That said, in R everything is an object and has a class, while there are plenty of function-based operations in Python.\n\n```python\nimport numpy as np\nx = np.array([1.2, 3.5, 4.2])\nx.shape  # field (or attribute) of the numpy array class\nx.sum()  # method of the class\nlen(x)   # function\n```\n\nDifferent people have different preferences, but which is better depends on what you are trying to do. If your computation is a data analysis pipeline that involves a series of transformations of some data, a functional approach might make more sense, since the focus is on a series of actions rather than the state of objects. If your computation involves various operations on fixed objects whose state needs to change, OOP might make more sense. For example, if you were writing code to keep track of student information, it would probably make sense to have each student as an object of a Student class with methods such as 'register' and 'assign_grade'. \n\n\n# 6. Object-oriented programming (OOP)\n\n## Principles\n\nSome of the standard concepts in object-oriented programming include *encapsulation*, *inheritance*, *polymorphism*, and *abstraction*.\n\n*Encapsulation* involves preventing direct access to internal data in an object from outside the object. Instead the class is designed so that access (reading or writing) happens through the interface set up by the programmer (e.g., 'getter' and 'setter' methods). We'll see this in our R6 class example below.\n\n*Inheritance* allows one class to be based on another class, adding more specialized features. For example (as in our S3 example), a *glm* class inheriting from an *lm* class. \n\n*Polymorphism* allows for different behavior of an object or function depending on the context. A polymorphic function behaves differently depending on the input types. A polymorphic object is one that can belong to different classes (e.g., based on inheritance), and a given method name can be used with any of the classes. An example would be having a base or super class called 'algorithm' and various specific machine learning algorithms inheriting from that class. All of the classes might have a 'predict' method.\n\n*Abstraction* involves hiding the details of how something is done (e.g., via the method of a class), giving the user an interface to provide inputs and get outputs. By making the actual computation a black box, the programmer can modify the internals without changing how a user uses the system. \n\nClasses generally have *constructors* that initialize objects of the class and *destructors* that remove objects.\n\n\n## Generic function OOP\n\nMuch of the object-oriented programming in R uses *generic function OOP*, also known as *functional OOP*. \nIn this style, classes don't have methods. Instead there are *generic functions* (also known as *generic methods*) that change their behavior based on the type of the input(s). Another way to put it is that the nouns and the verbs are separate, unliked in standard OOP.\n\nGeneric function OOP  is how the (very) old S3 system in R works. It's also a key part of the (fairly) new Julia language.\n\n### S3 classes in R\n\nS3 classes are widely-used, in particular for statistical models in the\n*stats* package. S3 classes are very informal in that there's not a\nformal definition for an S3 class. Instead, an S3 object is just a\nprimitive R object such as a list or vector with additional attributes\nincluding a class name.\n\n#### Creating our own class\n\nWe can create an object with a new class as follows:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyog <- list(firstname = 'Yogi', surname = 'the Bear', age = 20)\nclass(yog) <- 'bear' \n```\n:::\n\n\n\nActually, if we want to create a new class that we'll use again, we want\nto create a *constructor* function that initializes new bears:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbear <- function(firstname = NA, surname = NA, age = NA){\n\t# constructor for 'indiv' class\n\tobj <- list(firstname = firstname, surname = surname,\n                    age = age)\n\tclass(obj) <- 'bear' \n\treturn(obj)\n}\nsmoke <- bear('Smokey','Bear')\n```\n:::\n\n\n\nFor those of you used to more formal OOP, the following is probably\ndisconcerting:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(smoke) <- \"celebrity\"\n```\n:::\n\n\n\n#### Generic methods\n\nThe real power of the S3 system comes from defining *class-specific methods*. For example,\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(10)\nsummary(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n -1.735  -0.502  -0.309  -0.388  -0.046   0.316 \n```\n:::\n\n```{.r .cell-code}\ny <- rnorm(10)\nmod <- lm(y ~ x)\nsummary(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = y ~ x)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-2.134 -0.381  0.179  0.538  1.687 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)\n(Intercept)  -0.0532     0.4243   -0.13     0.90\nx             0.4774     0.6058    0.79     0.45\n\nResidual standard error: 1.12 on 8 degrees of freedom\nMultiple R-squared:  0.072,\tAdjusted R-squared:  -0.044 \nF-statistic: 0.621 on 1 and 8 DF,  p-value: 0.453\n```\n:::\n:::\n\n\n\nHere *summary* is a generic function (or generic method) that, based\non the type of object given to it (the first argument), dispatches a\nclass-specific function (method) that operates on the object. \n\nThe above is equivalent to directly calling the class-specific methods:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nidentical(summary(x), summary.default(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nidentical(summary(mod), summary.lm(mod))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n\n\nThis use of generic functions is convenient in that it allows us to work with a variety of kinds of objects using familiar functions. Consider\nthe generic methods *plot*, *print*, *summary*, *\\[*, and\nothers. We can look at a function and easily see that it is a generic\nmethod. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (object, ...) \nUseMethod(\"summary\")\n<bytecode: 0x5600c181c038>\n<environment: namespace:base>\n```\n:::\n:::\n\n\n\nThe `UseMethod` syntax is what causes the dispatching of the class-specific method\nassociated with `object` and calls that method.\nIn many cases there will be a default method (here,\n*summary.default*), so if no method is defined for the class, R uses\nthe default. Sidenote: arguments to a generic method are passed along to\nthe selected method by passing along the calling environment.\n\nWe can also see what classes have methods for a given generic\nfunction.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmethods(summary)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] summary,ANY-method                   summary,DBIObject-method            \n [3] summary,diagonalMatrix-method        summary,sparseMatrix-method         \n [5] summary.aov                          summary.aovlist*                    \n [7] summary.aspell*                      summary.check_packages_in_dir*      \n [9] summary.connection                   summary.data.frame                  \n[11] summary.Date                         summary.default                     \n[13] summary.ecdf*                        summary.factor                      \n[15] summary.glm                          summary.infl*                       \n[17] summary.lm                           summary.loess*                      \n[19] summary.manova                       summary.matrix                      \n[21] summary.mlm*                         summary.nls*                        \n[23] summary.packageStatus*               summary.pandas.core.frame.DataFrame*\n[25] summary.pandas.core.series.Series*   summary.POSIXct                     \n[27] summary.POSIXlt                      summary.ppr*                        \n[29] summary.prcomp*                      summary.princomp*                   \n[31] summary.proc_time                    summary.python.builtin.object*      \n[33] summary.rlang_error*                 summary.rlang_message*              \n[35] summary.rlang_trace*                 summary.rlang_warning*              \n[37] summary.rlang:::list_of_conditions*  summary.shingle*                    \n[39] summary.srcfile                      summary.srcref                      \n[41] summary.stepfun                      summary.stl*                        \n[43] summary.table                        summary.trellis*                    \n[45] summary.tukeysmooth*                 summary.vctrs_sclr*                 \n[47] summary.vctrs_vctr*                  summary.warnings                    \nsee '?methods' for accessing help and source code\n```\n:::\n:::\n\n\n\n\nWe can define a new generic function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarize <- function(object, ...) \n\tUseMethod(\"summarize\") \n```\n:::\n\n\n\nLet's try this out on our *bear*\nclass. In reality, we'd write either *summary.bear* or *print.bear*\n(and of course the generics for *summary* and *print* already exist) but\nfor illustration, I wanted to show how we would write both the generic\nand the specific method, so I'll write a *summarize* method instead of a *summary* method.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarize.bear <- function(object) \n\treturn(with(object, cat(\"Bear of age \", age, \n\t\" whose name is \", firstname, \" \", surname, \".\\n\",\n    sep = \"\")))\nsummarize(yog)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBear of age 20 whose name is Yogi the Bear.\n```\n:::\n:::\n\n\n\n#### Why use generic functions?\n\nWe could have written *summary* as a regular function with a bunch of if statements or if-else clauses (or *switch*) so that it can handle different kinds of input objects. \n\nThis has two disadvantages:\n\n  1. We need to write the code that does the checking (and all the code for the different cases all lives inside one potentially very long function, unless we create class-specific helper functions).\n  2. Much more importantly, *summary* will only work for existing classes. And users can't easily extend it for new classes that they create because they don't control the *summary* function. So a user could not add the additional conditions/classes in a big if-else statement. The generic function approach makes the system *extensible* -- we can build our own new functionality on what is already in R.\n\n#### The print method\n\nLike *summary*, *print* is a generic method, with various\nclass-specific methods, such as *print.lm*.\n\nNote that the *print* function is what is called when you simply type\nthe name of the object, so we can have object information printed out in\na structured way. Recall that the output when we type the name of an\n*lm* object is NOT simply a regurgitation of the elements of the list -\nrather *print.lm* is called.\n\nSimilarly, when we used `print(object.size(x))` we are invoking the\n*object_size*-specific print method which gets the value of the size and\nthen formats it. So there's actually a fair amount going on behind the\nscenes.\n\nSurprisingly, the *summary* method generally doesn't actually print\nout information; rather it computes things not stored in the original\nobject and returns it as a new class (e.g., class *summary.lm*), which\nis then automatically printed, per my comment above (e.g., using\n*print.summary.lm*), unless one assigns it to a new object. Note that\n*print.summary.lm* is hidden from user view (it's a private object in the *stats* namespace).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout <- summary(mod)\nclass(out)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"summary.lm\"\n```\n:::\n\n```{.r .cell-code}\nout\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = y ~ x)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-2.134 -0.381  0.179  0.538  1.687 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)\n(Intercept)  -0.0532     0.4243   -0.13     0.90\nx             0.4774     0.6058    0.79     0.45\n\nResidual standard error: 1.12 on 8 degrees of freedom\nMultiple R-squared:  0.072,\tAdjusted R-squared:  -0.044 \nF-statistic: 0.621 on 1 and 8 DF,  p-value: 0.453\n```\n:::\n\n```{.r .cell-code}\nprint(out)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = y ~ x)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-2.134 -0.381  0.179  0.538  1.687 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)\n(Intercept)  -0.0532     0.4243   -0.13     0.90\nx             0.4774     0.6058    0.79     0.45\n\nResidual standard error: 1.12 on 8 degrees of freedom\nMultiple R-squared:  0.072,\tAdjusted R-squared:  -0.044 \nF-statistic: 0.621 on 1 and 8 DF,  p-value: 0.453\n```\n:::\n\n```{.r .cell-code}\n## One can look at the code for the method (not shown):\n## getS3method(f = \"print\", class = \"summary.lm\")\n```\n:::\n\n\n\n#### Inheritance\n\nLet's look at the *lm* class, which builds on lists, and *glm* class,\nwhich builds on the *lm* class. Here *mod* is an object (an instance) of\nclass *lm*. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(methods)\nybin <- sample(c(0, 1), 10, replace = TRUE)\nycont <- rnorm(10)\nx <- rnorm(10)\nmod1 <- lm(ycont ~ x)\nmod2 <- glm(ybin ~ x, family = binomial)\nclass(mod1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"lm\"\n```\n:::\n\n```{.r .cell-code}\nclass(mod2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"glm\" \"lm\" \n```\n:::\n\n```{.r .cell-code}\nis.list(mod1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nnames(mod1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"coefficients\"  \"residuals\"     \"effects\"       \"rank\"         \n [5] \"fitted.values\" \"assign\"        \"qr\"            \"df.residual\"  \n [9] \"xlevels\"       \"call\"          \"terms\"         \"model\"        \n```\n:::\n\n```{.r .cell-code}\nis(mod2, \"lm\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nmethods(class = \"lm\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] add1           alias          anova          case.names     coerce        \n [6] confint        cooks.distance deviance       dfbeta         dfbetas       \n[11] drop1          dummy.coef     effects        extractAIC     family        \n[16] formula        hatvalues      influence      initialize     kappa         \n[21] labels         logLik         model.frame    model.matrix   nobs          \n[26] plot           predict        print          proj           qr            \n[31] residuals      rstandard      rstudent       show           simulate      \n[36] slotsFromS3    summary        variable.names vcov          \nsee '?methods' for accessing help and source code\n```\n:::\n:::\n\n\n\nOften S3 classes inherit from lists (i.e., are special cases of lists),\nso you can obtain components of the object using the \\$ operator.\n\nAs noted with *lm* and *glm* objects, we can assign more than one class\nto an object. Here *summarize* still works, even though the primary\nclass is *grizzly_bear*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(yog) <- c('grizzly_bear', 'bear')\nsummarize(yog) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBear of age 20 whose name is Yogi the Bear.\n```\n:::\n:::\n\n\n\nThe classes should nest within one another with the more specific\nclasses to the left, e.g., here a *grizzly_bear* would have some\nadditional fields on top of those of a *bear*, perhaps\n*number_of_people_killed* (since grizzly bears are much more dangerous\nthan some other kinds of bears), and perhaps additional or modified\nmethods. *grizzly_bear* inherits from *bear*, and R uses methods for the\nfirst class before methods for the next class(es).\n\nThe above is an example of polymorphism. `yog` is a polymorphic object \nand the various methods are polymorphic in that *print* can be used\nwith the *bear* class, the *grizzly_bear* class, and other classes beyond that.\n\n\n> **Challenge**\n> How would you get R to quit immediately, without asking for any more information, when you simply type `k` (no parentheses!) instead of `quit()`? (Hint: you can do this by understanding what happens when you type `k` and how to exploit the S3 system.)\n\n\n### Multiple dispatch OOP \n\nS3 method dispatch involves only the first argument to the function. In contrast, [Julia emphasizes the importance of multiple dispatch](https://docs.julialang.org/en/v1/manual/methods) as particularly important for mathematical computation. With multiple dispatch, the specific method can be chosen based on more than one argument.\n\nThe old (but still used in some contexts) [S4](http://adv-r.had.co.nz/S4.html) system in R and the (very) new [R7](https://rconsortium.github.io/OOP-WG) system both provide for multiple dispatch. \n\nAs a very simple example unrelated to any specific language, multiple dispatch would allow one to do the following with the addition operator:\n\n```\n3 + 7    # 10\n3 + 'a'  # '3a'\n'hi' +  ' there'  # 'hi there'\n```\n\nThe idea of having the behavior of an operator or function adapt to the type of the input(s) is one aspect of *polymorphism*.\n\nBoth S4 and R7 are designed to be more formal than the S3 system (recall how we could just 'create' an S3 class by giving a class name to an existing list). With S4 and R7, you need to define your classes. \n\n## 'Standard' OOP\n\nWhat I'm calling 'standard' object-oriented programming is the style of OOP used in languages such as Python, C++, and Java. In R, one can use this style via the R6 system (or the older *referenceClass* system).\n\nIn this style, objects belong to classes. A class is made up of fields (the data objects) that store information and methods that operate on the fields. Thus, unlike generic function OOP, the verbs are part of the nouns.\n\nWe'll illustrate this style of OOP using an example with an R6 class.\n\n### R6 classes\n\nR6 classes are a somewhat new construct in R, with a class-based approach fairly similar to Python and C++. Importantly, they behave like pointers. We'll discuss pointers in detail later. Let's work through an example\nwhere we set up the fields of the class and class\nmethods, including a constructor.\n\n#### Example\n\nOur example is to create a class for working with random time series. Each object of the class has specific parameter values that control the stochastic behavior of the time series. With a given object we can simulate one or more time series (realizations).\n\nHere's the initial definition of the class, with both public\n(user-facing) and private (internal use only) methods and fields.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(R6)\n\ntsSimClass <- R6Class(\"tsSimClass\",\n    ## class for holding time series simulators\n    public = list(\n        initialize = function(times, mean = 0, corParam = 1) {\n            library(fields)\n            stopifnot(is.numeric(corParam), length(corParam) == 1)\n            stopifnot(is.numeric(times))\n            private$times <- times\n            private$n <- length(times)\n            private$mean <- mean\n            private$corParam <- corParam\n            private$currentU <- FALSE\n            private$calcMats()\n        },\n        \n        changeTimes = function(newTimes) {\n            private$times <- newTimes\n            private$calcMats()\n        },\n        \n        getTimes = function() {\n            return(private$times)\n        },\n\n        print = function() { # 'print' method\n            cat(\"R6 Object of class 'tsSimClass' with \",\n                private$n, \" time points.\\n\", sep = '')\n            invisible(self)\n        },\n\n        simulate = function() {\n            if(!private$currentU)     \n                private$calcMats()\n            ## analogous to mu+sigma*z for generating N(mu, sigma^2)\n            return(private$mean + crossprod(private$U, rnorm(private$n)))\n        }\n    ),\n\n    ## private methods and functions not accessible externally\n    private = list(\n        calcMats = function() {\n            ## calculates correlation matrix and Cholesky factor\n            lagMat <- fields::rdist(private$times) # local variable\n            corMat <- exp(-lagMat^2 / private$corParam^2)\n            private$U <- chol(corMat) # square root matrix\n            cat(\"Done updating correlation matrix and Cholesky factor.\\n\")\n            private$currentU <- TRUE\n            invisible(self)\n        },\n        n = NULL, \n        times = NULL,\n        mean = NULL,\n        corParam = NULL,\n        U = NULL,\n        currentU = FALSE\n    )\n)   \n```\n:::\n\n\n\n\nNow let's see how we would use the class.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyts <- tsSimClass$new(1:100, 2, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDone updating correlation matrix and Cholesky factor.\n```\n:::\n\n```{.r .cell-code}\nmyts\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR6 Object of class 'tsSimClass' with 100 time points.\n```\n:::\n\n```{.r .cell-code}\nset.seed(1)\n## here's a simulated time series\ny1 <- myts$simulate()\nplot(myts$getTimes(), y1, type = 'l', xlab = 'time',\n     ylab = 'process values')\n## simulate a second series\ny2 <- myts$simulate()\nlines(myts$getTimes(), y2, lty = 2)\n```\n\n::: {.cell-output-display}\n![](unit5-programming_files/figure-html/unnamed-chunk-54-1.png){width=672}\n:::\n:::\n\n\n\nWe could set up a different object that has different parameter values.\nThat new simulated time series is less wiggly because the `corParam` value\n is larger than before.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyts2 <- tsSimClass$new(1:100, 2, 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDone updating correlation matrix and Cholesky factor.\n```\n:::\n\n```{.r .cell-code}\nset.seed(1)\n## here's a simulated time series with a different value of\n## the correlation parameter (corParam)\ny3 <- myts2$simulate()\n\nplot(myts$getTimes(), y1, type = 'l', xlab = 'time',\n     ylab = 'process values')\nlines(myts$getTimes(), y2, lty = 2)\nlines(myts2$getTimes(), y3, col = 'red')\n```\n\n::: {.cell-output-display}\n![](unit5-programming_files/figure-html/unnamed-chunk-55-1.png){width=672}\n:::\n:::\n\n\n\n#### Copies and references\n\nNext let's think about when copies are made. In the next example `mytsRef` is a copy of `myts`\nin the sense that both names point to the same underlying object.\nBut no data were copied when the assignment to `mytsRef` was done. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmytsRef <- myts\n## 'mytsRef' and 'myts' are names for the same underlying object\nmytsFullCopy <- myts$clone()  \n\n## Now let's change the values of a field\nmyts$changeTimes(seq(0,1000, length = 100))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDone updating correlation matrix and Cholesky factor.\n```\n:::\n\n```{.r .cell-code}\nmyts$getTimes()[1:5] \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  0.0 10.1 20.2 30.3 40.4\n```\n:::\n\n```{.r .cell-code}\nmytsRef$getTimes()[1:5] # the same as `myts`\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  0.0 10.1 20.2 30.3 40.4\n```\n:::\n\n```{.r .cell-code}\nmytsFullCopy$getTimes()[1:5] # different from `myts`\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n\n\nIn contrast `mytsFullCopy` is a reference to a different object, and\nall the data from `myts` had to be copied over to `mytsFullCopy`. This takes additional memory (and time), but is also safer, as it avoids the possibility that the user might modify `myts` and not realize that they were also affecting `mytsRef`.\n\n#### Encapsulation\n\nWhy have private fields (i.e., encapsulation)? The use of private fields shields them from\n    modification by users. In this case, that prevent users from modifying the\n*times* field. Why is this important? In this example, the correlation matrix and\n    the Cholesky factor U are both functions of the vector of times. So\n    we don't want to allow a user to directly modify *times*. If they did, it would leave the fields of the object in inconsistent states. Instead we\n    force them to use *setTimes*, which correctly keeps all the fields\n    in the object internally consistent (by calling *calcMats*). It also allows us to improve efficiency\nby controlling when computationally expensive operations are carried out.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntry(myts$times <- 1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nError in myts$times <- 1:10 : cannot add bindings to a locked environment\n```\n:::\n:::\n\n\n\n#### Final comments\n\n  -   As we saw above, a copy of an object is just a pointer to the original object, unless we explicitly invoke the *clone* method.\n  -   Classes can inherit from other classes. E.g., if we had a *simClass* and we wanted the *tsSimClass* to inherit from it:\n\n      ```\n      R6Class(tsSimClass, inherit = simClass, ...) \n      ```\n  -   If you need to refer to methods and fields you refer to the entire object as either *self* or *private*.\n\n\nMore details on R6 classes can be found in the [Advanced R book](https://adv-r.hadley.nz/r6.html).\n\n\n",
    "supporting": [
      "unit5-programming_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}