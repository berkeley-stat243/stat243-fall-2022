{
  "hash": "0f81e30ad4898072c3143b61f6802340",
  "result": {
    "markdown": "---\ntitle: \"Programming concepts\"\nauthor: \"Chris Paciorek\"\ndate: \"2022-09-06\"\nformat:\n  pdf:\n    documentclass: article\n    margin-left: 30mm\n    margin-right: 30mm\n    toc: true\n  html:\n    theme: cosmo\n    css: ../styles.css\n    toc: true\n    code-copy: true\n    code-block-background: true\nexecute:\n  freeze: auto\n---\n\n\n\n[PDF](./unit5-programming.pdf){.btn .btn-primary}\n\n\n> **Note**\n> This Unit will be posted in phases as I get the material ready.\n> 2022-09-21: Currently only Sections 1-8 are available.\n\n\nReferences:\n\n-   Books on R listed on the syllabus: Adler, Chambers, Wickham\n-   [R intro manual](http://cran.r-project.org/doc/manuals/R-intro.html)\n    and [R language\n    manual](http://cran.r-project.org/doc/manuals/R-lang.html) (R-lang),\n    both on CRAN.\n-   Murrell, Introduction to Data Technologies\n\n(Optional) Videos\n\nThere are various videos from 2020 in the bCourses Media Gallery that you\ncan use for reference if you want to. Note that I've reorganized the material in this Unit relative to 2020, so the section numbers and ordering in the videos may differ from that in the current Unit, but you should be able to match things up fairly easily.\n\n  - Video 1. Strings and regular expressions\n  - Video 3. Type/class coercion\n  - Video 4. Object-oriented programming - S3 classes\n  - Video 5. Object-oriented programming - R6 classes\n  - Video 6. Nested function calls and the call stack\n  - Video 7. Operators in R\n  - Video 8. Unexpected functions and replacement functions\n  - Video 13. Memory and copying\n\n# Overview\n\nThis unit covers a variety of programming concepts, illustrated in the\ncontext of R and with comments about and connections to other languages. It also serves as a way to teach some advanced features of\nR. In general the concepts are relevant in other languages, though other\nlanguages may implement things differently. One of my goals for the unit is for us\nto think about why things are the way they are in R. I.e., what\nprinciples were used in creating the language and what choices were\nmade? While other languages use different principles and made different \nchoices, understanding what one language does in detail will be helpful when you\nare learning another language or choosing a language for a project.\n\nI'll likely refer to R syntax as *statements* or *expressions*, meaning\n any code that is a valid, complete R expression. But note that the term *expression* also means a specific type of object\nwithin the R language, as seen late in this Unit when we discuss computing on the language.\n\n# 1. Text manipulation, string processing and regular expressions (regex)\n\nText manipulations in R have a number of things in common with Python,\nPerl, and UNIX, as many of these evolved from UNIX. When I use the term\n*string* here, I'll be referring to any sequence of characters that may\ninclude numbers, white space, and special characters, rather than to the\ncharacter class of R objects. The string or strings will generally be\nstored as an R character vector.\n\n## String processing and regular expressions in R\n\nFor details of string processing in R, including use of regular expressions, see the [string\nprocessing tutorial](https://berkeley-scf.github.io/tutorial-string-processing).\n(You can ignore the sections on Python if you wish.) That tutorial then refers to\nthe [bash shell tutorial](https://berkeley-scf.github.io/tutorial-using-bash/regex) \nfor details on regular expressions.\n\nIn class we'll work through some problems in the string processing tutorial, focusing in\nparticular on the use of regular expressions with the *stringr* package.\nThis will augment our consideration of regular expressions in the shell, in particular\nby seeing how we can replace patterns in addition to finding them. \n\n## Regex/string processing challenges\n\nWe'll work on these challenges (and perhaps one or two others) in class in the process of working\nthrough the string processing tutorial.\n\n1.  What regex would I use to find any number with or without a decimal place.\n\n2.  Suppose a text string has dates in the form \"Aug-3\", \"May-9\", etc.\n    and I want them in the form \"3 Aug\", \"9 May\", etc. How would I do\n    this search and replace operation? (Alternatively, how could I do\n    this without using regular expressions at all?)\n\n## Side notes on special characters in R \n\nRecall that when characters are used for special purposes, we need to\n'escape' them if we want them interpreted as the actual character. In what\nfollows, I show this in R, but similar manipulations are sometimes\nneeded in the shell and in Python.\n\nThis can get particularly confusing in R as the backslash is also used\nto input special characters such as newline (`\\n`) or tab (`\\t`).\n\nHere are some examples of using special characters.\n\n> **Note**\n> It is hard to compile the Rmd file correctly for these R chunks, so I am just pasting in the output from running in R 'manually' in some cases.)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmp <- \"Harry said, \\\"Hi\\\"\"\n## cat(tmp)   # prints out without a newline -- this is hard to show in the pdf\ntmp <- \"Harry said, \\\"Hi\\\".\\n\"\ncat(tmp)      # prints out with the newline\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHarry said, \"Hi\".\n```\n:::\n\n```{.r .cell-code}\ntmp <- c(\"azar\", \"foo\", \"hello\\tthere\\n\")\ncat(tmp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nazar foo hello\tthere\n```\n:::\n\n```{.r .cell-code}\nprint(tmp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"azar\"           \"foo\"            \"hello\\tthere\\n\"\n```\n:::\n\n```{.r .cell-code}\ngrep(\"[\\tz]\", tmp)   ## search for a tab or a 'z'\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3\n```\n:::\n:::\n\n\n\nAs a result, in R we often need two backslashes when working with\nregular expressions. In the next examples, the first backslash says to\ninterpret the next backslash literally, with the second backslash being\nused to indicate that the caret (\\^) should be interpreted literally and\nnot as a special character in the regular expression syntax.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Search for characters that are not 'z'\n## (using ^ as regular expression syntax)\ngrep(\"[^z]\", c(\"a^2\", \"93\", \"zzz\", \"zit\", \"azar\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 4 5\n```\n:::\n\n```{.r .cell-code}\n## Search for either a '^' (as a regular charcter) or a 'z':\ngrep(\"[\\\\^z]\", c(\"a^2\", \"93\", \"zzz\", \"zit\", \"azar\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 4 5\n```\n:::\n\n```{.r .cell-code}\n## This fails (and the Rmd won't compile) because\n## '\\^' is not an escape sequence (i.e., a special character):\n## grep(\"[\\^z]\", c(\"a^2\", \"93\", \"zit\", \"azar\", \"zzz\"))\n## Error: '\\^' is an unrecognized escape in character string starting \"\"[\\^\"\n\n## Search for exactly three characters\n## (using . as regular expression syntax)\ngrep(\"^.{3}$\", c(\"abc\", \"1234\", \"def\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3\n```\n:::\n\n```{.r .cell-code}\n## Search for a period (as a regular character)\ngrep(\"\\\\.\", c(\"3.9\", \"27\", \"4.2\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3\n```\n:::\n\n```{.r .cell-code}\n## This fails (and the Rmd won't compile) because \n## '\\.' is not an escape sequence (i.e., a special character):\n## grep(\"\\.\", c(\"3.9\", \"27\")))\n## Error: '\\.' is an unrecognized escape in character string starting \"\"\\.\"\n```\n:::\n\n\n\n> **Challenge**\n> Explain why we use a single backslash to get a newline and double backslash to write out a Windows path in the examples here:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Suppose we want to use a \\ in our string:\ncat(\"hello\\nagain\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nhello\nagain\n```\n:::\n\n```{.r .cell-code}\ncat(\"hello\\\\nagain\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nhello\\nagain\n```\n:::\n\n```{.r .cell-code}\ncat(\"My Windows path is: C:\\\\Users\\\\My Documents.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMy Windows path is: C:\\Users\\My Documents.\n```\n:::\n:::\n\n\n\nFor more information, see `?Quotes` in R and the subsections of the\nstring processing tutorial that discuss backslashes and escaping.\n\nAdvanced note: Searching for an actual backslash gets even more\ncomplicated, because we need to pass two backslashes as the regular\nexpression, so that a literal backslash is searched for. However, to\npass two backslashes, we need to escape each of them with a backslash so\nR doesn't treat each backslash as part of a special character. So that's\nfour backslashes to search for a single backslash! Yikes. One rule of\nthumb is just to keep entering backslashes until things work!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Search for an actual backslash\ntmp <- \"something \\\\ other\\n\"\ncat(tmp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsomething \\ other\n```\n:::\n\n```{.r .cell-code}\ngrep(\"\\\\\\\\\", tmp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\ntry(grep(\"\\\\\", tmp))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in grep(\"\\\\\", tmp): TRE pattern compilation error 'Trailing backslash'\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nError in grep(\"\\\\\", tmp) : \n  invalid regular expression '\\', reason 'Trailing backslash'\n```\n:::\n:::\n\n\n\n> **Warning**\n> Be careful when cutting and pasting from documents that are not text\n> files as you may paste in something that looks like a single or double\n> quote, but which R cannot interpret as a quote because it's some other\n> ASCII quote character. If you paste in a \" from PDF, it will not be\n> interpreted as a standard R double quote mark.\n\nSimilar things come up in the shell and in Python, but in the shell you\noften don't need two backslashes. E.g. you could do this to look for a\nliteral \\^ character.\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngrep '\\^' file.txt\n```\n:::\n\n\n\n# 2. Interacting with the operating system and external code and configuring R \n\n## Interacting with the operating system\n\nScripting languages allow one to interact with the operating system in various ways.\nMost allow you to call out to the shell to run arbitrary shell code and save results within your session.\n\nI'll assume everyone knows about the following functions/functionality for interacting with the filesystem and file\nin R: *getwd*, *setwd*, *source*, *pdf*, *save*, *save.image*, *load*.\n\n-   To run UNIX commands from within R, use `system()`, as follows,\n    noting that we can save the result of a system call to an R object:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    system(\"ls -al\")   ## results apparently not shown when compiled...\n    files <- system(\"ls\", intern = TRUE)\n    files[1:5]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"0-bash-shell.sh\" \"badCode.R\"       \"cache\"           \"calc_mean.py\"   \n    [5] \"convert.sh\"     \n    ```\n    :::\n    :::\n\n\n\n-   There are also a bunch of functions that will do specific queries of\n    the filesystem, including\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    file.exists(\"unit2-dataTech.Rmd\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] TRUE\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    list.files(\"../data\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"airline.csv\"           \"coop.txt.gz\"           \"cpds.csv\"             \n    [4] \"hivSequ.csv\"           \"IPs.RData\"             \"precip.txt\"           \n    [7] \"precipData.txt\"        \"RTADataSub.csv\"        \"stackoverflow-2016.db\"\n    ```\n    :::\n    :::\n\n\n\n-   There are some tools for dealing with differences between operating\n    systems. *file.path* is a nice example:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    list.files(file.path(\"..\", \"data\"))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"airline.csv\"           \"coop.txt.gz\"           \"cpds.csv\"             \n    [4] \"hivSequ.csv\"           \"IPs.RData\"             \"precip.txt\"           \n    [7] \"precipData.txt\"        \"RTADataSub.csv\"        \"stackoverflow-2016.db\"\n    ```\n    :::\n    :::\n\n\n\n    It's best if you can to write your code in a way that is *agnostic* to the underlying operating system.\n\n-   To get some info on the system you're running on:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    Sys.info()\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n                                           sysname \n                                           \"Linux\" \n                                           release \n                               \"5.4.0-120-generic\" \n                                           version \n    \"#136-Ubuntu SMP Fri Jun 10 13:40:48 UTC 2022\" \n                                          nodename \n                                         \"smeagol\" \n                                           machine \n                                          \"x86_64\" \n                                             login \n                                        \"paciorek\" \n                                              user \n                                        \"paciorek\" \n                                    effective_user \n                                        \"paciorek\" \n    ```\n    :::\n    :::\n\n\n\n## Controlling the behavior of R\n\nScripting languages generally allow you to control/customize their behavior\nin various ways by setting options.\n\n-   To see some of the options that control how R behaves, try the\n    *options* function. The *width* option changes the number of\n    characters of width printed to the screen, while *max.print*\n    revents too much of a large object from being printed to the\n    screen. \n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ## options()  # this would print out a long list of options\n    options()[1:4]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    $add.smooth\n    [1] TRUE\n    \n    $bitmapType\n    [1] \"cairo\"\n    \n    $browser\n    [1] \"xdg-open\"\n    \n    $browserNLdisabled\n    [1] FALSE\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    options()[c('width', 'digits')]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    $width\n    [1] 80\n    \n    $digits\n    [1] 7\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    ## Often it's nice to have more characters in each line on the screen,\n    ## but that would cause overly lines in the compiled file.\n    ## options(width = 120)\n    \n    options(max.print = 5000)\n    ```\n    :::\n\n\n\n    The *digits* option changes the number of digits of numbers\n    printed to the screen (but be careful as this can be deceptive if\n    you then try to compare two numbers based on what you see on the\n    screen).\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    options(digits = 3)\n    a <- 0.123456; b <- 0.1234561\n    a; b; a == b\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 0.123\n    ```\n    :::\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 0.123\n    ```\n    :::\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] FALSE\n    ```\n    :::\n    :::\n\n\n\n    More on how to (and how not to) compare real-valued numbers on a computer in Unit 8.\n\n-   Use `Ctrl-C` to interrupt execution. This will generally back out\n    gracefully, returning you to a state as if the command had not been\n    started. Note that if R is exceeding the amount of memory available, there can\n    be a long delay. This can be frustrating, particularly since a\n    primary reason you would want to interrupt is when R runs out of\n    memory.\n\n-   *sessionInfo* gives information on the current R session and can\n    be very helpful for recording the state of your session (including package versions) to allow for reproducibility.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    sessionInfo()\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    R version 4.2.0 (2022-04-22)\n    Platform: x86_64-pc-linux-gnu (64-bit)\n    Running under: Ubuntu 20.04.3 LTS\n    \n    Matrix products: default\n    BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3\n    LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/liblapack.so.3\n    \n    locale:\n     [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n     [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n     [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n     [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n     [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n    [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n    \n    attached base packages:\n    [1] stats     graphics  grDevices utils     datasets  methods   base     \n    \n    other attached packages:\n    [1] SCF_4.1.0\n    \n    loaded via a namespace (and not attached):\n     [1] compiler_4.2.0  magrittr_2.0.3  fastmap_1.1.0   cli_3.3.0      \n     [5] tools_4.2.0     htmltools_0.5.3 yaml_2.3.5      stringi_1.7.8  \n     [9] rmarkdown_2.14  knitr_1.39      stringr_1.4.0   xfun_0.31      \n    [13] digest_0.6.29   jsonlite_1.8.0  rlang_1.0.5     evaluate_0.15  \n    ```\n    :::\n    :::\n\n\n\n-   Any code that you wanted executed automatically when starting R can\n    be placed in `~/.Rprofile` (or in individual, project-specific `.Rprofile` files in\n    specific directories). This could include loading packages (see\n    below), sourcing files that contain user-defined functions that you\n    commonly use (you can also put the function code itself in\n    `.Rprofile`), assigning variables, and specifying options via\n    `options()`.\n\n-   You can have an R script act as a shell script (like running a bash\n    shell script) as follows. This will probably on work on Linux and\n    Mac.\n\n    1.  Write your R code in a text file, say `exampleRscript.R`.\n    2.  As the first line of the file, include `#!/usr/bin/Rscript`\n        (like `#!/bin/bash` in a bash shell file, as seen in Unit 2) or\n        for more portability across machines, include\n        `#!/usr/bin/env Rscript`.\n    3.  Make the R code file executable with *chmod*:\n        `chmod ugo+x exampleRscript.R`.\n    4.  Run the script from the command line: `./exampleRscript.R`\n\n    If you want to pass arguments into your script, you can do so as\n    long as you set up the R code to interpret the incoming arguments:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    args <- commandArgs(TRUE)\n    \n    ## Now args is a character vector containing the arguments.\n    ## Suppose the first argument should be interpreted as a number \n    ## and the second as a character string and the third as a boolean:\n    \n    numericArg <- as.numeric(args[1])\n    charArg <- args[2]\n    logicalArg <- as.logical(args[3])\n    \n    cat(\"First arg is: \", numericArg, \"; second is: \", charArg, \n        \"; third is: \", logicalArg, \".\\n\")\n    ```\n    :::\n\n\n\n    Now we can run it as follows in the shell:\n\n\n\n    ::: {.cell}\n    \n    ```{.bash .cell-code}\n    ./exampleRscript.R 53 blah T\n    ./exampleRscript.R blah 22.5 t\n    ```\n    \n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    First arg is:  53 ; second is:  blah ; third is:  TRUE .\n    Warning message:\n    NAs introduced by coercion \n    First arg is:  NA ; second is:  22.5 ; third is:  NA .\n    ```\n    :::\n    :::\n\n\n\n## Interacting with external code\n\nScripting languages such as R, Python, and Julia allow you to call out to \"external code\",\nwhich often means C or C++ (but also Fortran, Java and other languages). \n\nIn fact, the predecessor language to R,\nwhich was called 'S' was developed specifically (at AT&T's Bell Labs in the 1970s and 1980s) as an interactive\nwrapper around Fortran, the numerical programming language most commonly used at the time (and still widely relied on today in various legacy codes). \n\nCalling out to external code is particularly important in languages like R and Python that are often much slower\nthan compiled code and less important in a fast language like Julia (which uses Just-In-Time compilation -- more on that later).\n\nIn R, one can call directly out to C or C++ code using *.Call* or one can use the [Rcpp package](https://adv-r.hadley.nz/rcpp.html). *Rcpp* is specifically designed to be able to write C++ code that feels somewhat like writing R code and where it is very easy to pass data between R and C++. \n\nIn Python, one can [directly call out to C or C++ code](https://docs.python.org/3/extending/extending.html) or one can use *Cython* to interact with C. With Cython, one can:\n  - Have Cython automatically translate Python code to C, if you provide type definitions for your variables.\n  - Define C functions that can be called from your Python code.\n\n# 3. Packages and namespaces\n\nScripting languages that become popular generally have an extensive collection\nof add-on packages available online (the causal relationship of the popularity and\nthe extensive add-on packages goes in both directions). Packages need to\nbe *installed* (once) on your computer and *loaded* (every time you start a new session).\n\nA big part of R's popularity is indeed the extensive collection of add-on\npackages on [CRAN](https://cran.r-project.org) (and GitHub and elsewhere) that provide\nmuch of R's functionality. To make use of a package it needs to be\ninstalled on your system (using *install.packages* once only) and\nloaded into R (using *library* every time you start R).\n\nSome packages are *installed* by default with R and of these, some are\n*loaded* by default, while others require a call to *library*. \n\nIf you want to sound like an R expert, make sure to call them *packages*\nand not *libraries*. A *library* is the location in the directory\nstructure where the packages are installed/stored.\n\n\n## Loading packages\n\nYou can use *library* to either (1) make a package available (loading\nit), (2) get an overview of the package, or (3) (if called without\narguments) to see all the installed packages.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)              # load the package\nlibrary(help = dplyr)       # get some help info about the package\n```\n:::\n\n\n\nPackages in R (and in Python, Julia, etc.) may be installed in various places\non the filesystem, and it sometimes it is helpful (e.g., if you end up with multiple\nversions of a package installed on your system) to be able to figure out \nwhere on the filesystem the package is being loaded from. \nIf you run `library()`, you'll notice that some of the packages are in a\nsystem directory and some are in your home directory. \n\n`.libPaths()` shows where R\nlooks for packages on your system and `searchpaths()` shows where\nindividual packages currently loaded in your session have been loaded from. The help information \nfor *.libPaths* gives some information about how R decides what locations\nto look in for packages (and how you can modify that).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.libPaths()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"/accounts/vis/paciorek/R/x86_64-pc-linux-gnu-library/4.2\"\n[2] \"/system/linux/lib/R-20.04/4.2.0/x86_64/site-library\"     \n[3] \"/usr/lib/R/site-library\"                                 \n[4] \"/usr/lib/R/library\"                                      \n```\n:::\n\n```{.r .cell-code}\nsearchpaths()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \".GlobalEnv\"                                             \n [2] \"tools:quarto\"                                           \n [3] \"/usr/lib/R/library/stats\"                               \n [4] \"/usr/lib/R/library/graphics\"                            \n [5] \"/usr/lib/R/library/grDevices\"                           \n [6] \"/usr/lib/R/library/utils\"                               \n [7] \"/usr/lib/R/library/datasets\"                            \n [8] \"/system/linux/lib/R-20.04/4.2.0/x86_64/site-library/SCF\"\n [9] \"/usr/lib/R/library/methods\"                             \n[10] \"Autoloads\"                                              \n[11] \"/usr/lib/R/library/base\"                                \n```\n:::\n:::\n\n\n\n## Installing packages\n\nIf a package is on CRAN but not on your system, you can install it\neasily (usually). You don't need root permission on a machine to install\na package (though sometimes you run into hassles if you are installing\nit just as a user, so if you have administrative privileges it may help\nto use them). Of course in RStudio, you can install via the GUI. \n\nPackages often depend on other packages. In general, if one package depends on another,\nR will install the dependency automatically, but sometimes you'll need to \ninstall a dependency yourself.  In general, package dependencies\nare handled very cleanly in R without you having having to worry much about it;\nthis is less the case in Python.\n\n\nNote that R will generally install the package in a reasonable place by default\nbut you can control where it is installed using the *lib* argument.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages('dplyr', lib = '~/Rlibs') # ~/Rlibs needs to exist!\n```\n:::\n\n\n\nYou can also download the zipped source file from CRAN and install from\nthe file; see the help page for *install.packages*. This is called\n\"installing from source\". On Windows and Mac, you'll need to do\nsomething like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages('dplyr_VERSION.tar.gz', repos = NULL, type = 'source')\n```\n:::\n\n\n\nThis can be handy if you need to install [an older version of a package](https://cran.r-project.org/src/contrib/Archive)\nfor reproducibility or because of some dependency incompatibility.\n\nIf you've downloaded the binary package (files ending in .tgz for Mac\nand .zip for Windows) and want to install the package directly from the\nfile, use the syntax above but omit the `type= 'source'` argument.\n\n### Source vs. binary packages\n\nThe difference between a *source* package and a *binary* package is that\nthe source package has the raw R (and C and Fortran, in some cases) code\nas text files while the binary package has all the code in a\nbinary/non-text format, including that any C and Fortran code will have already been\ncompiled. To install a source package with C or Fortran code in it,\nyou'll need to have developer/command-line tools (e.g., *XCode* on Mac\nor *Rtools.exe* on Windows) installed on your system so that you have a\ncompiler.\n\n## Managing packages using package managers\n\nFor reproducibility, it's important to know the versions of the packages you use (and the version of R).\nPackage managers make it easy to do this. Some useful packages that do package management in R are *checkpoint*, *renv*, and *packrat*. The basic commonality is that they try to make it easy to 'freeze' the versions of hte packages you are using, record that information, and restore the versions (potentially on some other machine and by some user other than yourself). The package manager may tell you where the packages are installed, but you can always verify things with `.libPaths()`.\n\nIn Python, you can set up and manage isolated environments in which you can control the package versions using virtualenvs or Conda environments.\n\n\n## Package namespaces\n\nThe objects in a package (primarily functions, but also data) are in\ntheir own workspaces, and are accessible after you load the package\nusing `library()`, but are not directly visible when you use `ls()`. In\nother words, each package has its own *namespace*. Namespaces help\nachieve modularity and avoid having zillions of objects all reside in\nyour workspace.  If we want to see the objects in a package's namespace, we\ncan do the following:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsearch()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \".GlobalEnv\"        \"tools:quarto\"      \"package:stats\"    \n [4] \"package:graphics\"  \"package:grDevices\" \"package:utils\"    \n [7] \"package:datasets\"  \"package:SCF\"       \"package:methods\"  \n[10] \"Autoloads\"         \"package:base\"     \n```\n:::\n\n```{.r .cell-code}\n## ls(pos = 4) # for the stats package\nls(pos = 4)[1:5] # just show the first few\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"abline\"    \"arrows\"    \"assocplot\" \"axis\"      \"Axis\"     \n```\n:::\n\n```{.r .cell-code}\nls(\"package:stats\")[1:5] # equivalent\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"acf\"        \"acf2AR\"     \"add.scope\"  \"add1\"       \"addmargins\"\n```\n:::\n\n```{.r .cell-code}\nls(\"package:stats\", pattern = \"^lm\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"lm\"           \"lm.fit\"       \"lm.influence\" \"lm.wfit\"     \n```\n:::\n:::\n\n\n\n### Why have namespaces?\n\nWe'll talk more about namespaces when we talk about variable scope and\nenvironments. But as some motivation for why this is useful, consider the following.\n\nThe *lm* function calls the *lm.fit* function to calculate the least squares solution in regression.\n\nSuppose we write our own *lm.fit* function that does something else:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm.fit <- function(x)\n    print('hi')\n\nx <- 7\nlm.fit(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"hi\"\n```\n:::\n:::\n\n\n\nOne might expect that if one now uses `lm()` to fit a regression, that it wouldn't work correctly because we have an *lm.fit* function in our workspace that doesn't calculate the least squares solution. But it works just fine (see below), because *lm* and *lm.fit* are in the *stats* package namespace (see above) and R's scoping rules (more later) ensure that the *lm.fit* that is found when I run *lm* is the *lm.fit* needed to run the regression and not my silly *lm.fit* function in current workspace.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 10\nx <- runif(n)\ny <- runif(n)\nmod <- lm(y ~ x)\nmod\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = y ~ x)\n\nCoefficients:\n(Intercept)            x  \n      0.638       -0.220  \n```\n:::\n:::\n\n\n\n### Namespace resolution\n\nStandard practice in R has generally been to load a package and then use any of the items in the package namespace directly, e.g.,\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringr)\nstr_detect(\"hello there\", \"hello\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n\nHowever, particularly if you're using the package in only a limited way, it can be a nice idea to not load the entire package and instead use the namespace resolution operator in a style that might remind you of Python and some other languages:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstringr::str_detect(\"hello there\", \"hello\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\nx = np.ndarray([0,3,5])\n```\n:::\n\n\n\nOf course in Python you could also load the entire package (i.e., import the entire namespace), though it's not standard practice:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom numpy import *\n## OR: from numpy import ndarray\nx = ndarray([0,3,5])\n```\n:::\n\n\n\nLoading entire packages often causes 'name collisions' where there are multiple functions (or variables, more genreally) that have the same name. This can be confusing. We'll see how R determines what function to use later in the Unit.\n\n# 4. Types and data structures\n\n## Data structures\n\nPlease see the [data structures section of Unit 2](unit2-dataTech.html#data-structures) for some general discussion of data structures.\n\nWe'll also see more complicated data structures when we consider objects in the next section on object-oriented programming.\n\n\n## Types and classes\n\n### Overview and static vs. dynamic typing\n\nThe term 'type' refers to how a given piece of information is stored and what operations can be done with the information.\n'Primitive' types are the most basic types that often relate directly to how data are stored in memory or on disk (e.g., boolean, integer, numeric (real-valued, aka *double* or *floating point*), character, pointer (aka *address*, *reference*).\n\nIn compiled languages like C and C++, one has to define the type of each variable. Such languages are *statically* typed.\nInterpreted (or scripting) languages such as Python and R have *dynamic* types. One can associate different types of information with a given variable name at different times and without declaring the type of the variable:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 'hello'\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"hello\"\n```\n:::\n\n```{.r .cell-code}\nx <- 7\nx*3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 21\n```\n:::\n:::\n\n\n\nIn contrast in a language like C, one has to declare a variable based on its type before using it:\n\n```\ndouble y;\ndouble x = 3.1;\ny = x * 7.1;\n```\n\nDynamic typing can be quite helpful from the perspective of quick implementation and avoiding tedious type definitions and problems from minor inconsistencies between types (e.g., multiplying an integer by a real-valued number).\nBut static typing has some critical advantages from the perspective of software development, including:\n\n  - protecting against errors from mismatched values and unexpected user inputs, and\n  - generally much faster execution because the type of a variable does not need to be checked when the code is run.\n\nMore complex types in R (and in Python) often use references (*pointers*, aka *addresses*) to the actual locations of the data. We'll see this in detail later in the Unit.\n\n### Types and classes in R\n\nYou should be familiar with vectors as the basic data structure in R,\nwith character, integer, numeric, etc. classes. Vectors are either\n*atomic vectors* or *lists*. Atomic vectors generally contain one of the\nfour following types: *logical*, *integer*, *double* (i.e., *numeric*), and\n*character*.\n\nEverything in R is an object and all objects have a class. For simple\nobjects class and type are often closely related, but this is not the\ncase for more complicated objects. As we'll see later in the Unit, the class describes what the object\ncontains and standard functions associated with it. In general, you\nmainly need to know what class an object is rather than its type.\n\n> **Note**\n> You can look at Table 7.1 in the Adler book to see some other types.\n\nLet's look at the type and class of various data structures in R.\nWe'll first see that real-valued are stored as double-precision (8 byte) floating point numbers\ninternally in R (as 'doubles' in C, as the R interpreter is a program written in C).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndevs <- rnorm(5)\nclass(devs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(devs)   \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\na <- data.frame(x = 1:2)\nclass(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.frame\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nis.data.frame(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.matrix(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis(a, \"matrix\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nm <- matrix(1:4, nrow = 2) \nclass(m) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"matrix\" \"array\" \n```\n:::\n\n```{.r .cell-code}\ntypeof(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n:::\n\n\n\nIn most cases integer-valued numbers are stored as numeric values in R, but there are exceptions such as the result of using the\nsequence operater, `:`, above. We can force R to store values\nas integers:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvals <- c(1, 2, 3)\nclass(vals)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nvals <- 1:3\nclass(vals)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\nvals <- c(1L, 2L, 3L)\nvals\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nclass(vals)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n:::\n\n\n\n\n### Attributes\n\nWe saw the notion of attributes when looking at HTML and XML, where the information was stored as\nkey-value pairs that in many cases had additional information in the form of attributes.\n\nIn R, *attributes* are information about an object attached to an object as\nsomething that looks like a named list. Attributes are often copied when\noperating on an object. This can lead to some weird-looking formatting when \nin subsequent operations the *names* attribute is carried along:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(10 * 365)\nattributes(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n\n```{.r .cell-code}\nqs <- quantile(x, c(.025, .975))\nattributes(qs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$names\n[1] \"2.5%\"  \"97.5%\"\n```\n:::\n\n```{.r .cell-code}\nqs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n 2.5% 97.5% \n-2.05  1.98 \n```\n:::\n\n```{.r .cell-code}\nqs[1] + 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n 2.5% \n0.949 \n```\n:::\n\n```{.r .cell-code}\nobject.size(qs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n352 bytes\n```\n:::\n:::\n\n\n\nWe can get rid of the attribute:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(qs) <- NULL\nqs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -2.05  1.98\n```\n:::\n\n```{.r .cell-code}\nobject.size(qs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n64 bytes\n```\n:::\n:::\n\n\n\nA common use of attributes is that rows and columns may be named in\nmatrices and data frames, and elements in vectors:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(x = 1:2, y = 3:4)\nattributes(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$names\n[1] \"x\" \"y\"\n\n$class\n[1] \"data.frame\"\n\n$row.names\n[1] 1 2\n```\n:::\n\n```{.r .cell-code}\nrow.names(df) <- c(\"first\", \"second\")\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       x y\nfirst  1 3\nsecond 2 4\n```\n:::\n\n```{.r .cell-code}\nattributes(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$names\n[1] \"x\" \"y\"\n\n$class\n[1] \"data.frame\"\n\n$row.names\n[1] \"first\"  \"second\"\n```\n:::\n\n```{.r .cell-code}\nvec <- c(first = 7, second = 1, third = 5)\nvec['first']\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfirst \n    7 \n```\n:::\n\n```{.r .cell-code}\nattributes(vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$names\n[1] \"first\"  \"second\" \"third\" \n```\n:::\n:::\n\n\n\n### Converting between types\n\nThis also goes by the term *coercion* and *casting*. \nCasting often needs to be done explicitly in compiled languages and somewhat less so in interpreted languages like R.\n\nWe convert between classes using variants on *as*: e.g.,\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.character(c(1,2,3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\" \"2\" \"3\"\n```\n:::\n\n```{.r .cell-code}\nas.numeric(c(\"1\", \"2.73\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.00 2.73\n```\n:::\n\n```{.r .cell-code}\nas.factor(c(\"a\", \"b\", \"c\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] a b c\nLevels: a b c\n```\n:::\n:::\n\n\n\nSome common conversions are converting numbers that are being\ninterpreted as characters into actual numbers, converting between\nfactors and characters, and converting between logical TRUE/FALSE\nvectors and numeric 1/0 vectors. \n\nIn some cases R will automatically do\nconversions behind the scenes in a smart way (or occasionally not so\nsmart way). Consider these examples of implicit coercion:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(5)\nx[3] <- 'hat' # What do you think is going to happen?\nindices <- c(1, 2.73)\nmyVec <- 1:10\nmyVec[indices]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2\n```\n:::\n:::\n\n\n\nHere's an example we can work through that will help illustrate how type\nconversions occur behind the scenes in R.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 5\ndf <- data.frame(label = rep('a', n), val1 = rnorm(n), val2 = rnorm(n))\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  label   val1   val2\n1     a -0.290 -1.180\n2     a -0.561  0.772\n3     a -0.790  0.682\n4     a  0.165  0.284\n5     a  1.089 -0.592\n```\n:::\n\n```{.r .cell-code}\n## Why does the following not work?\ntry( apply(df, 1, function(x) x[2] + x[3]) )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nError in x[2] + x[3] : non-numeric argument to binary operator\n```\n:::\n\n```{.r .cell-code}\n## Instead, this will work. Why?\napply(df[ , 2:3], 1, function(x) x[1] + x[2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1.470  0.211 -0.108  0.449  0.496\n```\n:::\n:::\n\n\n\nBe careful of using factors as indices:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudents <- factor(c(\"basic\", \"proficient\", \"advanced\",\n                     \"basic\", \"advanced\", \"minimal\"))\nscore <- c(minimal = 65, basic = 75, proficient = 85, advanced = 95)\nscore[\"advanced\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nadvanced \n      95 \n```\n:::\n\n```{.r .cell-code}\nstudents[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] advanced\nLevels: advanced basic minimal proficient\n```\n:::\n\n```{.r .cell-code}\nscore[students[3]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nminimal \n     65 \n```\n:::\n\n```{.r .cell-code}\nscore[as.character(students[3])]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nadvanced \n      95 \n```\n:::\n:::\n\n\n\nWhat has gone wrong and how does it relate to type coercion?\n\n\n\n## Data frames and related concepts\n\n### Some notes on data frames and operations on data frames\n\nBase R provides a variety of functions for manipulating data frames, but\nnow many researchers use add-on packages (many written by Hadley Wickham\nas part of a group of packages called the *tidyverse*) to do these\nmanipulations in a more elegant way. [Module 6 of the R bootcamp](https://https://berkeley-scf.github.io/r-bootcamp-fall-2022/modules/module6_tidyverse) describes some of these new tools in more details, but I'll touch on some aspects of this here, without showing much of the tidyverse syntax.\n\n### split-apply-combine\n\nOften analyses are done in a stratified fashion - the same operation or\nanalysis is done on subsets of the data set. The subsets might be\ndifferent time points, different locations, different hospitals,\ndifferent people, etc.\n\nThe split-apply-combine framework is intended to operate in this kind of\ncontext: first one splits the dataset by one or more variables, then one\ndoes something to each subset, and then one combines the results. The\n*dplyr* package implements this framework (as does the *pandas* package\nfor Python). One can also do similar operations using various flavors of\nthe *lapply* family of functions such as *by*, *tapply*, and\n*aggregate*, but the dplyr-based tools are often nicer to use.\n\nsplit-apply-combine is also closely related to the famous Map-Reduce framework\nunderlying big data tools such as Hadoop and Spark. \n\nIt's also very similar to standard SQL queries involving filtering, grouping, and\naggregation.\n\n### Long and wide formats\n\nFinally, we may want to convert between so-called 'long' and 'wide'\nformats, which we can motivate in the context of longitudinal data\n(multiple observations per subject) and panel data (temporal data for\neach of multiple units such as in econometrics). The wide format has\nrepeated measurements for a subject in separate columns, while the long\nformat has repeated measurements in separate rows, with a column for\ndifferentiating the repeated measurements. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlong <- data.frame(id = c(1, 1, 1, 2, 2, 2),\n                   time = c(1980, 1990, 2000, 1980, 1990, 2000),\n                   value = c(5, 8, 9, 7, 4, 7))\nwide <- data.frame(id = c(1, 2),\n                   value_1980 = c(5, 7), value_1990 = c(8, 4), value_2000 = c(9, 7))\nlong\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  id time value\n1  1 1980     5\n2  1 1990     8\n3  1 2000     9\n4  2 1980     7\n5  2 1990     4\n6  2 2000     7\n```\n:::\n\n```{.r .cell-code}\nwide\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  id value_1980 value_1990 value_2000\n1  1          5          8          9\n2  2          7          4          7\n```\n:::\n:::\n\n\n\nThe wide format can be useful in some situations for treating each row as a (multivariate observation), \nbut the long formatwhile the long format is often what is needed for analyses such as \nmixed models. ANOVA, or for plotting, such as with *ggplot2*.\n\nThere are a variety of functions for converting between wide and long\nformats. I recommend *pivot_longer* and *pivot_wider* in the *tidyr* package. There are also older *tidyr* functions\ncalled *gather* and *spread*. There are also the *melt* and\n*cast* in the *reshape2* package. These are easier to use than the\nfunctions in base R such as *reshape* or *stack* and *unstack*\nfunctions*.*\n\n### Piping\n\nPiping was introduced into R in conjuction with *dplyr* and the *tidyverse*.\n\nThe tidyverse pipe is `%>%` while the new base R pipe is `|>`.\nThese are based on the UNIX pipe, which we saw in Unit 3, though\nthey behave somewhat differently in that the output of the previous function\nis passed in as the *first* argument of the next function. In the shell,\nthe pipe connects *stdout* from the previous command to *stdin* for the next command.\n\n\n### Non-standard evaluation and the tidyverse\n\nMany tidyverse packages use non-standard evaluation to make it easier to\ncode. For example in the following dplyr example, you can refer directly\nto *country* and *unemp*, which are variables in the data frame, without\nusing `data$country` or `data$unemp` and without using quotes around the\nvariable names, as in `\"country\"` or `\"unemp\"`. Referring directly to\nthe variables in the data frame is not standard R usage, hence the term\n\"non-standard evaluation\". One reason it is not standard is that *country*\nand *unemp* are not themselves independent R variables so R can't find\nthem in the usual way using scoping (discussed later in the Unit).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\ncpds <- read.csv(file.path('..', 'data', 'cpds.csv'))\n\ncpds2 <- cpds %>% group_by(country) %>%\n                  mutate(mean_unemp = mean(unemp))\n\nhead(cpds2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 7\n# Groups:   country [1]\n   year country   vturn outlays realgdpgr unemp mean_unemp\n  <int> <chr>     <dbl>   <dbl>     <dbl> <dbl>      <dbl>\n1  1960 Australia  95.5    NA       NA     1.42       5.52\n2  1961 Australia  95.3    NA       -0.07  2.79       5.52\n3  1962 Australia  95.3    23.2      5.71  2.63       5.52\n4  1963 Australia  95.7    23.0      6.1   2.12       5.52\n5  1964 Australia  95.7    22.9      6.28  1.15       5.52\n6  1965 Australia  95.7    24.9      4.97  1.15       5.52\n```\n:::\n:::\n\n\n\n\nThis 'magic' is done by capturing the code expression you write and\nevaluating it in a special way in the context of the data frame. I\nbelieve this uses R's environment class (discussed later in the Unit), but\nhaven't looked more deeply.\n\nWhile this has benefits, this so-called non-standard evaluation makes it\nharder to program functions in the usual way, as illustrated in the\nfollowing code chunk, where neither attempt to use the function works.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_mean <- function(data, group_var, summarize_var) {\n    data %>% group_by(group_var) %>%\n             mutate(mean_of_var = mean(summarize_var))\n}\n\ntry(cpds2 <- add_mean(cpds, country, unemp))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nError in group_by(., group_var) : \n  Must group by variables found in `.data`.\nx Column `group_var` is not found.\n```\n:::\n\n```{.r .cell-code}\ntry(cpds2 <- add_mean(cpds, 'country', 'unemp'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nError in group_by(., group_var) : \n  Must group by variables found in `.data`.\nx Column `group_var` is not found.\n```\n:::\n:::\n\n\n\n\nFor more details on how to avoid this problem when writing functions\nthat involve tidyverse manipulations, see\n[this tidyverse programming guide](https://dplyr.tidyverse.org/articles/programming.html).\n\nNote that the tidyverse is not the only place where non-standard\nevaluation is used. Consider this *lm* call:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm(y ~ x, weights = w, data = mydf)\n```\n:::\n\n\n\n> **Challenge**\n> Where is the non-standard evaluation there?\n\n# 5. Programming paradigms: object-oriented and functional programming\n\nObject-oriented and functional programming are two important approaches to programming.\n\nFunctional programming focuses on writing functions that take inputs and produce outputs. Ideally those functions don't change the state (i.e., the values) of any variables and can be treated as black boxes. Functions can be treated like other variables, such as passing functions as arguments (as one does with *lapply* in R, for example).\n\nObject-oriented programming revolves around objects that belong to classes. The class of an object defines the fields (the data objects) holding information and (often) methods that can be applied to those fields. When one calls a method, it may modify the value of the fields. A statistical analogy is that an object of a class is like the realization (the object) of a random variable (the class).\n\nOne can think of functional programming as being focused on actions (or *verbs* to make an analogy with human language). One carries out a computation as a sequence of function calls. One can think of OOP as being focused on the objects (or *nouns*). One carries out a computation as a sequence of operations with the objects, using the class methods.\n\nMany languages are multi-paradigm, containing aspects of both approaches and allowing programmers to use either approach. Both R and Python are like this, though some might consider R to be more functional and Python to be more object-oriented. That said, in R everything is an object and has a class, while there are plenty of function-based operations in Python.\n\n```python\nimport numpy as np\nx = np.array([1.2, 3.5, 4.2])\nx.shape  # field (or attribute) of the numpy array class\nx.sum()  # method of the class\nlen(x)   # function\n```\n\nDifferent people have different preferences, but which is better depends on what you are trying to do. If your computation is a data analysis pipeline that involves a series of transformations of some data, a functional approach might make more sense, since the focus is on a series of actions rather than the state of objects. If your computation involves various operations on fixed objects whose state needs to change, OOP might make more sense. For example, if you were writing code to keep track of student information, it would probably make sense to have each student as an object of a Student class with methods such as 'register' and 'assign_grade'. \n\n\n# 6. Object-oriented programming (OOP)\n\n## Principles\n\nSome of the standard concepts in object-oriented programming include *encapsulation*, *inheritance*, *polymorphism*, and *abstraction*.\n\n*Encapsulation* involves preventing direct access to internal data in an object from outside the object. Instead the class is designed so that access (reading or writing) happens through the interface set up by the programmer (e.g., 'getter' and 'setter' methods). We'll see this in our R6 class example below.\n\n*Inheritance* allows one class to be based on another class, adding more specialized features. An example in R's S3 system is that the *glm* class inherits from the *lm* class. \n\n*Polymorphism* allows for different behavior of an object or function depending on the context. A polymorphic function behaves differently depending on the input types. A polymorphic object is one that can belong to different classes (e.g., based on inheritance), and a given method name can be used with any of the classes. An example would be having a base or super class called 'algorithm' and various specific machine learning algorithms inheriting from that class. All of the classes might have a 'predict' method.\n\n*Abstraction* involves hiding the details of how something is done (e.g., via the method of a class), giving the user an interface to provide inputs and get outputs. By making the actual computation a black box, the programmer can modify the internals without changing how a user uses the system. \n\nClasses generally have *constructors* that initialize objects of the class and *destructors* that remove objects.\n\n\n## Generic function OOP\n\nMuch of the object-oriented programming in R uses *generic function OOP*, also known as *functional OOP*. \nIn this style, classes don't have methods. Instead there are *generic functions* (also known as *generic methods*) that change their behavior based on the type of the input(s). Another way to put it is that the nouns and the verbs are separate, unliked in standard OOP.\n\nThe use of generic functions is similar in spirit to function or method *overloading* in C++ and Java.\n\nGeneric function OOP  is how the (very) old S3 system in R works. It's also a key part of the (fairly) new Julia language.\n\n### S3 classes in R\n\nS3 classes are widely-used, in particular for statistical models in the\n*stats* package. S3 classes are very informal in that there's not a\nformal definition for an S3 class. Instead, an S3 object is just a\nprimitive R object such as a list or vector with additional attributes\nincluding a class name.\n\n#### Creating our own class\n\nWe can create an object with a new class as follows:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyog <- list(firstname = 'Yogi', surname = 'the Bear', age = 20)\nclass(yog) <- 'bear' \n```\n:::\n\n\n\nActually, if we want to create a new class that we'll use again, we want\nto create a *constructor* function that initializes new bears:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbear <- function(firstname = NA, surname = NA, age = NA){\n\t# constructor for 'indiv' class\n\tobj <- list(firstname = firstname, surname = surname,\n                    age = age)\n\tclass(obj) <- 'bear' \n\treturn(obj)\n}\nsmoke <- bear('Smokey','Bear')\n```\n:::\n\n\n\nFor those of you used to more formal OOP, the following is probably\ndisconcerting:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(smoke) <- \"celebrity\"\n```\n:::\n\n\n\nGenerally S3 classes inherit from lists (i.e., are special cases of lists),\nso you can obtain components of the object using the \\$ operator.\n\n#### Generic methods\n\nThe real power of the S3 system comes from defining *class-specific methods*. For example,\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(10)\nsummary(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n -3.003  -0.665  -0.029  -0.330   0.452   1.215 \n```\n:::\n\n```{.r .cell-code}\ny <- rnorm(10)\nmod <- lm(y ~ x)\nsummary(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = y ~ x)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-1.5499 -0.6848 -0.0534  0.8031  1.5231 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)\n(Intercept)    0.117      0.369    0.32     0.76\nx              0.113      0.307    0.37     0.72\n\nResidual standard error: 1.12 on 8 degrees of freedom\nMultiple R-squared:  0.0165,\tAdjusted R-squared:  -0.106 \nF-statistic: 0.134 on 1 and 8 DF,  p-value: 0.723\n```\n:::\n:::\n\n\n\nHere *summary* is a generic function (or generic method) that, based\non the type of object given to it (the first argument), dispatches a\nclass-specific function (method) that operates on the object. \n\nThe above is equivalent to directly calling the class-specific methods:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nidentical(summary(x), summary.default(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nidentical(summary(mod), summary.lm(mod))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n\n\nThis use of generic functions is convenient in that it allows us to work with a variety of kinds of objects using familiar functions. Consider\nthe generic methods *plot*, *print*, *summary*, *\\[*, and\nothers. We can look at a function and easily see that it is a generic\nmethod. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (object, ...) \nUseMethod(\"summary\")\n<bytecode: 0x562addfc90c0>\n<environment: namespace:base>\n```\n:::\n:::\n\n\n\nThe `UseMethod` syntax is what causes the dispatching of the class-specific method\nassociated with `object` and calls that method.\nIn many cases there will be a default method (here,\n*summary.default*), so if no method is defined for the class, R uses\nthe default. Sidenote: arguments to a generic method are passed along to\nthe selected method by passing along the calling environment.\n\nWe can also see what classes have methods for a given generic\nfunction.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmethods(summary)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] summary,ANY-method                   summary,DBIObject-method            \n [3] summary,diagonalMatrix-method        summary,sparseMatrix-method         \n [5] summary.aov                          summary.aovlist*                    \n [7] summary.aspell*                      summary.check_packages_in_dir*      \n [9] summary.connection                   summary.data.frame                  \n[11] summary.Date                         summary.default                     \n[13] summary.ecdf*                        summary.factor                      \n[15] summary.glm                          summary.infl*                       \n[17] summary.lm                           summary.loess*                      \n[19] summary.manova                       summary.matrix                      \n[21] summary.mlm*                         summary.nls*                        \n[23] summary.packageStatus*               summary.pandas.core.frame.DataFrame*\n[25] summary.pandas.core.series.Series*   summary.POSIXct                     \n[27] summary.POSIXlt                      summary.ppr*                        \n[29] summary.prcomp*                      summary.princomp*                   \n[31] summary.proc_time                    summary.python.builtin.object*      \n[33] summary.rlang_error*                 summary.rlang_message*              \n[35] summary.rlang_trace*                 summary.rlang_warning*              \n[37] summary.rlang:::list_of_conditions*  summary.shingle*                    \n[39] summary.srcfile                      summary.srcref                      \n[41] summary.stepfun                      summary.stl*                        \n[43] summary.table                        summary.trellis*                    \n[45] summary.tukeysmooth*                 summary.vctrs_sclr*                 \n[47] summary.vctrs_vctr*                  summary.warnings                    \nsee '?methods' for accessing help and source code\n```\n:::\n:::\n\n\n\nOr from a different angle we can see what specific methods are available for a given class.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmethods(class = 'lm')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] add1           alias          anova          case.names     coerce        \n [6] confint        cooks.distance deviance       dfbeta         dfbetas       \n[11] drop1          dummy.coef     effects        extractAIC     family        \n[16] formula        hatvalues      influence      initialize     kappa         \n[21] labels         logLik         model.frame    model.matrix   nobs          \n[26] plot           predict        print          proj           qr            \n[31] residuals      rstandard      rstudent       show           simulate      \n[36] slotsFromS3    summary        variable.names vcov          \nsee '?methods' for accessing help and source code\n```\n:::\n:::\n\n\n\nLet's try this functionality  out on our *bear* class.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary.bear <- function(object) \n    with(object, cat(\"Bear of age \", age, \n\t\" whose name is \", firstname, \" \", surname, \".\\n\",\n        sep = \"\"))\n    invisible(NULL)\n\nsummary(yog)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBear of age 20 whose name is Yogi the Bear.\n```\n:::\n:::\n\n\n\nWe can also define a new generic function.\n\nLet's do this for the *bear* class as an illustration, though this won't\nprovide any functionality beyond what we did with *summary*\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarize <- function(object, ...) \n\tUseMethod(\"summarize\") \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarize.bear <- function(object) \n    with(object, cat(\"Bear of age \", age, \n\t\" whose name is \", firstname, \" \", surname, \".\\n\",\n        sep = \"\"))\n    invisible(NULL)\n\nsummarize(yog)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBear of age 20 whose name is Yogi the Bear.\n```\n:::\n:::\n\n\n\n#### Why use generic functions?\n\nWe could have written *summary* as a regular function with a bunch of if statements or if-else clauses (or *switch*) so that it can handle different kinds of input objects. \n\nThis has two disadvantages:\n\n  1. We need to write the code that does the checking (and all the code for the different cases all lives inside one potentially very long function, unless we create class-specific helper functions).\n  2. Much more importantly, *summary* will only work for existing classes. And users can't easily extend it for new classes that they create because they don't control the *summary* function. So a user could not add the additional conditions/classes in a big if-else statement. The generic function approach makes the system *extensible* -- we can build our own new functionality on what is already in R. For example, we could have written *summary.bear*.\n\n#### The print method\n\nLike *summary*, *print* is a generic method, with various\nclass-specific methods, such as *print.lm*. We could write our own\n*print.bear* specific method. \n\nNote that the *print* function is what is called when you simply type\nthe name of the object, so we can have object information printed out in\na structured way. Thus, the output when we type the name of an\n*lm* object is NOT simply a regurgitation of the elements of the list -\nrather *print.lm* is called.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = y ~ x)\n\nCoefficients:\n(Intercept)            x  \n      0.117        0.113  \n```\n:::\n\n```{.r .cell-code}\nprint(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = y ~ x)\n\nCoefficients:\n(Intercept)            x  \n      0.117        0.113  \n```\n:::\n\n```{.r .cell-code}\nstats:::print.lm(mod)  ## print.lm is private to the stats namespace\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = y ~ x)\n\nCoefficients:\n(Intercept)            x  \n      0.117        0.113  \n```\n:::\n\n```{.r .cell-code}\n# print.default(mod)   ## lots of output, so don't print in document...\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstats:::print.lm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, digits = max(3L, getOption(\"digits\") - 3L), ...) \n{\n    cat(\"\\nCall:\\n\", paste(deparse(x$call), sep = \"\\n\", collapse = \"\\n\"), \n        \"\\n\\n\", sep = \"\")\n    if (length(coef(x))) {\n        cat(\"Coefficients:\\n\")\n        print.default(format(coef(x), digits = digits), print.gap = 2L, \n            quote = FALSE)\n    }\n    else cat(\"No coefficients\\n\")\n    cat(\"\\n\")\n    invisible(x)\n}\n<bytecode: 0x562ada51c7e0>\n<environment: namespace:stats>\n```\n:::\n:::\n\n\n\nSurprisingly, the *summary* method generally doesn't actually print\nout information; rather it computes things not stored in the original\nobject and returns it as a new class (e.g., class *summary.lm*), which\nis then automatically printed, per my comment above (e.g., using\n*print.summary.lm*), unless one assigns it to a new object. Note that\n*print.summary.lm* is hidden from user view (it's a private object in the *stats* namespace).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout <- summary(mod)\nclass(out)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"summary.lm\"\n```\n:::\n\n```{.r .cell-code}\nout\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = y ~ x)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-1.5499 -0.6848 -0.0534  0.8031  1.5231 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)\n(Intercept)    0.117      0.369    0.32     0.76\nx              0.113      0.307    0.37     0.72\n\nResidual standard error: 1.12 on 8 degrees of freedom\nMultiple R-squared:  0.0165,\tAdjusted R-squared:  -0.106 \nF-statistic: 0.134 on 1 and 8 DF,  p-value: 0.723\n```\n:::\n\n```{.r .cell-code}\nprint(out)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = y ~ x)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-1.5499 -0.6848 -0.0534  0.8031  1.5231 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)\n(Intercept)    0.117      0.369    0.32     0.76\nx              0.113      0.307    0.37     0.72\n\nResidual standard error: 1.12 on 8 degrees of freedom\nMultiple R-squared:  0.0165,\tAdjusted R-squared:  -0.106 \nF-statistic: 0.134 on 1 and 8 DF,  p-value: 0.723\n```\n:::\n\n```{.r .cell-code}\n## One can look at the code for the method (not shown):\n## getS3method(f = \"print\", class = \"summary.lm\")\n```\n:::\n\n\n\n#### Inheritance\n\nLet's look at the *lm* class, which builds on lists, and *glm* class,\nwhich builds on the *lm* class. Here *mod* is an object (an instance) of\nclass *lm*. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(methods)\nybin <- sample(c(0, 1), 10, replace = TRUE)\nycont <- rnorm(10)\nx <- rnorm(10)\nmod1 <- lm(ycont ~ x)\nmod2 <- glm(ybin ~ x, family = binomial)\nclass(mod1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"lm\"\n```\n:::\n\n```{.r .cell-code}\nclass(mod2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"glm\" \"lm\" \n```\n:::\n\n```{.r .cell-code}\nis.list(mod1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nnames(mod1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"coefficients\"  \"residuals\"     \"effects\"       \"rank\"         \n [5] \"fitted.values\" \"assign\"        \"qr\"            \"df.residual\"  \n [9] \"xlevels\"       \"call\"          \"terms\"         \"model\"        \n```\n:::\n\n```{.r .cell-code}\nis(mod2, \"lm\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n\nHere's an example of why this is useful. We don't have to define methods for\nthe *glm* class if the given method for the *lm* class would work fine:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel.matrix(mod1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   (Intercept)      x\n1            1  1.902\n2            1  0.235\n3            1  0.794\n4            1  1.709\n5            1 -0.116\n6            1  1.314\n7            1  2.767\n8            1 -0.891\n9            1 -1.857\n10           1 -0.397\nattr(,\"assign\")\n[1] 0 1\n```\n:::\n\n```{.r .cell-code}\nmodel.matrix(mod2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   (Intercept)      x\n1            1  1.902\n2            1  0.235\n3            1  0.794\n4            1  1.709\n5            1 -0.116\n6            1  1.314\n7            1  2.767\n8            1 -0.891\n9            1 -1.857\n10           1 -0.397\nattr(,\"assign\")\n[1] 0 1\n```\n:::\n\n```{.r .cell-code}\nmethods(model.matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] model.matrix.default model.matrix.lm     \nsee '?methods' for accessing help and source code\n```\n:::\n:::\n\n\n\nAs noted with *lm* and *glm* objects, we can assign more than one class\nto an object. Here *summarize* still works, even though the primary\nclass is *grizzly_bear*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(yog) <- c('grizzly_bear', 'bear')\nsummarize(yog) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBear of age 20 whose name is Yogi the Bear.\n```\n:::\n:::\n\n\n\nThe classes should nest within one another with the more specific\nclasses to the left, e.g., here a *grizzly_bear* would have some\nadditional fields on top of those of a *bear*, perhaps\n*number_of_people_killed* (since grizzly bears are much more dangerous\nthan some other kinds of bears), and perhaps additional or modified\nmethods. *grizzly_bear* inherits from *bear*, and R uses methods for the\nfirst class before methods for the next class(es).\n\nThe above is an example of polymorphism. `yog` is a polymorphic object \nand the various methods are polymorphic in that *print* can be used\nwith the *bear* class, the *grizzly_bear* class, and other classes beyond that.\n\n\n> **Challenge**\n> How would you get R to quit immediately, without asking for any more information, when you simply type `k` (no parentheses!) instead of `quit()`? (Hint: you can do this by understanding what happens when you type `k` and how to exploit the S3 system.)\n\n\n### Multiple dispatch OOP \n\nS3 method dispatch involves only the first argument to the function. In contrast, [Julia emphasizes the importance of multiple dispatch](https://docs.julialang.org/en/v1/manual/methods) as particularly important for mathematical computation. With multiple dispatch, the specific method can be chosen based on more than one argument.\n\nThe old (but still used in some contexts) [S4](http://adv-r.had.co.nz/S4.html) system in R and the (very) new [R7](https://rconsortium.github.io/OOP-WG) system both provide for multiple dispatch. \n\nAs a very simple example unrelated to any specific language, multiple dispatch would allow one to do the following with the addition operator:\n\n```\n3 + 7    # 10\n3 + 'a'  # '3a'\n'hi' +  ' there'  # 'hi there'\n```\n\nThe idea of having the behavior of an operator or function adapt to the type of the input(s) is one aspect of *polymorphism*.\n\nBoth S4 and R7 are designed to be more formal than the S3 system (recall how we could just 'create' an S3 class by giving a class name to an existing list). With S4 and R7, you need to define your classes. \n\n## 'Standard' OOP\n\nWhat I'm calling 'standard' object-oriented programming is the style of OOP used in languages such as Python, C++, and Java. In R, one can use this style via the R6 system (or the older *referenceClass* system).\n\nIn this style, objects belong to classes. A class is made up of fields (the data objects) that store information and methods that operate on the fields. Thus, unlike generic function OOP, the verbs are part of the nouns.\n\nWe'll illustrate this style of OOP using an example with an R6 class.\n\n### R6 classes\n\nR6 classes are a somewhat new construct in R, with a class-based approach fairly similar to Python and C++. Importantly, they behave like pointers. We'll discuss pointers in detail later. Let's work through an example\nwhere we set up the fields of the class and class\nmethods, including a constructor.\n\n#### Example\n\nOur example is to create a class for working with random time series. Each object of the class has specific parameter values that control the stochastic behavior of the time series. With a given object we can simulate one or more time series (realizations).\n\nHere's the initial definition of the class, with both public\n(user-facing) and private (internal use only) methods and fields.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(R6)\n\ntsSimClass <- R6Class(\"tsSimClass\",\n    ## class for holding time series simulators\n    public = list(\n        initialize = function(times, mean = 0, corParam = 1) {\n            library(fields)\n            stopifnot(is.numeric(corParam), length(corParam) == 1)\n            stopifnot(is.numeric(times))\n            private$times <- times\n            private$n <- length(times)\n            private$mean <- mean\n            private$corParam <- corParam\n            private$currentU <- FALSE\n            private$calcMats()\n        },\n        \n        setTimes = function(newTimes) {\n            private$times <- newTimes\n            private$calcMats()\n        },\n        \n        getTimes = function() {\n            return(private$times)\n        },\n\n        print = function() { # 'print' method\n            cat(\"R6 Object of class 'tsSimClass' with \",\n                private$n, \" time points.\\n\", sep = '')\n            invisible(self)\n        },\n\n        simulate = function() {\n            if(!private$currentU)     \n                private$calcMats()\n            ## analogous to mu+sigma*z for generating N(mu, sigma^2)\n            return(private$mean + crossprod(private$U, rnorm(private$n)))\n        }\n    ),\n\n    ## private methods and functions not accessible externally\n    private = list(\n        calcMats = function() {\n            ## calculates correlation matrix and Cholesky factor\n            lagMat <- fields::rdist(private$times) # local variable\n            corMat <- exp(-lagMat^2 / private$corParam^2)\n            private$U <- chol(corMat) # square root matrix\n            cat(\"Done updating correlation matrix and Cholesky factor.\\n\")\n            private$currentU <- TRUE\n            invisible(self)\n        },\n        n = NULL, \n        times = NULL,\n        mean = NULL,\n        corParam = NULL,\n        U = NULL,\n        currentU = FALSE\n    )\n)   \n```\n:::\n\n\n\n\nNow let's see how we would use the class.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyts <- tsSimClass$new(1:100, 2, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDone updating correlation matrix and Cholesky factor.\n```\n:::\n\n```{.r .cell-code}\nmyts\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR6 Object of class 'tsSimClass' with 100 time points.\n```\n:::\n\n```{.r .cell-code}\nset.seed(1)\n## here's a simulated time series\ny1 <- myts$simulate()\nplot(myts$getTimes(), y1, type = 'l', xlab = 'time',\n     ylab = 'process values')\n## simulate a second series\ny2 <- myts$simulate()\nlines(myts$getTimes(), y2, lty = 2)\n```\n\n::: {.cell-output-display}\n![](unit5-programming_files/figure-pdf/unnamed-chunk-59-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nWe could set up a different object that has different parameter values.\nThat new simulated time series is less wiggly because the `corParam` value\n is larger than before.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyts2 <- tsSimClass$new(1:100, 2, 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDone updating correlation matrix and Cholesky factor.\n```\n:::\n\n```{.r .cell-code}\nset.seed(1)\n## here's a simulated time series with a different value of\n## the correlation parameter (corParam)\ny3 <- myts2$simulate()\n\nplot(myts$getTimes(), y1, type = 'l', xlab = 'time',\n     ylab = 'process values')\nlines(myts$getTimes(), y2, lty = 2)\nlines(myts2$getTimes(), y3, col = 'red')\n```\n\n::: {.cell-output-display}\n![](unit5-programming_files/figure-pdf/unnamed-chunk-60-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n#### Copies and references\n\nNext let's think about when copies are made. In the next example `mytsRef` is a copy of `myts`\nin the sense that both names point to the same underlying object.\nBut no data were copied when the assignment to `mytsRef` was done. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmytsRef <- myts\n## 'mytsRef' and 'myts' are names for the same underlying object\nmytsFullCopy <- myts$clone()  \n\n## Now let's change the values of a field\nmyts$setTimes(seq(0,1000, length = 100))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDone updating correlation matrix and Cholesky factor.\n```\n:::\n\n```{.r .cell-code}\nmyts$getTimes()[1:5] \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  0.0 10.1 20.2 30.3 40.4\n```\n:::\n\n```{.r .cell-code}\nmytsRef$getTimes()[1:5] # the same as `myts`\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  0.0 10.1 20.2 30.3 40.4\n```\n:::\n\n```{.r .cell-code}\nmytsFullCopy$getTimes()[1:5] # different from `myts`\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n\n\nIn contrast `mytsFullCopy` is a reference to a different object, and\nall the data from `myts` had to be copied over to `mytsFullCopy`. This takes additional memory (and time), but is also safer, as it avoids the possibility that the user might modify `myts` and not realize that they were also affecting `mytsRef`.\n\n#### Encapsulation\n\nWhy have private fields (i.e., encapsulation)? The use of private fields shields them from\n    modification by users. In this case, that prevent users from modifying the\n*times* field. Why is this important? In this example, the correlation matrix and\n    the Cholesky factor U are both functions of the vector of times. So\n    we don't want to allow a user to directly modify *times*. If they did, it would leave the fields of the object in inconsistent states. Instead we\n    force them to use *setTimes*, which correctly keeps all the fields\n    in the object internally consistent (by calling *calcMats*). It also allows us to improve efficiency\nby controlling when computationally expensive operations are carried out.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntry(myts$times <- 1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nError in myts$times <- 1:10 : cannot add bindings to a locked environment\n```\n:::\n:::\n\n\n\n#### Final comments\n\n  -   As we saw above, a copy of an object is just a pointer to the original object, unless we explicitly invoke the *clone* method.\n  -   Classes can inherit from other classes. E.g., if we had a *simClass* and we wanted the *tsSimClass* to inherit from it:\n\n      ```\n      R6Class(tsSimClass, inherit = simClass, ...) \n      ```\n  -   If you need to refer to methods and fields you refer to the entire object as either *self* or *private*.\n\n\nMore details on R6 classes can be found in the [Advanced R book](https://adv-r.hadley.nz/r6.html).\n\n\n# 7. Functional programming\n\n## Overview of functional programming\n\nFunctional programming is an approach to programming that emphasizes the use of modular, self-contained functions.\nSuch functions should operate only on arguments provided to\nthem (avoiding global variables), and **produce no side effects**, although in some cases there are good\nreasons for making an exception. Another aspect of functional programming is \nthat functions are considered 'first-class' citizens in that they can be passed as arguments to another function,\nreturned as the result of a function, and assigned to variables. In other words, a function can be treated as any other variable.\n\nIn many cases (including R and Python), anonymous functions (also called 'lambda functions') can be created on-the-fly for use in various circumstances. \n\n## Functional programming in R\n\nR is a language that has strong functional programming aspects to it, including:\n\n  - All operations are carried out by functions.\n  - Functions are first class citizens.\n  - Functions (generally) do not have side effects.\n  - *Map* operations (e.g., *lapply*) are central to programming in R.\n\nFunctions that are not implemented internally in R  are also referred to officially as *closures* (this is their\n*type*) - this terminology sometimes comes up in error messages.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"closure\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(lm)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"closure\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(length)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"builtin\"\n```\n:::\n:::\n\n\n\n\n### No side effects\n\nMost functions available in R (and ideally functions that you write as well) operate by taking in arguments and producing output that is then (presumably) used subsequently. The functions generally don't have any effect on the state of your R environment/session other than the output they produce.\n\nAn important reason for this (plus for not using global variables) is that it means that it is easy for people using the language to understand what code does. Every function can be treated a black box -- you don't need to understand what happens in the function or worry that the function might do something unexpected (such as changing the value of one of your variables). The result of running code is simply the result of a composition of functions, as in mathematical function composition.\n\nOne aspect of this is that R uses a *pass-by-value* approach to function arguments (as opposed to a *pass-by-reference* approach). We'll talk about function arguments and when copies are made  in much more detail later, but briefly, when you pass an object in as an argument and then modify it in the function, you are modifying a local copy of the variable that exists in the context (the *frame*) of the function and is deleted when the function call finishes:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:3\nmyfun <- function(x) {\n      x[2] <- 7\n      print(x)\n      return(x)\n}\n\nnew_x <- myfun(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 7 3\n```\n:::\n\n```{.r .cell-code}\nx   # unmodified\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n:::\n\n\n\nIn contrast, let's see what happens in Python\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nx = [1,2,3]\ndef myfun(x):\n  x[1] = 7\n  print(x)\n  return(x)\n\nnew_x = myfun(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 7, 3]\n```\n:::\n\n```{.python .cell-code}\nx   # modified!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 7, 3]\n```\n:::\n:::\n\n\n\nThere are some (necessary) exceptions to the idea of no side effects in R. \nAn important exception is *par()*. If you change graphics parameters by\ncalling *par()* in a user-defined function, they are changed permanently\noutside of the function. One trick is as follows:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(){\n  oldpar <- par()\n  par(cex = 2)\n          \n  # body of code\n\n  par() <- oldpar\n}\n```\n:::\n\n\nNote that changing graphics parameters within a specific plotting\nfunction - e.g., `plot(x, y, pch = '+')`, doesn't change things except\nfor that particular plot.\n\n> **Challenge**\n> What are some other functions that are called for the purpose of the side effects they produce? (For example, which functions change the state of your R session in some way?\n\n### Functions are first-class objects\n\nEverything in R is an object, including functions. We can assign\nfunctions to variables in the same way we assign numeric and other\nvalues.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 3\nclass(x); typeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\ntry(x(2))    # x is not a function (yet)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nError in x(2) : could not find function \"x\"\n```\n:::\n\n```{.r .cell-code}\nx <- function(z) z^2  # now it is a function\nx(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\nclass(x); typeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"function\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"closure\"\n```\n:::\n:::\n\n\n\nWe can call a function based on the text name of the function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyFun <- 'mean'; x <- rnorm(10)\neval(as.name(myFun))(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.347\n```\n:::\n:::\n\n\n\nWe can also pass a function into another function as the actual function\nobject. This is an important aspect of R being a functional programming language.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(10)\nsapply(x, abs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.636 0.462 1.432 0.651 0.207 0.393 0.320 0.279 0.494 0.177\n```\n:::\n\n```{.r .cell-code}\nf <- function(fxn, x) {\n    fxn(x)\n}\nf(mean, x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.12\n```\n:::\n:::\n\n\n\nWe can also pass in a function based on a a character vector of length\none with the name of the function. Here *match.fun()* is a handy\nfunction that extracts a function when the function is passed in as an\nargument of a function. It looks in the calling environment for the\nfunction and can handle when the function is passed in as a function\nobject or as a character vector of length 1 giving the function name.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(fxn, x){\n  match.fun(fxn)(x) \n}\nf(\"mean\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.12\n```\n:::\n\n```{.r .cell-code}\nf(mean, x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.12\n```\n:::\n:::\n\n\n\n\nFunction objects contain three components: an argument list, a body (a\nparsed R statement), and an environment.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf1 <- function(x) y <- x^2\nf2 <- function(x) {\n    y <- x^2\n    z <- x^3\n    return(list(y, z))\n}\nclass(f1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"function\"\n```\n:::\n\n```{.r .cell-code}\nbody(f2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{\n    y <- x^2\n    z <- x^3\n    return(list(y, z))\n}\n```\n:::\n\n```{.r .cell-code}\ntypeof(body(f1)); class(body(f1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"language\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"<-\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(body(f2)); class(body(f2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"language\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"{\"\n```\n:::\n:::\n\n\n\nWe'll see more about objects relating to the R language and parsed code\nin the final section of this Unit. For now, just realize that the parsed\ncode itself is treated as an object(s) with certain types and certain\nclasses.\n\n\nThe *do.call* function is another example of a function that takes a function as an argument.\nIt will apply a function to the elements of a\nlist. For example, we can `rbind()` together (if compatible) the\nelements of a list of vectors instead of having to loop over the\nelements or manually type them in:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyList <- list(a = 1:3, b = 11:13, c = 21:23)\nargs(rbind)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (..., deparse.level = 1) \nNULL\n```\n:::\n\n```{.r .cell-code}\nrbind(myList$a, myList$b, myList$c)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]   11   12   13\n[3,]   21   22   23\n```\n:::\n\n```{.r .cell-code}\nrbind(myList)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       a         b         c        \nmyList integer,3 integer,3 integer,3\n```\n:::\n\n```{.r .cell-code}\ndo.call(rbind, myList)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [,1] [,2] [,3]\na    1    2    3\nb   11   12   13\nc   21   22   23\n```\n:::\n:::\n\n\n\nWhy couldn't we just use *rbind* directly? Basically we're using\n`do.call()` to use functions that take `...` as input (i.e., functions\naccepting an arbitrary number of arguments) and to use the list as the\ninput instead (i.e., to use the list elements).\n\nMore generally *do.call* is a way to pass arguments to a function when \nthe arguments you want to pass are part of a list.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndo.call(mean, list(1:10, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.5\n```\n:::\n:::\n\n\n\n\n### All operations are functions\n\nAll operations in R are actually function calls, even things that don't look like function calls,\nincluding various operators (such as addition,\nsubtraction, etc.), printing to the screen, etc.\n\n#### Operators\n\nOperators, such as `+` and `[` are just functions, but their arguments\ncan occur both before and after the function call:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 7; b <- 3\n# let's think about the following as a mathematical function\n#  -- what's the function call?\na + b \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n\n```{.r .cell-code}\n`+`(a, b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n:::\n\n\n\nIn general, you can use back-ticks to refer to the operators as\noperators instead of characters. In some cases single or double quotes\nalso work. We can look at the code of an operator as follows using\nback-ticks to escape out of the standard R parsing, e.g., \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n`%*%`\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, y)  .Primitive(\"%*%\")\n```\n:::\n:::\n\n\n\nFinally, since an operator is just a function, you can use it as an\nargument in various places:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:3; y <- c(100,200,300)\nouter(x, y, `+`)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]  101  201  301\n[2,]  102  202  302\n[3,]  103  203  303\n```\n:::\n\n```{.r .cell-code}\nmyList <- list(list(state = 'new york', value = 1:5),\n               list(state = 'california', value = 6:10),\n               list(state = 'delaware', value = 11:15))\n\n## note that the index \"2\" is the additional argument to the [[ function\nresult <- lapply(myList, `[[`, 2)\nresult\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\n[1]  6  7  8  9 10\n\n[[3]]\n[1] 11 12 13 14 15\n```\n:::\n\n```{.r .cell-code}\nmyMat <- sapply(myList, `[[`, 2)\nmyMat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    6   11\n[2,]    2    7   12\n[3,]    3    8   13\n[4,]    4    9   14\n[5,]    5   10   15\n```\n:::\n\n```{.r .cell-code}\ncbind(myList[[1]][[2]], myList[[2]][[2]])  ## equivalent but doesn't scale\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    6\n[2,]    2    7\n[3,]    3    8\n[4,]    4    9\n[5,]    5   10\n```\n:::\n:::\n\n\n\nYou can define your own *binary* operator (an operator taking two\narguments) using a string inside *%* symbols. Here's how we could do\nPython-style string addition:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n`%+%` <- function(a, b) paste0(a, b, collapse = '')\n\"Hi \" %+% \"there\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hi there\"\n```\n:::\n:::\n\n\n\nSince operators are just functions, there are cases in which there are\noptional arguments that we might not expect. Here's how to pass a\nsometimes useful argument to the bracket operator (in this case avoiding\nconversion from a matrix to a vector, which can mess up subsequent\ncode).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- matrix(1:4, 2, 2)\nmat[ , 1] \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2\n```\n:::\n\n```{.r .cell-code}\nmat[ , 1, drop = FALSE] # what's the difference?\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]\n[1,]    1\n[2,]    2\n```\n:::\n:::\n\n\n\nWe can also use operators with our S3 classes. Picking up our example\nfrom our discussion of S3 OOP, the following example will be a bit silly\n(it would make more sense with a class that is a mathematical object)\nbut indicates the power of having methods.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyog <- list(firstname = 'Yogi', surname = 'the Bear', age = 20)\nclass(yog) <- 'bear' \n\nmethods(`+`)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] +,dgTMatrix,dgTMatrix-method +,Matrix,missing-method     \n [3] +,matrix,spam-method         +,spam,matrix-method        \n [5] +,spam,missing-method        +,spam,spam-method          \n [7] +.Date                       +.gg*                       \n [9] +.glue*                      +.POSIXt                    \n[11] +.vctrs_vctr*               \nsee '?methods' for accessing help and source code\n```\n:::\n\n```{.r .cell-code}\n`+.bear` <- function(object, incr) {\n\tobject$age <- object$age + incr\n\treturn(object)\n}\nolder_yog <- yog + 15\n\nolder_yog\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$firstname\n[1] \"Yogi\"\n\n$surname\n[1] \"the Bear\"\n\n$age\n[1] 35\n\nattr(,\"class\")\n[1] \"bear\"\n```\n:::\n:::\n\n\n\n#### Other operations that are functions\n\nEven beyond operators, all code in R can be viewed as a function call, including\nif statements and for and while loops.\n\nWhat do you think is the functional version of the following code? What\nare the arguments?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif(x > 27){\n\tprint(x)\t\n} else{\n\tprint(\"too small\") \n}\n```\n:::\n\n\n\n#### Replacement functions\n\nAssignments that involve functions or operators on the left-hand side\n(LHS) are called *replacement expressions* or *replacement functions.*\nThese can be quite handy. Here are a few examples:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiag(mat) <- c(3, 2)\nis.na(vec) <- 3\nnames(df) <- c('var1', 'var2')\n```\n:::\n\n\n\nReplacement expressions are actually function calls. The R interpreter\ncalls the replacement function (which often creates a new object that\nincludes the replacement) and then assigns the result to the name of the\noriginal object.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- matrix(rnorm(4), 2, 2)\ndiag(mat) <- c(3, 2)\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]   [,2]\n[1,] 3.00 -0.215\n[2,] 1.34  2.000\n```\n:::\n\n```{.r .cell-code}\nmat <- `diag<-`(mat, c(10, 21))\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1]   [,2]\n[1,] 10.00 -0.215\n[2,]  1.34 21.000\n```\n:::\n\n```{.r .cell-code}\nbase::`diag<-`\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, value) \n{\n    dx <- dim(x)\n    if (length(dx) != 2L) \n        stop(\"only matrix diagonals can be replaced\")\n    len.i <- min(dx)\n    len.v <- length(value)\n    if (len.v != 1L && len.v != len.i) \n        stop(\"replacement diagonal has wrong length\")\n    if (len.i) {\n        i <- seq_len(len.i)\n        x[cbind(i, i)] <- value\n    }\n    x\n}\n<bytecode: 0x562ade911d88>\n<environment: namespace:base>\n```\n:::\n:::\n\n\n\nThe old version of *mat* still exists until R's memory management cleans\nit up, but it's no longer referred to by the symbol *mat*.\nThis can cause memory use to increase temporarily (but generally very briefly).\nSo it's something to keep in mind if you're doing replacements on large objects.\n\nYou can define your own replacement functions like this, with the\nrequirements that the last argument be named `value` and that the\nfunction return the entire object:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyog <- list(firstName = 'Yogi', lastName = 'Bear')\n\n`firstName<-` <- function(obj, value){\n  obj$firstName <- value\n  return(obj)\n}\n\nfirstName(yog) <- 'Yogisandra'\n```\n:::\n\n\n\nWe can use replacement functions with functional OOP. We need to define the generic\nreplacement function and then the class-specific one.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n`age<-` <- function(x, ...) UseMethod(\"age<-\")\n\n`age<-.bear` <- function(object, value){ \n\tobject$age <- value\n\treturn(object)\n}\nage(older_yog) <- 60\n\nolder_yog\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$firstname\n[1] \"Yogi\"\n\n$surname\n[1] \"the Bear\"\n\n$age\n[1] 60\n\nattr(,\"class\")\n[1] \"bear\"\n```\n:::\n:::\n\n\n\n### Map operations\n\nA *map* operation takes a function and runs the function on each element of some collection of items,\nanalogous to a mathematical map.\nThis kind of operation is very commonly used in programming, particularly functional programming,\nand often makes for clean, concise, and readable code.\n\nBase R provides a variety of map-type functions: *lapply* and *sapply* and their variants, as well as *apply*.\nIn addition, the *purrr* package for functional programming provides `purrr::map`.\nIn R, often the map-type function is run on the elements of a list, but they can also generally be run on elements of a vector and in other ways. In other languages, map-type functions are run on a variety of data structures. \nThese are  examples of higher-order functions -- functions that take a function as an argument.\n\nLet's compare using *lapply* to using a for loop to run a stratified analysis for a generic example (this code won't run because the variables don't exist):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# stratification \nsubsets <- split(df, grouping_variable)\n\n# lapply: one line, easy to understand\nresults <- lapply(subsets, analysis_function)\n\n# for loop: needs storage set up and multiple lines\nresults <- list()\nlength(results) <- length(subsets)\nfor(i in seq_along(subsets)) \n  results[[i]] <- analysis_function(subsets[[i]])\n```\n:::\n\n\n\nMap operations are also at the heart of the famous map-reduce paradigm, used in Hadoop and Spark for big data processing. \n\n## Function evaluation, frames, and the call stack\n\n### Overview\n\nWhen we run code, we end up calling functions inside of other function calls.\nThis leads to a nested series of function calls. The series of calls is the *call stack*.\nThe stack operates like a stack of cafeteria trays - when a\nfunction is called, it is added to the stack (pushed) and when it\nfinishes, it is removed (popped).\n\nUnderstanding the series of calls is important when reading error messages and debugging.\nIn Python, when an error occurs, the call stack is shown, which has the advantage of\ngiving the complete history of what led to the error and the disadvantage of producing\noften very verbose output that can be hard to understand. In R, only the function in which\nthe error occurs is shown, but you can see the full call stack by invoking `traceback()` (see the [debugging tutorial](https://github.com/berkeley-scf/tutorial-R-debugging)).\n\nWhat happens when an R function is evaluated? \n\n  - The user-provided function arguments are evaluated in the calling environment and the results are\nmatched to the argument names in the function definition. \n  - A new environment with its own frame is created, with the frame on the call stack. Assignment to the argument names is done in the environment, including any default arguments. \n  - The body of the function is evaluated in the environment. Any look-up of variables not found in the\nenvironment is done using R's lexical scoping rules to look in the\nseries of enclosing environments. \n  - When the function finishes, the return\nvalue is passed back to the calling frame and the function frame is\ntaken off the stack. The environment is removed, unless the environment\nserves as the enclosing environment of another environment.\n\nI'm not expecting you to fully understand that previous paragraph and\nall the terms in it yet. We'll see all the details as we proceed through this Unit.\n\n### Frames and the call stack\n\nR keeps track of the call stack. Each function call is associated with\na *frame* that contains the local variables for that function call.\n\nThere are a bunch of functions that let us query what frames are on the\nstack and access objects in particular frames of interest. This gives us\nthe ability to work with objects in the frame from which a function was\ncalled.\n\nSome terminology: for our purposes we'll use the terms *frame* and\n*environment* somewhat interchangeably for the moment. A *frame* or\n*environment* is a collection of named objects. (Note that when we talk\nabout variable scope later in this Unit, we'll have to be more careful with\nour terminology.) So in the context of a function call, the frame is the\nset of local variables available in the function, including arguments\npassed to the function.\n\nR provides some functions that allow you to query the call stack and its frames.\n*sys.nframe* returns the number of the current frame/environment and\n*sys.parent* the number of the parent, while *parent.frame* gives\nthe name of the frame/environment of the parent (i.e., the calling)\nframe. *sys.frame* gives the name of the frame/environment for a given\nframe number (for non-negative numbers). For negative numbers, it goes\nback that many frames in the call stack and returns the name of the\nframe/environment. I need to manually insert the output here because the R Markdown processing\nup the frame counting somehow.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsys.nframe()\nf <- function() {\n\tcat('in f: Frame number is ', sys.nframe(),\n            '; parent frame number is ', sys.parent(), '.\\n', sep = '')\n\tcat('in f: Frame (i.e., environment) is: ')\n\tprint(sys.frame(sys.nframe()))\n\tcat('in f: Parent is ')\n\tprint(parent.frame())\n\tcat('in f: Two frames up is ')\n\tprint(sys.frame(-2))\n}\nf()\n```\n:::\n\n\n\n```\nin f: Frame number is 1; parent frame number is 0.\nin f: Frame (i.e., environment) is: <environment: 0x55a4d71beb88>\nin f: Parent is <environment: R_GlobalEnv>\nin f: Two frames up is Error in sys.frame(-2) : not that many frames on the stack\n```\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nff <- function() {\n\tcat('in ff: Frame (i.e., environment) is: ')\n\tprint(sys.frame(sys.nframe()))\n\tcat('in ff: Parent is ')\n\tprint(parent.frame())\t\n\tf()\n}\nff() \n```\n:::\n\n\n\n```\nin ff: Frame (i.e., environment) is: <environment: 0x55a4d7391700>\nin ff: Parent is <environment: R_GlobalEnv>\nin f: Frame number is 2; parent frame number is 1.\nin f: Frame (i.e., environment) is: <environment: 0x55a4d7393b38>\nin f: Parent is <environment: 0x55a4d7391700>\nin f: Two frames up is <environment: R_GlobalEnv>\n```\n\nNext we'll use a recursive function to illustrate what information we can gather\nabout the call stack using *sys.status*. *sys.status* gives extensive information about the call\nstack and the frames involved (*sys.status* uses *sys.calls*,\n*sys.parents* and *sys.frames*).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- function(y) {\n    if(y > 0) g(y-1) else gg()\n}\n\n## Ultimately, gg() is called, and it prints out info about the call stack\ngg <- function() {\n    ## this gives us the information from sys.calls(),\n    ##   sys.parents() and sys.frames() as one object\n    ## Rather than running print(sys.status()),\n    ## which would involve adding print() to the call stack,\n    ## we'll run sys.status and then print the result out.\n    tmp <- sys.status()\n    print(tmp)\n}\n\ng(3)\n```\n:::\n\n\n\n```\n$sys.calls\n$sys.calls[[1]]\ng(3)\n\n$sys.calls[[2]]\nif(y > 0) g(y-1) else gg()\n\n$sys.calls[[3]]\nif(y > 0) g(y-1) else gg()\n\n$sys.calls[[4]]\nif(y > 0) g(y-1) else gg()\n\n$sys.calls[[5]]\nif(y > 0) g(y-1) else gg()\n\n$sys.calls[[6]]\ntmp <- sys.status()\n\n\n$sys.parents\n[1] 0 1 2 3 4 5\n\n$sys.frames\n$sys.frames[[1]]\n<environment: 0x55a4d63479e8>\n\n$sys.frames[[2]]\n<environment: 0x55a4d6347ba8>\n\n$sys.frames[[3]]\n<environment: 0x55a4d5736638>\n\n$sys.frames[[4]]\n<environment: 0x55a4d5732028>\n\n$sys.frames[[5]]\n<environment: 0x55a4d5732098>\n\n$sys.frames[[6]]\n<environment: 0x55a4d5732488>\n```\n\n> **Challenge**\n> Why did I not do `print(sys.status())` directly?\n\nIf you're interested in parsing a somewhat complicated example of frames\nin action, Adler provides a user-defined timing function that evaluates\nstatements in the calling frame.\n\n## Function inputs and outputs \n\n### Arguments\n\nArguments can be specified by position (based on the order of the inputs)\nor by name, using `name = value`. R first tries to match arguments by name and\nthen by position. In general the more important arguments are specified\nfirst. You can see the arguments and defaults for a function using\n*args*:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nargs(lm)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (formula, data, subset, weights, na.action, method = \"qr\", \n    model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, \n    contrasts = NULL, offset, ...) \nNULL\n```\n:::\n:::\n\n\n\nYou can't generally tell directly which arguments are required; in\ngeneral you'd need to look at the documentation. For example,\n`lm()` requires `formula` but not `data`, `subset`, etc., even though\nnone of them have default arguments.\n\nR will error out if it\nis expecting an argument, rather than looking for that argument\nelsewhere.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (..., na.rm = FALSE)  .Primitive(\"sum\")\n```\n:::\n\n```{.r .cell-code}\nsum()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\nprint(quantile)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, ...) \nUseMethod(\"quantile\")\n<bytecode: 0x562ad85891b8>\n<environment: namespace:stats>\n```\n:::\n\n```{.r .cell-code}\ntry(quantile())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nError in is.factor(x) : argument \"x\" is missing, with no default\n```\n:::\n\n```{.r .cell-code}\nx <- 1\ny <- 2\nmyfun <- function(x) {\n    z <- y+3\n    w <- x+3\n}\ntry(myfun())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nError in myfun() : argument \"x\" is missing, with no default\n```\n:::\n:::\n\n\n\nYou can check if an argument is missing with `missing()`. Arguments can\nalso have default values, which may be `NULL`. If you are writing a\nfunction and designate the default as `argname = NULL`, you can check\nwhether the user provided anything using `is.null(argname)`. The default\nvalues can also relate to other arguments. As an example, consider\n*dgamma*:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nargs(dgamma)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, shape, rate = 1, scale = 1/rate, log = FALSE) \nNULL\n```\n:::\n:::\n\n\n\nFunctions may have unspecified arguments, which are designated using\n`...`. Unspecified arguments occurring at the beginning of the argument\nlist are generally a collection of like objects that will be manipulated\n(consider *paste*, *c*, and *rbind*), while unspecified arguments\noccurring at the end are often optional arguments (consider *plot*).\nThese optional arguments are sometimes passed along to a function within\nthe function. For example, here's my own wrapper for plotting, where any\nadditional arguments specified by the user (such as `xlab` and `ylab`) will get passed along to\nplot:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npplot <- function(x, y, pch = 16, cex = 0.4, ...) {\n\tplot(x, y, pch = pch, cex = cex, ...)\n}\npplot(rnorm(10), rnorm(10), xlab = 'x', ylab = 'y')\n```\n:::\n\n\n\nIf you want to manipulate what the user passed in as the `...` args,\nrather than just passing them along, you can extract them:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyFun <- function(...){\n  print(..2) \n  args <- list(...)\n  print(args[[2]])\n}\nmyFun(1,3,5,7)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n[1] 3\n```\n:::\n:::\n\n\n\n\nAs we've seen, functions can be passed in as arguments (e.g., see the\nvariants of *apply* and *lapply*). Note that one does not need to pass in a named\nfunction - you can create the function on the spot - this is called an\n*anonymous function* (also called a *lambda function* in some languages\nsuch as Python):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmylist <- list(rnorm(2), rnorm(3), rnorm(5))\nsapply(mylist, length)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3 5\n```\n:::\n\n```{.r .cell-code}\nlapply(mylist, function(x) x[x < 0])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] -0.1\n\n[[2]]\n[1] -0.0736 -0.0376 -0.6817\n\n[[3]]\n[1] -0.324 -0.589 -1.518\n```\n:::\n:::\n\n\n\nWe can see the arguments using `args()` and extract the arguments using\n`formals()`. `formals()` can be helpful if you need to manipulate the\narguments.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(x, y = 2, z = 3 / y) { \n  x + y + z \n}\nargs(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, y = 2, z = 3/y) \nNULL\n```\n:::\n\n```{.r .cell-code}\nformals(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$x\n\n\n$y\n[1] 2\n\n$z\n3/y\n```\n:::\n:::\n\n\n\n*match.call()* will show the user-suppled arguments explicitly matched\nto named arguments.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatch.call(definition = mean, \n  call = quote(mean(y, na.rm = TRUE))) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nmean(x = y, na.rm = TRUE)\n```\n:::\n:::\n\n\n\n> **Challenge**\n> In the above code, what do you think `quote()`does? Why is it needed?\n\n#### Where are arguments evaluated?\n\nUser-supplied arguments are evaluated in the calling frame (why?), while\ndefault arguments are evaluated in the frame of the function (why?):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- 3\nx <- 100\nf <- function(x, y = x*3) {x+y}\nf(z*5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 60\n```\n:::\n:::\n\n\n\nHere, when `f()` is called and the code is evaluated, `z` is evaluated in the calling frame\nand `z*5` is assigned to `x` in the frame of the function, while `x*3`\nis evaluated in the frame of the function (using the local `x` that was just created) and assigned to `y`.\n\n### Function outputs\n\n`return(x)` will specify `x` as the output of the function. By default,\nif `return()` is not specified, the output is the result of the last\nevaluated statement. `return()` can occur anywhere in the function, and\nallows the function to exit as soon as it is done.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(x) { \n    if(x < 0) {\n        return(-x^2)\n    } else res <- x^2\n}\nf(-3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -9\n```\n:::\n\n```{.r .cell-code}\nf(3)\na <- f(3)\na\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 9\n```\n:::\n:::\n\n\n\n`invisible(x)` will return `x` and the result can be assigned in the\ncalling environment but it will not be printed if not assigned:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(x){ \n  invisible(x^2) \n}\nf(3)\na <- f(3)\na\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 9\n```\n:::\n:::\n\n\n\nA function can only return a single object (unlike Matlab, e.g.), but of\ncourse we can tack things together as a list and return that, as occurs with many functions, such as \n*lm*. (Of course `lm()` actually returns an object of the S3 `lm` class, which inherits from the list class.)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod <- lm(mpg ~ cyl, data = mtcars)\nclass(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"lm\"\n```\n:::\n\n```{.r .cell-code}\nis.list(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n\n## Pass by value vs. pass by reference\n\nWhen talking about programming languages, one often distinguishes\n*pass-by-value* and *pass-by-reference*. \n\n*Pass-by-value* means that when a\nfunction is called with one or more arguments, a copy is made of each\nargument and the function operates on those copies. \n\n*Pass-by-reference*\nmeans that the arguments are not copied, but rather that information is\npassed allowing the function to find and modify the original value of\nthe objects passed into the function. \n\nIn pass-by-value, changes to an\nargument made within a function do not affect the value of the argument\nin the calling environment. In pass-by-reference changes inside a\nfunction do affect the object outside of the function. R is (roughly)\npass-by-value. R's designers chose not to allow pass-by-reference\nbecause they didn't like the idea that a function could have the side\neffect of changing an object. However, passing by reference can\nsometimes be very helpful, and we'll see ways of passing by reference\nlater (and also note our discussion of R6 classes).\n\nPass-by-value is elegant and modular in that functions do not have side\neffects - the effect of the function occurs only through the return\nvalue of the function. However, it can be inefficient in terms of the\namount of computation and of memory used. In contrast, pass-by-reference\nis more efficient, but also more dangerous and less modular. It's more\ndifficult to reason about code that uses pass-by-reference because\neffects of calling a function can be hidden inside the function.\nThus pass-by-value is directly related to functional programming.\n\nArrays in Python are pass-by-reference (but note that tuples are immutable, \nso one could not modify a tuple that is passed as an argument).\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef myfun(x):\n    x[1] = 99\n\ny = [0, 1, 2]\nz = myfun(y)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0, 99, 2]\n```\n:::\n:::\n\n\n\n### Pointers \n\nBy way of contrast to a pass-by-value system, I want to briefly discuss\nthe idea of a pointer, common in compiled languages such as C.\n\n```\nint x = 3;\nint* ptr;\nptr = &x;\n*ptr * 7; // returns 21\n```\n\n  - The `int*` declares `ptr` to be a pointer to (the address of) the integer `x`.\n  - The `&x` gets the address where `x` is stored.\n  - `*ptr` dereferences `ptr`, returning the value in that address (which is 3 since `ptr` is the address of `x`.\n\nVectors in C are really pointers to a block of memory:\n\n```\nint x[10];\n```\n\nIn this case `x` will be the address of the first element of the vector.\nWe can access the first element as `x[0]` or `*x`.\n\nWhy have we gone into this? In C, you can pass a pointer as an argument\nto a function. The result is that only the scalar address is copied and\nnot the entire object, and inside the function, one can modify the\noriginal object, with the new value persisting on exit from the\nfunction. For example in the following example one passes in the address of an\nobject and that object is then modified in place, affecting its value when the function\ncall finishes.\n\n```\nint myCal(int* ptr){\n    *ptr = *ptr + *ptr;\n}\n\nmyCal(&x)  # x itself will be modified\n```\n\n> **Note** When calling C or C++ from R, one (implicitly) passes pointers to the vectors into C. \n\n\n### Pointers in R?\n\nAre there pointers in R? From a user perspective, one might say 'no',\nbecause an R programmer can't use pointers explicitly. But pointer-like\nbehavior is occurring behind the scenes in lots of ways:\n\n  -   Lists in R are essentially vectors of pointers to the elements of the list.\n  -   Character vectors in R are essentially pointers to the individual character strings.\n  -   Environments behave like pointers and are passed by reference rather than by copy.\n  -   R6 objects behave like pointers and are passed by reference, as seen earlier.\n\nWe'll see more on these ideas later in the Unit.\n\n### Alternatives to pass by value in R\n\nThere are occasions we do not want to pass by value. In addition to\navoiding copies and the  computation and memory use that that causes, another\nreason is when we want a function to modify a complicated object without\nhaving to return it and re-assign it in the parent environment. There\nare several work-arounds:\n\n1.  We can use R6 (or Reference Class) objects.\n2.  We can use a *closure*, as discussed later.\n3.  We can access the object in the enclosing environment as a 'global\n    variable', as we'll see when  discussing scoping. More generally we\n    can access the object using `get()`, specifying the environment from\n    which we want to obtain the variable. To specify the location of an\n    object when using `get()`, we can generally specify (1) a position\n    in the search path, (2) an explicit environment, or (3) a location\n    in the call stack by using `sys.frame()`. However we cannot change\n    the value of the object in the parent environment without some\n    additional tools:\n    a.  We can use the `<<-` operator to assign into an object in the\n        enclosing environment (provided an object of that name exists in\n        the enclosing environment). We'll discuss enclosing environments when we talk about scoping.\n    b.  We can also use `assign()`, specifying the environment in which\n        we want the assignment to occur.\n    While these techniques are possible and ok for exploratory coding,\n    they're generally bad practice for more formal code development.\n4.  We can use replacement functions, which hide the\n    reassignment in the parent environment from the user. Note that a\n    second copy is generally created in this case, but the original copy\n    is quickly removed.\n\n### Promises and lazy evaluation\n\nIn actuality, R is not quite pass-by-value; rather it is\n*call-by-value*. Copying of arguments is delayed in two ways:\n\n  - The first is the idea of *promises*, described next. Promises are an example of a general programming concept called *lazy evaluation*.\n  - The second is the idea of *copy-on-modify*, described in more detail later. Basically, with copy-on-modify,\ncopies of arguments are only made if the argument is changed within the\nfunction. Until then the object in the function just refers back to the\noriginal object.\n\nLet's see what a *promise* object is. In function calls, when R matches\nuser input arguments to formal argument names, it does not (usually)\nevaluate the arguments until they are needed, which is called *lazy\nevaluation*. Instead the formal arguments are of a special type called a\n*promise*. Let's see lazy evaluation in action. \n\nWhat's strange about this?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(x) print(\"hi\")\nsystem.time(mean(rnorm(1000000)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.062   0.000   0.062 \n```\n:::\n\n```{.r .cell-code}\nsystem.time(f(3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"hi\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n      0       0       0 \n```\n:::\n\n```{.r .cell-code}\nsystem.time(f(mean(rnorm(1000000)))) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"hi\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.001   0.000   0.001 \n```\n:::\n:::\n\n\n\nHere's an even stranger situation. Do you think the\nfollowing code will run?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(a, b = d) {\n\td <- a*3; \n\treturn(a*b)\n}\n\nb <- 100\nf(5)\n```\n:::\n\n\n\n\nLazy evaluation is not just an R thing. It also occurs in Tensorflow (particularly version 1),\nthe Python Dask package, and in Spark. The basic idea is to delay executation until\nit's really needed, with the goal that if one does so, the system may be\nable to better optimize a series of multiple steps as a joint operation\nrelative to executing them one by one.\n\n\n\n## Variable scope and lookup\n\n### Lexical scoping\n\nIn this section, we seek to understand what happens in the following\ncircumstance. Namely, where does R get the value for the object `x`?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(y) {\n  return(x + y)\n}\nf(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 103\n```\n:::\n:::\n\n\n\nTo consider variable scope, we need to define the terms *environment*\nand *frame*. Environments and frames are closely related.\n\n  -   A *frame* is a collection of named objects.\n  -   An *environment* is a frame, with a pointer to the 'enclosing\n    environment', i.e., the next environment to look for something in.\n    (Be careful as this is different than the parent frame of a\n    function, discussed when we were talking about the call stack.)\n\nVariables in the enclosing environment (also called the parent\nenvironment) are available within a function. This is the analog of\n*global variables* in other languages. **The enclosing environment is the\nenvironment in which a function is defined, not the environment from\nwhich a function is called.**\n\nThis approach is called *lexical scoping*. Python and many other languages\nalso use lexical scoping.\n\n\nWhy is the enclosing environment defined in this way? Recall our example where\nI tried to break the usage of the *lm* function by redefining *lm.fit*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm.fit <- function(x) print('hi')\ny <- rnorm(10)\nx <- rnorm(10)\nmod <- lm(y~x)  # this still works!\n```\n:::\n\n\n\nWhen R looks for `lm.fit` when it is called within `lm`, it looks in the enclosing\nenvironment of `lm`. That is where `lm` is defined, which is the stats package namespace.\nIt finds `lm.fit` there. All is well! In contrast, if the scoping rules looked for `lm.fit`\nwhere `lm` was called from, then the user-defined `lm.fit` would be found and `lm()`\nwould not work until that `lm.fit` was removed. That would be a very fragile system!\n\n\nLet's dig deeper to understand where R looks for non-local variables, illustrating lexical scoping:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 3\nf2 <- function() print(x)\nf <- function() {\n    x <- 7\n    f2()\n}\nf() # what will happen?\n\nx <- 3\nf2 <- function() print(x)\nf <- function() {\n    x <- 7\n    f2()\n}\nx <- 100\nf() # what will happen?\n\nx <- 3\nf <- function() {\n    f2 <- function() { print(x) }\n    x <- 7\n    f2()\n}\nf() # what will happen?\n\nx <- 3\nf <- function() { \n    f2 <- function() { print(x) }\n    f2()\n} \nf() # what will happen?\n```\n:::\n\n\n\nHere's a tricky example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- 100\nfun_constructor <- function(){\n\ty <- 10\n\tg <- function(x) {\n            return(x + y)\n        }\n\treturn(g)\n}\n## fun_constructor() creates functions\nmyfun <- fun_constructor()\nmyfun(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 13\n```\n:::\n:::\n\n\n\nLet's work through this:\n\n1.  What is the enclosing environment of the function *g()*?\n2.  What does *g()* use for *y*?\n3.  When *fun_constructor()* finishes, does its environment disappear?\n    What would happen if it did?\n4.  What is the enclosing environment of *myfun()*?\n\nThe following code helps explain things, but it's a bit confusing because\n`environment()` gives back different results depending on whether it is\ngiven a function as its argument. If given a function, it returns the\nenclosing environment for that function. If given no argument, it\nreturns the current execution environment.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenvironment(myfun)  # enclosing environment of h()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<environment: 0x562ae2d47428>\n```\n:::\n\n```{.r .cell-code}\nls(environment(myfun)) # objects in that environment\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"g\" \"y\"\n```\n:::\n\n```{.r .cell-code}\nfun_constructor <- function(){\n\tprint(environment()) # execution environment of fun_constructor()\n\ty <- 10\n\tg <- function(x) x + y\n\treturn(g)\n}\nmyfun <- fun_constructor()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<environment: 0x562ae2555de0>\n```\n:::\n\n```{.r .cell-code}\nenvironment(myfun)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<environment: 0x562ae2555de0>\n```\n:::\n\n```{.r .cell-code}\nmyfun(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 13\n```\n:::\n\n```{.r .cell-code}\nenvironment(myfun)$y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n\n```{.r .cell-code}\n## advanced: explain this:\nenvironment(myfun)$g\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction(x) x + y\n<environment: 0x562ae2555de0>\n```\n:::\n:::\n\n\n\nBe careful when using variables from the enclosing environment as the\nvalue of that variable in the enclosing environment may well not be what\nyou expect it to be. In general it's bad practice to use variables that\nare taken from environments outside that of a function, but in some\ncases it can be useful. Here are some examples of using variables\noutside of the frame of a function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 3\nf <- function() {x <- x^2; print(x)}\nf()\nx # what do you expect?\nf <- function() { assign('x', x^2, env = .GlobalEnv) } \n## careful: could be dangerous as a variable is changed as a side effect\nf()\nx\nf <- function(x) { x <<- x^2 }\n## careful: could be dangerous as a variable is changed as a side effect\nf(5)\nx\n```\n:::\n\n\n\n#### Comprehension problem\n\nHere's a case where something I tried failed and I had to think more\ncarefully about scoping to understand why.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1) \nrnorm(1) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.626\n```\n:::\n\n```{.r .cell-code}\nsave(.Random.seed, file = 'tmp.Rda') \nrnorm(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.184\n```\n:::\n\n```{.r .cell-code}\ntmp <- function() { \n  load('tmp.Rda') \n  print(rnorm(1)) \n}\ntmp()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.836\n```\n:::\n:::\n\n\n\nQuestion: what was I hoping that code to do, and why didn't it work?\n\n#### Detecting non-local variables {#detecting-non-local-variables .unnumbered}\n\nWe can use `codetools::findGlobals()` to detect non-local variables when\nwe are programming.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function() {\n    y <- 3\n    print(x + y)\n}\ncodetools::findGlobals(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"{\"     \"+\"     \"<-\"    \"print\" \"x\"    \n```\n:::\n:::\n\n\n\nIs that result what you would expect? What does it say about my\nstatement that using non-local variables is a bad idea?\n\n### Closures\n\nOne way to avoid passing data by value is to associate data with a\nfunction, using a *closure*. This is a functional programming way to\nachieve something like an OOP class. This [Wikipedia\nentry](https://en.wikipedia.org/wiki/Closure_(computer_programming))\nnicely summarizes the idea, which is a general functional programming idea and not specific to R. \n\nUsing a closure\ninvolves creating one (or more functions) within a function call and\nreturning the function(s) as the output. When one executes the original\nfunction, the new function(s) is created and returned and one can then\ncall that new function(s). The new function then can access objects in\nthe enclosing environment (the environment of the original function) and\ncan use `<<-` to assign into the enclosing environment, to which the\nfunction (or the multiple functions) have access. The nice thing about\nthis compared to using a global variable is that the data in the closure\nis bound up with the function(s) and is protected from being changed by\nthe user of the closure. Chambers provides an example of this in Sec.\n5.4.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(10)\nscaler_constructor <- function(input){\n\tdata <- input\n\tg <- function(param) return(param * data) \n\treturn(g)\n}\nscaler <- scaler_constructor(x)\nrm(x) # to demonstrate we no longer need x\nscaler(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  4.786  0.989 -2.461  1.462  2.215  1.727 -0.916  4.535  1.170 -1.864\n```\n:::\n:::\n\n\n\nSo calling `scaler(3)` multiplies 3 by the value of `data` stored in the closure (the enclosing environment) of the function `scaler`.\n\nIt turns out that it can be hard to see the memory used involved in the closure.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(1e7)\nscaler <- scaler_constructor(x)\nobject.size(scaler) # hmmm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3800 bytes\n```\n:::\n\n```{.r .cell-code}\nobject.size(environment(scaler)$data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n80000048 bytes\n```\n:::\n\n```{.r .cell-code}\nlibrary(pryr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'pryr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked _by_ '.GlobalEnv':\n\n    f\n```\n:::\n\n```{.r .cell-code}\nobject_size(scaler) # that's better!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n80,012,560 B\n```\n:::\n:::\n\n\n\nHere's a fun example. You might do this with an *apply* variant, in\nparticular *replicate*, but this is slick:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_container <- function(n) {\n\tx <- numeric(n)\n\ti <- 1\n\t\n\tfunction(value = NULL) {\n\t\tif (is.null(value)) {\n\t\t\treturn(x)\n\t\t} else {\n\t\t\tx[i] <<- value\n\t\t\ti <<- i + 1\n\t\t}\t \n\t}\n}\nnboot <- 100\nbootmeans <- make_container(nboot)\ndata <- faithful[ , 1] # Old Faithful geyser eruption lengths\nfor (i in 1:nboot)\n\tbootmeans(mean(sample(data, length(data),\n      replace=TRUE)))\nbootmeans()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] 3.59 3.41 3.47 3.46 3.43 3.48 3.51 3.48 3.50 3.46 3.41 3.62 3.46 3.46 3.49\n [16] 3.50 3.56 3.50 3.58 3.60 3.46 3.45 3.50 3.41 3.46 3.59 3.35 3.50 3.51 3.37\n [31] 3.46 3.38 3.58 3.52 3.45 3.58 3.50 3.47 3.54 3.57 3.53 3.58 3.40 3.50 3.50\n [46] 3.56 3.41 3.45 3.50 3.53 3.49 3.57 3.46 3.50 3.43 3.48 3.54 3.45 3.53 3.53\n [61] 3.46 3.36 3.41 3.58 3.58 3.47 3.51 3.50 3.56 3.48 3.39 3.48 3.62 3.54 3.51\n [76] 3.52 3.47 3.49 3.43 3.45 3.40 3.52 3.43 3.49 3.51 3.56 3.55 3.46 3.30 3.56\n [91] 3.47 3.49 3.41 3.40 3.46 3.43 3.43 3.44 3.45 3.42\n```\n:::\n:::\n\n\n\n\n\nThe closure stores the bootstrapped values and \n\n### Environments and the search path\n\nSo far we've seen lexical scoping in action primarily in terms of\nfinding variables in a single enclosing environment. But what if the\nvariable is not found in either the frame/environment of the function or\nthe enclosing environment? When R goes looking for an object (in the\nform of a symbol), it starts in the current environment (e.g., the\nframe/environment of a function) and then runs up through the enclosing\nenvironments, until it reaches the global environment, which is where R\nstarts when you open R.\n\nThen, if R can't find the object when reaching the global environment, it runs\nthrough the search path, which you can see with `search()`. The search\npath is a set of additional environments, mainly the namespaces of packages loaded in the R session.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsearch()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \".GlobalEnv\"          \"package:pryr\"        \"package:R6\"         \n [4] \"package:fields\"      \"package:viridis\"     \"package:viridisLite\"\n [7] \"package:spam\"        \"package:dplyr\"       \"package:stringr\"    \n[10] \"tools:quarto\"        \"package:stats\"       \"package:graphics\"   \n[13] \"package:grDevices\"   \"package:utils\"       \"package:datasets\"   \n[16] \"package:SCF\"         \"package:methods\"     \"Autoloads\"          \n[19] \"package:base\"       \n```\n:::\n:::\n\n\n\nWe can see the full set of environments in which R looks using code such as the following.\nThis illustrates that in looking for a local variable\nused in *lm* the search process would go through the stats namespace, the base R namespace,\nthe global environment and then the various packages loaded in the current R session. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- environment(lm)\nwhile (environmentName(x) != environmentName(emptyenv())) {\n\tprint(environmentName(x))\n\tx <- parent.env(x) # enclosing env't, NOT parent frame!\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"stats\"\n[1] \"imports:stats\"\n[1] \"base\"\n[1] \"R_GlobalEnv\"\n[1] \"package:pryr\"\n[1] \"package:R6\"\n[1] \"package:fields\"\n[1] \"package:viridis\"\n[1] \"package:viridisLite\"\n[1] \"package:spam\"\n[1] \"package:dplyr\"\n[1] \"package:stringr\"\n[1] \"tools:quarto\"\n[1] \"package:stats\"\n[1] \"package:graphics\"\n[1] \"package:grDevices\"\n[1] \"package:utils\"\n[1] \"package:datasets\"\n[1] \"package:SCF\"\n[1] \"package:methods\"\n[1] \"Autoloads\"\n[1] \"base\"\n```\n:::\n:::\n\n\n\nThat code uses `environmentName()`, which prints out a nice-looking version of\nthe environment name. \n\n\nHere's an alternative way using *pryr*:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(pryr)\nx <- environment(lm)\nparenvs(x, all = TRUE)  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   label                              name                 \n1  <environment: namespace:stats>     \"\"                   \n2  <environment: 0x562ad6d51f68>      \"imports:stats\"      \n3  <environment: namespace:base>      \"\"                   \n4  <environment: R_GlobalEnv>         \"\"                   \n5  <environment: package:pryr>        \"package:pryr\"       \n6  <environment: package:R6>          \"package:R6\"         \n7  <environment: package:fields>      \"package:fields\"     \n8  <environment: package:viridis>     \"package:viridis\"    \n9  <environment: package:viridisLite> \"package:viridisLite\"\n10 <environment: package:spam>        \"package:spam\"       \n11 <environment: package:dplyr>       \"package:dplyr\"      \n12 <environment: package:stringr>     \"package:stringr\"    \n13 <environment: 0x562ad731b5b8>      \"tools:quarto\"       \n14 <environment: package:stats>       \"package:stats\"      \n15 <environment: package:graphics>    \"package:graphics\"   \n16 <environment: package:grDevices>   \"package:grDevices\"  \n17 <environment: package:utils>       \"package:utils\"      \n18 <environment: package:datasets>    \"package:datasets\"   \n19 <environment: package:SCF>         \"package:SCF\"        \n20 <environment: package:methods>     \"package:methods\"    \n21 <environment: 0x562ad6ab4510>      \"Autoloads\"          \n22 <environment: base>                \"\"                   \n23 <environment: R_EmptyEnv>          \"\"                   \n```\n:::\n:::\n\n\n\nNote that eventually the global environment and the environments of the\npackages are nested within the base environment (of the base package)\nand the empty environment. \n\n\n\n# 8. Memory and copies\n\n## Overview\n\nThe main things to remember when thinking about memory use are: (1)\nnumeric vectors take 8 bytes per element and (2) we need to keep track\nof when large objects are created, including local variables in the\nframes of functions.\n\nIn some of our work here we'll use functions from the *pryr* package,\nwhich provides functions to help understand what is going on under the\nhood in R.\n\n**In general, don't try to run this code within RStudio, as some of how\nRStudio works affects when copies are made. In particular the environment pane\ncauses there to be an additional reference to each object.\n Also, as noted in the document, some of the output in the PDF\n does not reflect  what is happening\nwhen running code directly within R,\nbecause of effects from the process of rendering the document.**\n\n### Allocating and freeing memory\n\nUnlike compiled languages like C, in R we do not need to explicitly\nallocate storage for objects. (However, we will see that there are times\nthat we do want to allocate storage in advance, rather than successively\nconcatenating onto a larger object.)\n\nR automatically manages memory, releasing memory back to the operating\nsystem when it's not needed via garbage collection. Very occasionally\nyou may want to remove large objects as soon as they are not needed.\n`rm()` does not actually free up memory, it just disassociates the name\nfrom the memory used to store the object. In general R will quickly\nclean up such objects without a reference (i.e., a name), so there is generally\nno need to call `gc()` to force\nthe garbage collection. In particular, calling `gc()` uses some computation so it's generally not\nrecommended.\n\nIn a language like C in which the user allocates and frees up memory,\nmemory leaks are a major cause of bugs. Basically if you are looping and\nyou allocate memory at each iteration and forget to free it, the memory\nuse builds up inexorably and eventually the machine runs out of memory.\nIn R, with automatic garbage collection, this is generally not an issue,\nbut occasionally memory leaks do occur.\n\n### The heap and the stack\n\nThe *heap* is the memory that is available for dynamically creating new\nobjects while a program is executing, e.g., if you create a new object\nin R or call *new* in C++. When more memory is needed the program can\nrequest more from the operating system. When objects are removed in R, R\nwill handle the garbage collection of releasing that memory.\n\nThe *stack* is the memory used for local variables when a function is\ncalled.\n\nThere's a nice discussion of this on [this Stack Overflow\nthread](https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap).\n\n\n## Monitoring memory use\n\n### Monitoring overall memory use on a UNIX-style computer\n\nTo understand how much memory is available on your computer, one needs\nto have a clear understanding of disk caching. The operating system will\ngenerally cache files/data in memory when it reads from disk. Then if\nthat information is still in memory the next time it is needed, it will\nbe much faster to access it the second time around than if it had to\nread the information from disk. While the cached information is using\nmemory, that same memory is immediately available to other processes, so\nthe memory is available even though it is \"in use\".\n\nWe can see this via `free -h` (the `-h` is for 'human-readable', i.e.\nshow in GB (G)) on Linux machine.\n\n```\n          total used free shared buff/cache available \n    Mem:   251G 998M 221G   2.6G        29G      247G \n    Swap:  7.6G 210M 7.4G\n```\n\nYou'll generally be interested in the `Mem` row. (See below for some\ncomments on `Swap`.) The `shared` column is complicated and probably\nwon't be of use to you. The `buff/cache` column shows how much space is\nused for disk caching and related purposes but is actually available.\nHence the `available` column is the sum of the `free` and `buff/cache`\ncolumns (more or less). In this case only about 1 GB is in use\n(indicated in the `used` column).\n\n`top` (Linux or Mac) and `vmstat` (on Linux) both show overall memory\nuse, but remember that the amount actually available to you is the\namount free plus any buff/cache usage. Here is some example output\nfrom `vmstat`:\n\n```\n\n    procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- \n    r b   swpd      free   buff    cache si so bi bo in cs us sy id wa st \n    1 0 215140 231655120 677944 30660296  0  0  1  2  0  0 18  0 82  0  0\n```\n\nIt shows 232 GB free and 31 GB used for cache and therefore available,\nfor a total of 263 GB available.\n\nHere are some example lines from `top`:\n\n```\n    KiB Mem : 26413715+total, 23180236+free, 999704 used, 31335072 buff/cache \n    KiB Swap:  7999484 total,  7784336 free, 215148 used. 25953483+avail Mem\n```\n\nWe see that this machine has 264 GB RAM (the total column in the `Mem`\nrow), with 259.5 GB available (232 GB free plus 31 GB buff/cache as seen\nin the `Mem` row). (I realize the numbers don't quite add up for reasons\nI don't fully understand, but we probably don't need to worry about that\ndegree of exactness.) Only 1 GB is in use.\n\n*Swap* is essentially the reverse of disk caching. It is disk space that\nis used for memory when the machine runs out of physical memory. You\nnever want your machine to be using swap for memory because your jobs\nwill slow to a crawl. As seen above, the `swap` line in both `free` and\n`top` shows 8 GB swap space, with very little in use, as desired.\n\n### Monitoring memory use in R\n\nThere are a number of ways to see how much memory is being used. When R\nis actively executing statements, you can use `top` from the UNIX shell.\nIn R, you can use `gc()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           used (Mb) gc trigger (Mb) max used (Mb)\nNcells  2349054  126    4161768  222  4161768  222\nVcells 14230158  109   23069744  176 14782033  113\n```\n:::\n:::\n\n\n\n`gc()` reports memory use and free memory as `Ncells` and\n`Vcells`. `Ncells` concerns the overhead of running R and `Vcells`\nrelates to objects created by the user, so you'll want to focus on\n`Vcells`. You can see the number of Mb currently used (the \"`used`\"\ncolumn of the output) and the maximum used in the session (the \"`max\nused`\" column)\". \n\nWe can see the size of an object with `object.size()` from base R or `object_size` from pryr:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(1e8) # should use about 800 Mb\nobject.size(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n800000048 bytes\n```\n:::\n\n```{.r .cell-code}\npryr::object_size(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n800,000,048 B\n```\n:::\n:::\n\n\n\nA newer alternative to `gc()` is to use functions in the `pryr`\npackage such as `mem_used()` and `mem_change()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(pryr)\nmem_used() \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1.05 GB\n```\n:::\n\n```{.r .cell-code}\ngc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           used (Mb) gc trigger (Mb) max used (Mb)\nNcells 2.35e+06  126   4.16e+06  222 4.16e+06  222\nVcells 1.14e+08  872   1.67e+08 1275 1.14e+08  872\n```\n:::\n\n```{.r .cell-code}\nrm(x)\nmem_used()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n245 MB\n```\n:::\n\n```{.r .cell-code}\ngc() # note the \"max used\" column is unchanged\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           used (Mb) gc trigger (Mb) max used (Mb)\nNcells  2350391  126   4.16e+06  222 4.16e+06  222\nVcells 14233643  109   1.07e+08  816 1.14e+08  872\n```\n:::\n\n```{.r .cell-code}\nmem_change(x <- rnorm(1e8)) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n800 MB\n```\n:::\n\n```{.r .cell-code}\nmem_change(x <- rnorm(1e7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-720 MB\n```\n:::\n:::\n\n\n\nYou can reset the value given for `max used`, with `gc(reset = TRUE)`.\n\nIn Windows only, `memory.size()` tells how much memory is being used.\n\n\nHere is a useful function, `ls.sizes()`, that wraps `object.size()` to\nreport the largest $n$ objects in a given environment:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nls.sizes <- function(howMany = 10, minSize = 1){\n\tpf <- parent.frame()\n\tobj <- ls(pf) # or ls(sys.frame(-1)) \n\tobjSizes <- sapply(obj, function(x) {\n                               pryr::object_size(get(x, pf))\n                           })\n\t## or sys.frame(-4) to get out of FUN, lapply(), sapply() and sizes()\n\tobjNames <- names(objSizes)\n\thowmany <- min(howMany, length(objSizes))\n\tord <- order(objSizes, decreasing = TRUE)\n\tobjSizes <- objSizes[ord][1:howMany]\n\tobjSizes <- objSizes[objSizes > minSize]\n\tobjSizes <- matrix(objSizes, ncol = 1)\n\trownames(objSizes) <- objNames[ord][1:length(objSizes)]\n\tcolnames(objSizes) <- \"bytes\"\n\tcat('object')\n\tprint(format(objSizes, justify = \"right\", width = 11),\n              quote = FALSE)\n}\n```\n:::\n\n\n\nUnfortunately with R6 and ReferenceClasses, closures, environments, and\nother such \"containers\", it can be hard to see how much memory the\nobject is using, including all the components of the object. Here's a\ntrick where we serialize the object, as if to export it, and then see\nhow long the binary representation is. In this case the object is a closure\nthat contains a large vector.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(pryr)\nx <- rnorm(1e7)\nf <- function(input){\n\tdata <- input\n\tg <- function(param) return(param * data) \n\treturn(g)\n}\nmyFun <- f(x)\nrm(x)\nobject.size(myFun)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1608 bytes\n```\n:::\n\n```{.r .cell-code}\nobject_size(myFun)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n80,013,376 B\n```\n:::\n\n```{.r .cell-code}\nlength(serialize(myFun, NULL))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 160007714\n```\n:::\n:::\n\n\n\nNote that  our discussion of copy-on-modify should help us understand\nwhy the serialized object is 160 MB, but only 80 MB is used to store the 10,000,000 numbers.\n\nHere we examine the size of an environment:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne <- new.env()\ne$x <- rnorm(1e7)\nobject.size(e)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n56 bytes\n```\n:::\n\n```{.r .cell-code}\nobject_size(e)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n80,000,496 B\n```\n:::\n\n```{.r .cell-code}\nlength(serialize(e, NULL))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 80000192\n```\n:::\n:::\n\n\n\nOne frustration with memory management is that if your code bumps up\nagainst the memory limits of the machine, it can be very slow to respond\neven when you're trying to cancel the statement with `Ctrl-C`. You can\nimpose memory limits in Linux by starting R (from the UNIX prompt) in a\nfashion such as this\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nR --max-vsize=1000M\n```\n:::\n\n\n\nThen if you try to create an object that will push you over that limit\nor execute code that involves going over the limit, it will simply fail\nwith the message \"*Error: vector memory exhausted (limit reached?)*\". So\nthis approach may be a nice way to avoid paging/swapping by setting the\nmaximum in relation to the physical memory of the machine. It might also\nhelp in debugging memory leaks because the program would fail at the\npoint that memory use was increasing. I haven't played around with this\nmuch, so I offer this with a note of caution.\n\nApparently there is a memory profiler in R, *Rprofmem*, but it needs to\nbe enabled when R is compiled (i.e., installed on the machine), because\nit slows R down even when not used. So I've never gotten to the point of\nplaying around with it.\n\n## How memory is used in R\n\n### A secret weapon: `inspect`\n\nWe can use an internal function called `inspect` to see where in\nmemory an object is stored. It's particularly useful for understanding storage\nand memory use for complicated data structures.\nWe'll also see that this can be a handy tool for\nseeing where copies are made and where they are not.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(5)\n.Internal(inspect(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n@562ae4acd9e8 14 REALSXP g0c4 [REF(2)] (len=5, tl=0) -0.742042,0.577906,1.85653,0.449136,0.746484\n```\n:::\n:::\n\n\n\nThe first output is the address in memory (in hexadecimal) of the vector. The `REALSXP` indicates that the vector\nis stored as a real-valued \"S\" object under the hood in C. `REF(2)` indicates that two variables are referring to this particular memory location (more on this in much detail in a bit).\n\n\n### Memory use in specific circumstances\n\n#### How lists are stored\n\nHere we can use `inspect()` to see how the overall list is stored as\nwell as the elements of the list and the attributes of the list.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnums <- rnorm(5)\nobj <- list(a = nums, b = nums, c = rnorm(5), d = list(some_string = \"adfs\"))\n.Internal(inspect(obj$a))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n@562ae5e2c778 14 REALSXP g0c4 [REF(4)] (len=5, tl=0) -1.47998,1.38282,0.22264,0.0640071,0.565649\n```\n:::\n\n```{.r .cell-code}\n.Internal(inspect(obj$b))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n@562ae5e2c778 14 REALSXP g0c4 [REF(5)] (len=5, tl=0) -1.47998,1.38282,0.22264,0.0640071,0.565649\n```\n:::\n\n```{.r .cell-code}\n.Internal(inspect(obj$c))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n@562ae777da78 14 REALSXP g0c4 [REF(1)] (len=5, tl=0) -1.07213,-0.451605,-0.0594438,0.153536,-0.939612\n```\n:::\n\n```{.r .cell-code}\n.Internal(inspect(obj))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n@562ae711f078 19 VECSXP g0c3 [REF(2),ATT] (len=4, tl=0)\n  @562ae5e2c778 14 REALSXP g0c4 [REF(6)] (len=5, tl=0) -1.47998,1.38282,0.22264,0.0640071,0.565649\n  @562ae5e2c778 14 REALSXP g0c4 [REF(6)] (len=5, tl=0) -1.47998,1.38282,0.22264,0.0640071,0.565649\n  @562ae777da78 14 REALSXP g0c4 [REF(2)] (len=5, tl=0) -1.07213,-0.451605,-0.0594438,0.153536,-0.939612\n  @562ae6dc2048 19 VECSXP g0c1 [REF(1),ATT] (len=1, tl=0)\n    @562ae709e3f8 16 STRSXP g0c1 [REF(3)] (len=1, tl=0)\n      @562ae709e430 09 CHARSXP g0c1 [REF(2),gp=0x60] [ASCII] [cached] \"adfs\"\n  ATTRIB:\n    @562ae23190e0 02 LISTSXP g0c0 [REF(1)] \n      TAG: @562ad6803730 01 SYMSXP g1c0 [MARK,REF(65535),LCK,gp=0x6000] \"names\" (has value)\n      @562ae6dc2080 16 STRSXP g0c1 [REF(1)] (len=1, tl=0)\n\t@562ae2ad5128 09 CHARSXP g0c2 [REF(4),gp=0x61] [ASCII] [cached] \"some_string\"\nATTRIB:\n  @562ae2319150 02 LISTSXP g0c0 [REF(1)] \n    TAG: @562ad6803730 01 SYMSXP g1c0 [MARK,REF(65535),LCK,gp=0x6000] \"names\" (has value)\n    @562ae711f0c8 16 STRSXP g0c3 [REF(65535)] (len=4, tl=0)\n      @562ad6b055d0 09 CHARSXP g1c1 [MARK,REF(801),gp=0x61] [ASCII] [cached] \"a\"\n      @562ad6e24b80 09 CHARSXP g1c1 [MARK,REF(699),gp=0x61] [ASCII] [cached] \"b\"\n      @562ad6804af0 09 CHARSXP g1c1 [MARK,REF(1006),gp=0x61] [ASCII] [cached] \"c\"\n      @562ad6ca36b0 09 CHARSXP g1c1 [MARK,REF(421),gp=0x61] [ASCII] [cached] \"d\"\n```\n:::\n:::\n\n\n\nWhat do we notice?\n\n  - The list itself is a vector of pointers to the component elements and a pointer to the attributes information.\n  - Each element has its own address.\n  - Attributes are themselves stored in particular locations.\n  - Two elements of a list can use the same memory (see `a` and `b` here, whose contents are at the same memory address).\n  \n\nThe *pryr* package provides `address()` or `inspect()` as an alternative\nto `.Internal(inspect())` though even `pryr::inspect()` doesn't give us the\nrichness of information about complicated objects that `.Internal(inspect())` does.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naddress(obj)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x562ae711f078\"\n```\n:::\n\n```{.r .cell-code}\ninspect(obj)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<VECSXP 0x562ae711f078>\n  <REALSXP 0x562ae5e2c778>\n  [REALSXP 0x562ae5e2c778]\n  <REALSXP 0x562ae777da78>\n  <VECSXP 0x562ae6dc2048>\n    <STRSXP 0x562ae709e3f8>\n      <CHARSXP 0x562ae709e430>\n  attributes: \n    <LISTSXP 0x562ae23190e0>\n    tag: \n      <SYMSXP 0x562ad6803730>\n    car: \n      <STRSXP 0x562ae6dc2080>\n        <CHARSXP 0x562ae2ad5128>\n    cdr: \n      NULL\nattributes: \n  <LISTSXP 0x562ae2319150>\n  tag: \n    [SYMSXP 0x562ad6803730]\n  car: \n    <STRSXP 0x562ae711f0c8>\n      <CHARSXP 0x562ad6b055d0>\n      <CHARSXP 0x562ad6e24b80>\n      <CHARSXP 0x562ad6804af0>\n      <CHARSXP 0x562ad6ca36b0>\n  cdr: \n    NULL\n```\n:::\n\n```{.r .cell-code}\ntry(address(obj$a)) # doesn't work\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nError : x must be the name of an object\n```\n:::\n:::\n\n\n\n\n#### How character strings are stored.\n\nSimilar tricks are used for storing character vectors.\nWe'll explore this in a problem on PS4 using `inspect()`.\n\n#### Replacement functions\n\nReplacement functions can hide the use of additional memory. How\n    much memory is used here? (Try running in R (not RStudio) on your\n    own computer and note the `max_used` column in the `gc()` result\n    should increase after we modify the dimensionality of `x`, indicating a copy was made.)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(x)\ngc(reset = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           used (Mb) gc trigger (Mb) max used (Mb)\nNcells  2351036  126   4.16e+06  222  2351036  126\nVcells 34235774  261   1.07e+08  816 34235774  261\n```\n:::\n\n```{.r .cell-code}\nx <- rnorm(1e7)\ngc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           used (Mb) gc trigger (Mb) max used (Mb)\nNcells  2350961  126   4.16e+06  222  2363241  126\nVcells 44235648  338   1.07e+08  816 44256745  338\n```\n:::\n\n```{.r .cell-code}\ndim(x) <- c(1e4, 1e3)\ndiag(x) <- 1\ngc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           used (Mb) gc trigger (Mb) max used (Mb)\nNcells  2350988  126   4.16e+06  222  2368797  127\nVcells 44235688  338   1.07e+08  816 54268473  414\n```\n:::\n:::\n\n\n\nHowever, not all replacement functions actually involve creating a new object\n    and replacing the original object.  Here\n    `[<-` is a primitive function, so the modification of the vector\n    can be done without a copy in the underlying execution in C. \n\n> **Warning**: For some reason when I compile this document a copy is made. Try it in R (not RStudio) on your own computer,\nand you should see that the address of `x` is unchanged and no additional memory has been used.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(x)\ngc(reset = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           used (Mb) gc trigger (Mb) max used (Mb)\nNcells  2350958  126   4.16e+06  222  2350958  126\nVcells 34235786  261   1.07e+08  816 34235786  261\n```\n:::\n\n```{.r .cell-code}\nx <- rnorm(1e7)\naddress(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x7f97616ec010\"\n```\n:::\n\n```{.r .cell-code}\ngc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           used (Mb) gc trigger (Mb) max used (Mb)\nNcells  2350987  126   4.16e+06  222  2369338  127\nVcells 44235830  338   1.07e+08  816 44267340  338\n```\n:::\n\n```{.r .cell-code}\nx[5] <- 7\n`[<-`\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n.Primitive(\"[<-\")\n```\n:::\n\n```{.r .cell-code}\n## When run plainly in R, should be the same address as before,\n## indicating no copy was made. Rendering the doc messes the\n## result up!\naddress(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x7f975caa0010\"\n```\n:::\n\n```{.r .cell-code}\ngc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           used (Mb) gc trigger (Mb) max used (Mb)\nNcells  2351038  126   4.16e+06  222  2375927  127\nVcells 44235920  338   1.07e+08  816 54277552  414\n```\n:::\n:::\n\n\n\nIt makes some sense that modifying elements of a vector doesn't cause a copy usually -- if it did, working with large vectors would be very difficult. \n\n#### Fast representations of sequences\n\nAs of R 3.5.0, `1:n` is not stored in memory as a vector of length *n*,\nbut rather is represented by the first and last value in the sequence.\nHowever, some of the functions we use to determine object size don't\ngive us the right answer in this case.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(microbenchmark)\n\nn <- 1e6\nmicrobenchmark(tmp <- 1:n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUnit: nanoseconds\n       expr min  lq mean median  uq  max neval\n tmp <- 1:n 168 177  261    182 252 3907   100\n```\n:::\n\n```{.r .cell-code}\nobject.size(tmp)  # incorrect\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4000048 bytes\n```\n:::\n\n```{.r .cell-code}\nobject_size(tmp)  # correct\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n680 B\n```\n:::\n\n```{.r .cell-code}\nmem_change(mySeq <- 1:n)  # not sure why the result is negative!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-11.1 kB\n```\n:::\n\n```{.r .cell-code}\nlength(serialize(mySeq, NULL)) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 133\n```\n:::\n:::\n\n\n\nOne implication is that in older versions of R, indexing large subsets\ncan involve a lot of memory use.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(1e7)\ny <- x[1:(length(x) - 1)]\n```\n:::\n\n\n\nIn this case, in old versions of R, more memory was used than just for\n`x` and `y`, because the index sequence itself used a bunch of memory.\n\n### Copy-on-modify\n\nNext we'll see that something like lazy evaluation occurs as well with some functionality called *delayed copying* or\n*copy-on-modify*. When we discussed R as being call-by-value, copy-on-modify was one of the\nreasons that copies of arguments are not always made. (But we didn't\ntalk about it at that time.)\n\n#### Copy-on-modify in function calls\n\nLet's see what goes on within a function in terms of memory use in\ndifferent situations. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(x)\ngc(reset = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           used (Mb) gc trigger (Mb) max used (Mb)\nNcells  2388091  128   4.16e+06  222  2388091  128\nVcells 34289665  262   1.07e+08  816 34289665  262\n```\n:::\n\n```{.r .cell-code}\nf <- function(x){\n    print(gc())\n    print(x[1])\n    print(gc())\n    .Internal(inspect(x))\n    ## print(address(x))  ## this gives the wrong answer; not sure why\n    return(x)\n}\n\ny <- rnorm(1e7)\ngc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           used (Mb) gc trigger (Mb) max used (Mb)\nNcells  2388071  128   4.16e+06  222  2406247  129\nVcells 44289662  338   1.07e+08  816 44320847  338\n```\n:::\n\n```{.r .cell-code}\n.Internal(inspect(y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n@7f9761068010 14 REALSXP g1c7 [MARK,REF(2)] (len=10000000, tl=0) 1.38438,0.609833,-0.283916,-1.52027,-0.213757,...\n```\n:::\n\n```{.r .cell-code}\nout <- f(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           used (Mb) gc trigger (Mb) max used (Mb)\nNcells  2388101  128   4.16e+06  222  2406247  129\nVcells 44289714  338   1.07e+08  816 44320847  338\n[1] 1.38\n           used (Mb) gc trigger (Mb) max used (Mb)\nNcells  2388111  128   4.16e+06  222  2406247  129\nVcells 44289737  338   1.07e+08  816 44320847  338\n@7f9761068010 14 REALSXP g1c7 [MARK,REF(4)] (len=10000000, tl=0) 1.38438,0.609833,-0.283916,-1.52027,-0.213757,...\n```\n:::\n\n```{.r .cell-code}\n.Internal(inspect(y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n@7f9761068010 14 REALSXP g1c7 [MARK,REF(6)] (len=10000000, tl=0) 1.38438,0.609833,-0.283916,-1.52027,-0.213757,...\n```\n:::\n\n```{.r .cell-code}\n.Internal(inspect(out))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n@7f9761068010 14 REALSXP g1c7 [MARK,REF(7)] (len=10000000, tl=0) 1.38438,0.609833,-0.283916,-1.52027,-0.213757,...\n```\n:::\n:::\n\n\n\nWe see that `y`, the local variable `x` in the function frame, and `out` all use the same memory, so no\ncopies are made here. The `gc()` output confirms that no additional memory was used.\n\nOnly if `x` is changed do the addresses change and a copy in memory get made. (Note that we already saw this with the `diag<-` replacement function example.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(x){\n    .Internal(inspect(x))\n    x[2] <- 7\n    .Internal(inspect(x))\n    return(x)\n}\n\ny <- rnorm(1e7)\n.Internal(inspect(y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n@7f9753207010 14 REALSXP g0c7 [REF(2)] (len=10000000, tl=0) 1.92264,1.19775,1.60747,0.417404,-0.102296,...\n```\n:::\n\n```{.r .cell-code}\nout <- f(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n@7f9753207010 14 REALSXP g0c7 [REF(4)] (len=10000000, tl=0) 1.92264,1.19775,1.60747,0.417404,-0.102296,...\n@7f974e5bb010 14 REALSXP g0c7 [REF(1)] (len=10000000, tl=0) 1.92264,7,1.60747,0.417404,-0.102296,...\n```\n:::\n\n```{.r .cell-code}\n.Internal(inspect(y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n@7f9753207010 14 REALSXP g0c7 [REF(3)] (len=10000000, tl=0) 1.92264,1.19775,1.60747,0.417404,-0.102296,...\n```\n:::\n\n```{.r .cell-code}\n.Internal(inspect(out))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n@7f974e5bb010 14 REALSXP g0c7 [REF(2)] (len=10000000, tl=0) 1.92264,7,1.60747,0.417404,-0.102296,...\n```\n:::\n:::\n\n\n\n#### Copy-on-modify in general\n\nIn fact, copy-on-modify occurs outside function calls as well. Copies of objects\nare not made until one of the objects is actually modified. Initially,\nthe copy points to the same memory location as the original object.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(y); rm(out)\ngc(reset = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           used (Mb) gc trigger (Mb) max used (Mb)\nNcells  2388148  128   4.16e+06  222  2388148  128\nVcells 34290819  262   1.07e+08  816 34290819  262\n```\n:::\n\n```{.r .cell-code}\ny <- rnorm(1e7)\ngc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           used (Mb) gc trigger (Mb) max used (Mb)\nNcells  2388139  128   4.16e+06  222  2400353  128\nVcells 44290803  338   1.07e+08  816 44311790  338\n```\n:::\n\n```{.r .cell-code}\naddress(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x7f9761068010\"\n```\n:::\n\n```{.r .cell-code}\nx <- y\ngc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           used (Mb) gc trigger (Mb) max used (Mb)\nNcells  2388165  128   4.16e+06  222  2406303  129\nVcells 44290848  338   1.07e+08  816 44322007  338\n```\n:::\n\n```{.r .cell-code}\nobject_size(x, y)  # from pryr\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n80,000,048 B\n```\n:::\n\n```{.r .cell-code}\naddress(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x7f9761068010\"\n```\n:::\n\n```{.r .cell-code}\nx[1] <- 5\ngc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           used (Mb) gc trigger (Mb) max used (Mb)\nNcells  2388198  128   4.16e+06  222  2414087  129\nVcells 54290897  414   1.07e+08  816 54333029  415\n```\n:::\n\n```{.r .cell-code}\naddress(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x7f9753207010\"\n```\n:::\n\n```{.r .cell-code}\nobject_size(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n160,000,096 B\n```\n:::\n\n```{.r .cell-code}\nrm(x)\nx <- y\naddress(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x7f9761068010\"\n```\n:::\n\n```{.r .cell-code}\naddress(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x7f9761068010\"\n```\n:::\n\n```{.r .cell-code}\ny[1] <- 5\naddress(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x7f9761068010\"\n```\n:::\n\n```{.r .cell-code}\naddress(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x7f974e5bb010\"\n```\n:::\n:::\n\n\n\nOr we can see this using `mem_change()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(pryr)\nrm(x)\nrm(y)\nmem_change(x <- rnorm(1e7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n80 MB\n```\n:::\n\n```{.r .cell-code}\naddress(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x7f9761068010\"\n```\n:::\n\n```{.r .cell-code}\nmem_change(x[3] <- 8)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n320 B\n```\n:::\n\n```{.r .cell-code}\naddress(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x7f9761068010\"\n```\n:::\n\n```{.r .cell-code}\nmem_change(y <- x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n376 B\n```\n:::\n\n```{.r .cell-code}\naddress(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x7f9761068010\"\n```\n:::\n\n```{.r .cell-code}\nmem_change(x[3] <- 8)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n80 MB\n```\n:::\n\n```{.r .cell-code}\naddress(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x7f9753207010\"\n```\n:::\n\n```{.r .cell-code}\naddress(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x7f9761068010\"\n```\n:::\n:::\n\n\n\n**Challenge**: explain the results of the example above.\n\n#### How does copy-on-modify work?\n\nR keeps track of how many names refer to an object and only makes copies\nas needed when multiple names refer to an object. Note the value of REF\nand the address returned by `.Internal(inspect())`, or simply use\n`refs()` and `address()` from `pryr`.\n\nWe'll see this live in class. Unfortunately both rendering and RStudio\ncan give us confusing results for `refs()`, so I'm adding the clean results from just\nrunning in R as comments here.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- rnorm(5)\naddress(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x562ae525f718\"\n```\n:::\n\n```{.r .cell-code}\n## refs(a)  ## 1\nb <- a\naddress(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x562ae525f718\"\n```\n:::\n\n```{.r .cell-code}\n## refs(a)  ## 2\n## refs(b)  ## 2\nrm(b)\n## refs(a)  ## 1\n\nb <- a\na[2] <- 0\naddress(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x562ae1877c68\"\n```\n:::\n\n```{.r .cell-code}\naddress(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x562ae525f718\"\n```\n:::\n\n```{.r .cell-code}\n## refs(a)  ## 1\n## refs(b)  ## 1\n```\n:::\n\n\n\nThis notion of reference counting occurs in other contexts, such as\nshared pointers in C++ and garbage collection (deletion of unused objects) in Python and R.\n\nIn older versions of R (before R 4.0) there were some shortcomings in\nhow R managed this, and one could see different results than shown\nabove.\n\n## Strategies for saving memory\n\nA couple basic strategies for saving memory include:\n\n-   Avoiding unnecessary copies.\n-   Removing objects that are not being used, at which point the R garbage collector should free up the memory.\n\nIf you're really trying to optimize memory use, you may also consider:\n\n-   Using R6 classes and similar strategies to pass by reference.\n-   Substituting integer and logical vectors for numeric vectors when\n    possible.\n\n## Example\n\nLet's work through a real example where we keep a running tally of\ncurrent memory in use and maximum memory used in a function call. We'll\nwant to consider hidden uses of memory, when copies are made, and lazy\nevaluation.  This\ncode is courtesy of Yuval Benjamini. For our purposes here, let's assume\nthat `xvar` and `yvar` are very long vectors using a lot of memory. The\nuse of `.C()` calls out to some user-written C code. (In a real example we'd also want to think about when copies\nare made in calling compiled code, but we don't do that here.)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfastcount <- function(xvar, yvar) {\n    print(xvar[1])\n    print(yvar[1])\n    naline <- is.na(xvar)\n    naline[is.na(yvar)] = TRUE\n    xvar[naline] <- 0\n    yvar[naline] <- 0\n    useline <- !naline\n    ## We'll ignore the rest of the code.\n    ## Table must be initialized for -1's\n    tablex <- numeric(max(xvar)+1)\n    tabley <- numeric(max(yvar)+1)\n    stopifnot(length(xvar) == length(yvar))\n    res <- .C(\"fastcount\",PACKAGE=\"GCcorrect\",\n              tablex = as.integer(tablex), tabley = as.integer(tabley),\n              as.integer(xvar), as.integer(yvar), as.integer(useline),\n              as.integer(length(xvar)))\n    xuse <- which(res$tablex>0)\n    xnames <- xuse - 1\n    resb <- rbind(res$tablex[xuse], res$tabley[xuse]) \n    colnames(resb) <- xnames\n    return(resb)\n}\n```\n:::\n\n\n\n\n\n# 9. Efficiency\n\nUnder construction.\n\n# 10. Computing on the language (optional)\n\nUnder construction.\n",
    "supporting": [
      "unit5-programming_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}